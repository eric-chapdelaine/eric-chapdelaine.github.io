I"ËÒ<h1 id="lecture-1---introduction">Lecture 1 - Introduction</h1>

<p><strong>What is Computer Science?</strong></p>

<ul>
  <li>Telling a computer what to do</li>
  <li>The science behind how computers run</li>
  <li>Problem solving</li>
</ul>

<p>Computer science is to computers as microscopes are to biology.</p>

<p>This course is about how to solve problems, NOT how to use the tools to solve problems. Learning universal computer science and not the tools.</p>

<h2 id="the-course">The Course</h2>

<p>The course website is on canvas</p>

<ul>
  <li>You need a Khoury College account</li>
  <li>We will be using Piazza</li>
</ul>

<p><strong>Piazza:</strong></p>

<ul>
  <li>Announcements</li>
  <li>Wiki for the class</li>
  <li>Questions and Answers</li>
</ul>

<p><strong>Homework:</strong></p>

<ul>
  <li>Due Friday evenings (but should be done Thursday)</li>
  <li>Check all homework on Canvas</li>
</ul>

<h2 id="rules-of-evaluation">Rules of Evaluation</h2>

<p>Like the order of operations but for computer science</p>

<h3 id="syntax-of-arithmetic">Syntax of Arithmetic</h3>

\[12 + 6-\]

<p>This is an example of incorrect syntax</p>

<h3 id="semantics--meaning">Semantics / Meaning</h3>

<p>Shows how to go from a valid arithmetic expression to an answer.</p>

\[5 \times 7 + \frac{21}{3}\]

<p>Why does this equal 42?</p>

<ul>
  <li>Order of operations (Rules of Evaluation)</li>
</ul>

<p><strong>Breakdown:</strong></p>

\[35 + \frac{21}{3}\]

\[35+7=42\]

<p><strong>Example:</strong></p>

\[3x-2\]

<p>Can‚Äôt tell what this is yet because it‚Äôs not complete</p>

<p>Let $x=8$</p>

<p>Now it is 22 (because $3(8) -2=22$)</p>

<h1 id="lecture-2---intro-to-dr-racket-and-image-manipulation">Lecture 2 - Intro to Dr Racket and Image Manipulation</h1>

<h2 id="homework">Homework</h2>

<p>Do the assigned reading before the week (lightly). Once the lecture is over, go back and read the book.</p>

<p>How to read a technical book:</p>

<p>You can‚Äôt read it as a ‚Äònormal‚Äô book. Type along with the examples. Try out different variations of the presented code</p>

<h2 id="drracket">DrRacket</h2>

<p>Use the ‚ÄòBeginning Student Language‚Äô</p>

<p>Recall:</p>

<ul>
  <li>1+2<em>4 ‚Üí(+ 1 (</em> 2 4))
    <ul>
      <li>This makes the order of operations obvious</li>
    </ul>
  </li>
  <li>Strings have to wrapped in double quotations</li>
</ul>

<p>Dr Racket is split up into two panels, the top one is used for code that you want to keep and the bottom one can be thought of as interactive (it runs each line when you hit enter)</p>

<h3 id="string-manipulation">String Manipulation</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">replicate</span> <span class="mi">10</span> <span class="s">"hi "</span><span class="p">)</span>
<span class="c1">; "hi hi hi hi hi hi hi hi hi hi "</span>
</code></pre></div></div>

<h3 id="image-manipulation">Image Manipulation</h3>

<p>Import Library:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
<span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">)</span> <span class="c1">; returns a solid, red circle of radius 10</span>
<span class="p">(</span><span class="nf">rectange</span> <span class="mi">300</span> <span class="mi">200</span> <span class="s">"outline"</span> <span class="s">"blue"</span><span class="p">)</span> <span class="c1">; Returns rectangle width 300,</span>
												<span class="c1">;height 200</span>
</code></pre></div></div>

<p>Other Functions of Images</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">beside</span> <span class="p">[</span><span class="nf">image1</span><span class="p">]</span> <span class="p">[</span><span class="nf">image2</span><span class="p">])</span>
<span class="p">(</span><span class="nf">overlay</span> <span class="p">[</span><span class="nf">image1</span><span class="p">]</span> <span class="p">[</span><span class="nf">image2</span><span class="p">])</span>
</code></pre></div></div>

<p>NOTE: Both of these functions return an image (you can nest these functions)</p>

<p><strong>place-image</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">place-image</span> <span class="nv">IMAGE</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">scene</span><span class="p">)</span> <span class="c1">; see documentation for more</span>
</code></pre></div></div>

<p>NOTE: The origin point is the top left corner</p>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Create an image of a setting sun with a blue background</span>
<span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span> <span class="s">"yellow"</span><span class="p">)</span> <span class="c1">; sun</span>
<span class="p">(</span><span class="nf">rectangle</span> <span class="mi">300</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"blue"</span><span class="p">)</span> <span class="c1">; sky</span>

<span class="p">(</span><span class="nf">place-image</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"yellow"</span><span class="p">)</span> <span class="mi">40</span> <span class="mi">50</span>
						<span class="p">(</span><span class="nf">rectangle</span> <span class="mi">400</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"blue"</span><span class="p">)</span>
</code></pre></div></div>

<p>This code is ugly and doesn‚Äôt represent how humans think about. We assign names to things. For example <code class="language-plaintext highlighter-rouge">(circle 10 "solid" "yellow")</code> is the <code class="language-plaintext highlighter-rouge">sun</code>. To do this, we use the <code class="language-plaintext highlighter-rouge">define</code> function.</p>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">SUN</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"yellow"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">400</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"blue"</span><span class="p">))</span>

<span class="p">(</span><span class="nf">place-image</span> <span class="nv">SUN</span> <span class="mi">300</span> <span class="mi">500</span> <span class="nv">SKY</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="functions">Functions</h2>

<p>What is a function?</p>

\[f(t)=30 - \frac{1}{2}9.8^{2}\]

<p>This function explains how far an object will have gone <code class="language-plaintext highlighter-rouge">t</code> seconds after dropping.</p>

<p>There are 3 things abou thtis function</p>

<ol>
  <li>The name of the function</li>
  <li>The argument(s)</li>
  <li>The body of the function</li>
</ol>

<h3 id="drracket-1">DrRacket</h3>

<p><code class="language-plaintext highlighter-rouge">(define ([name] [argument[s]) (body of the function))</code></p>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">ACCEL-BY-GRAVITY</span> <span class="mf">9.8</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">free-fall</span> <span class="nv">t</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">-</span> <span class="mi">30</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">ACCEL-BY-GRAVITY</span> <span class="nv">t</span> <span class="nv">t</span><span class="p">))</span>
</code></pre></div></div>

<p>Example: Example drawing function in DrRacket</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Draw a sun with y-point `y`</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-sun</span> <span class="nv">y</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">place-image</span> <span class="nv">SUN</span> <span class="mi">300</span> <span class="nv">y</span> <span class="nv">SKY</span><span class="p">))</span>
</code></pre></div></div>

<p>But what about ‚Äòreal‚Äô animations?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Include draw-sun function from previous example</span>
<span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>
<span class="p">(</span><span class="nf">animate</span> <span class="nv">draw-sun</span><span class="p">)</span> <span class="c1">; Input a function that will be incremented every</span>
									<span class="c1">; tick</span>
</code></pre></div></div>
<h1 id="lecture-3---conditions-and-functions">Lecture 3 - Conditions and Functions</h1>

<h3 id="functions-1">Functions</h3>

<p>Recall this math equation from <a href="Lecture%202%20-%20Intro%20to%20Dr%20Racket%20and%20Image%20Manipulat%206769d1599dd84aba921baee4d63089f3.md">Lecture 2 - Intro to Dr Racket and Image Manipulation</a></p>

\[f(t) = 30 - \frac{1}{2} 9.8^{2}\]

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; whole program not shown</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">free-fall</span> <span class="nv">t</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">-30</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">1</span><span class="nv">/2</span> <span class="nv">ACCEL-BY-GRAVITY</span> <span class="nv">t</span> <span class="nv">t</span><span class="p">)))</span>
</code></pre></div></div>

<p><strong>Solving By Substitution</strong></p>

<p>Racket replaces all variables by the actual parameter/variable value. If you put in <code class="language-plaintext highlighter-rouge">3</code> into free-fall, it would handle it as follows</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-</span> <span class="mi">30</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">1</span><span class="nv">/2</span> <span class="mf">9.8</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">))</span> <span class="nv">=</span> <span class="mf">-14.1</span>
</code></pre></div></div>

<h2 id="racket">Racket</h2>

<h3 id="numbers-in-racket">Numbers in Racket:</h3>

<p>Whenever you write $\frac{1}{2}$or $\frac{1}{3}$, you aren‚Äôt doing the division (the language handles it as a single number). To actually do the division, do <code class="language-plaintext highlighter-rouge">(/ 1 2)</code></p>

<h3 id="comments">Comments</h3>

<p>Block Comments: <code class="language-plaintext highlighter-rouge">#| [CODE] |#</code></p>

<p>Single Line: <code class="language-plaintext highlighter-rouge">;</code></p>

<h3 id="check-expect">Check-Expect</h3>

<p>Checks return value against an expected value. Shows ‚Äòhalloween‚Äô colors where your code hasn‚Äôt run in the tests.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">check-expect</span> <span class="p">[</span><span class="nf">function</span> <span class="nv">with</span> <span class="nv">value</span><span class="p">]</span> <span class="p">[</span><span class="nf">expected</span> <span class="nv">value</span><span class="p">])</span>
</code></pre></div></div>

<p>For example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">price-&gt;yelp</span> <span class="mi">100</span><span class="p">)</span> <span class="s">"$$$"</span><span class="p">)</span> <span class="c1">; Returns 'The test passed!'</span>
</code></pre></div></div>

<h3 id="stepper">Stepper</h3>

<p>Shows how BSL uses substitiution in its code. Acts as a debugger.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$f</span><span class="p">(</span><span class="nf">t</span><span class="p">)</span> <span class="nv">=</span> <span class="mi">30</span> <span class="nv">-</span> <span class="err">\</span><span class="nv">frac</span><span class="err">{</span><span class="mi">1</span><span class="err">}{</span><span class="mi">2</span><span class="err">}</span> <span class="mf">9.8</span><span class="nv">^</span><span class="err">{</span><span class="mi">2</span><span class="err">}</span><span class="nv">$</span>
</code></pre></div></div>

<h3 id="booleans">Booleans</h3>

<p>Any yes/no or true/false answer. In BSL, they are represented by <code class="language-plaintext highlighter-rouge">#true</code> and <code class="language-plaintext highlighter-rouge">#false</code></p>

<h3 id="predicates">Predicates</h3>

<p>A function that returns a boolean. Usually ends with <code class="language-plaintext highlighter-rouge">?</code> and it‚Äôs pronounced ‚Äòhuh‚Äô. Example <code class="language-plaintext highlighter-rouge">string?</code> is pronounced string-huh?</p>

<h2 id="sunset-problem">Sunset Problem</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
<span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">SUN</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"yellow"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">100</span> <span class="s">"solid"</span> <span class="s">"blue"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">NIGHT-SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">100</span> <span class="s">"solid"</span> <span class="s">"black"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">MOON</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"gray"</span><span class="p">))</span>

<span class="p">(</span><span class="nf">place-image</span> <span class="mi">100</span> <span class="mi">33</span> <span class="nv">SUN</span> <span class="mi">100</span> <span class="mi">33</span> <span class="nv">SKY</span><span class="p">))</span><span class="c1">; Places the SUN in the SKY</span>

<span class="p">(</span><span class="nf">place-image</span> <span class="nv">MOON</span> <span class="mi">50</span> <span class="mi">33</span> <span class="p">(</span><span class="nf">place-image</span> <span class="nv">SUN</span> <span class="mi">100</span> <span class="mi">33</span> <span class="nv">SKY</span><span class="p">))</span><span class="c1">; Places the moon and sun in the sky</span>

<span class="c1">;  Places the moon at the given x</span>
<span class="c1">; coordinate on an image of the sun and the sky.</span>
<span class="c1">; eclipse: Number -&gt; Image</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">eclipse</span> <span class="nv">moon-x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">place-image</span> <span class="nv">MOON</span> <span class="nv">moon-x</span> <span class="mi">33</span> <span class="p">(</span><span class="nf">place-image</span> <span class="nv">SUN</span> <span class="mi">100</span> <span class="mi">33</span> <span class="nv">SKY</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">animate</span> <span class="nv">eclipse</span><span class="p">)</span><span class="c1">; Run and incriment eclipse every `tick'</span>
</code></pre></div></div>

<p>Now let‚Äôs try to write the eclipse function with a conditional (See later in the lecture for conditionals)</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;  Places the moon at the given x</span>
<span class="c1">; coordinate on an image of the sun and the sky.</span>
<span class="c1">; eclipse: Number -&gt; Image</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">eclipse</span> <span class="nv">moon-x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">place-image</span> <span class="nv">MOON</span> <span class="nv">moon-x</span> <span class="mi">33</span> <span class="p">(</span><span class="nf">place-image</span> <span class="nv">SUN</span> <span class="mi">100</span> <span class="mi">33</span>
        <span class="p">(</span><span class="k">cond</span>
            <span class="p">[</span> <span class="o">..</span><span class="nv">to</span> <span class="nv">the</span> <span class="nv">left</span><span class="o">..</span> <span class="nv">SKY</span><span class="p">]</span>
            <span class="p">[</span> <span class="o">..</span><span class="nv">covering</span><span class="o">..</span> <span class="nv">NIGHT-SKY</span><span class="p">]</span>
            <span class="p">[</span> <span class="o">..</span><span class="nv">to</span> <span class="nv">the</span> <span class="nv">right</span><span class="o">..</span> <span class="nv">SKY</span><span class="p">]))))</span>
<span class="p">(</span><span class="nf">animate</span> <span class="nv">eclipse</span><span class="p">)</span><span class="c1">; Run and incriment eclipse every `tick'</span>
</code></pre></div></div>

<h2 id="conditionals">Conditionals</h2>

<p>Goes through the tests until one of them is true, then it runs the corresponding code.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">cond</span>
    <span class="p">[</span><span class="nf">test-1</span> <span class="nv">answer-1</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">test-2</span> <span class="nv">answer-2</span><span class="p">])</span>
</code></pre></div></div>

<p>Example: <code class="language-plaintext highlighter-rouge">price-&gt;yelp</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; price-&gt;yelp (pronounced "price to yelp")</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">price-&gt;</span> <span class="nv">price</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
        <span class="p">[(</span><span class="nb">&gt;</span> <span class="nv">price</span> <span class="mi">50</span><span class="p">)</span> <span class="s">"\$\$\$\$"</span><span class="p">]</span>
        <span class="p">[(</span><span class="nb">&gt;</span> <span class="nv">price</span> <span class="mi">30</span><span class="p">)</span> <span class="s">"\$\$\$"</span><span class="p">]</span>
        <span class="p">[(</span><span class="nb">&gt;</span> <span class="nv">price</span> <span class="mi">15</span><span class="p">)</span> <span class="s">"\$\$"</span><span class="p">]</span>
        <span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">price</span> <span class="mi">15</span><span class="p">)</span> <span class="s">"\$"</span><span class="p">]))</span>
        <span class="c1">; if you don't want the last check,</span>
				<span class="c1">;use `else' in the condititon to catch everything else</span>
</code></pre></div></div>
<h1 id="lecture-4---how-to-write-functions">Lecture 4 - How to Write Functions</h1>

<p>From Lecture 3‚Äôs class:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
<span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">SUN</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">25</span> <span class="s">"solid"</span> <span class="s">"yellow"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">MOON</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">25</span> <span class="s">"solid"</span> <span class="s">"gray"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"light blue"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">NIGHT-SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"black"</span><span class="p">))</span>

<span class="c1">; draw-eclipse : Number -&gt; Image</span>
<span class="c1">; Draw the moon at the given x-coordinate, on a scene with the</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-eclipse</span> <span class="nv">x-moon</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">place-image</span> <span class="nv">MOON</span> <span class="nv">x-moon</span> <span class="mi">100</span> <span class="p">(</span><span class="nf">place-image</span> <span class="nv">SUN</span> <span class="mi">100</span> <span class="mi">100</span> <span class="p">(</span><span class="k">cond</span>
                                                          <span class="p">[</span><span class="nf">test-2</span> <span class="nv">SKY</span><span class="p">]</span>
                                                          <span class="p">[</span><span class="nf">test-2</span> <span class="nv">NIGHT-SKY</span><span class="p">]))))</span>

<span class="p">(</span><span class="nf">animate</span> <span class="nv">draw-eclipse</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="programming-style">Programming Style:</h3>

<ul>
  <li>It doesn‚Äôt really matter but as long as it‚Äôs consistant
    <ul>
      <li>Writing is just a small part of programming</li>
    </ul>
  </li>
  <li><a href="https://course.ccs.neu.edu/cs2500/style.html">https://course.ccs.neu.edu/cs2500/style.html</a> for course style guide</li>
</ul>

<p>Examples:</p>

<ul>
  <li>Having really long lines (usually 80 characters; 102 for this course)</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">cond</span>
  <span class="p">[</span><span class="nf">test-2</span> <span class="nv">SKY</span><span class="p">]</span>
  <span class="p">[</span><span class="nf">test-2</span> <span class="nv">NIGHT-SKY</span><span class="p">])</span>

</code></pre></div></div>

<p>Notice how each condition is on its own line and they are properly indented</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
<span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">SUN</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">25</span> <span class="s">"solid"</span> <span class="s">"yellow"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">MOON</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">25</span> <span class="s">"solid"</span> <span class="s">"gray"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"light blue"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">NIGHT-SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"black"</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">DARK-SKY</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"blue"</span><span class="p">))</span>

<span class="c1">; draw-eclipse : Number -&gt; Image</span>
<span class="c1">; Draw the moon at the given x-coordinate, on a scene with the</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-eclipse</span> <span class="nv">x-moon</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">place-image</span>
   <span class="nv">MOON</span>
   <span class="nv">x-moon</span>
   <span class="mi">100</span>
   <span class="p">(</span><span class="nf">place-image</span>
    <span class="nv">SUN</span>
    <span class="mi">100</span>
    <span class="mi">100</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="k">or</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">x-moon</span> <span class="mi">50</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">x-moon</span> <span class="mi">150</span><span class="p">))</span> <span class="nv">SKY</span><span class="p">]</span>
      <span class="p">[(</span><span class="nb">=</span> <span class="nv">x-moon</span> <span class="mi">100</span><span class="p">)</span> <span class="nv">NIGHT-SKY</span><span class="p">]</span>
      <span class="p">[(</span><span class="nb">&lt;=</span> <span class="mi">50</span> <span class="nv">x-moon</span> <span class="mi">150</span><span class="p">)</span> <span class="nv">DARK-SKY</span><span class="p">]))))</span> <span class="c1">; between 50 - 100 - 150</span>

<span class="p">(</span><span class="nf">animate</span> <span class="nv">draw-eclipse</span><span class="p">)</span>

</code></pre></div></div>

<h2 id="how-do-get-started-writing-functions">How do get started writing functions:</h2>

<ul>
  <li>Function Signatures</li>
  <li>Purpose Statement: Higher level (short) description for what the function does.</li>
  <li>The Function Definition</li>
  <li>The <code class="language-plaintext highlighter-rouge">check-expects</code></li>
</ul>

<p><strong>Designing Functions:</strong></p>

<ul>
  <li>Signature</li>
  <li>Purpose Statement</li>
  <li>Function Definition</li>
</ul>

<p><strong>Designing Data:</strong></p>

<ul>
  <li>Data Definition</li>
  <li>Interpretation</li>
  <li>Examples</li>
</ul>

<p>Prompt: Create a function that takes in a numerical grade and returns a letter grade</p>

<p><strong>Signature</strong>: num-&gt;grade : Number -&gt; String
Can be multiple lines to define data types</p>

<p><strong>Purpose Statement</strong>: Given a numeric grade, produces a letter grade</p>

<p><strong>Function Template</strong>: Used to copy and paste for similar functions (such as <code class="language-plaintext highlighter-rouge">lettergrade-&gt;gpa</code>, <code class="language-plaintext highlighter-rouge">lettergrade-&gt;passing?</code>)</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; letter-grade-template : LetterGrade -&gt; ?</span>

<span class="o">#</span><span class="nv">|</span> <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">letter-grade-template</span> <span class="nv">lg</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond</span>
	<span class="p">[(</span><span class="nb">string=?</span> <span class="nv">lg</span> <span class="s">"A"</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
	<span class="p">[(</span><span class="nb">string=?</span> <span class="nv">lg</span> <span class="s">"B"</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
	<span class="p">[(</span><span class="nb">string=?</span> <span class="nv">lg</span> <span class="s">"C"</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
	<span class="p">[(</span><span class="nb">string=?</span> <span class="nv">lg</span> <span class="s">"D"</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
	<span class="p">[(</span><span class="nb">string=?</span> <span class="nv">lg</span> <span class="s">"F"</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>
<span class="nv">|</span><span class="o">#</span> <span class="c1">;This is a block comment</span>

</code></pre></div></div>

<p><strong>Examples (<code class="language-plaintext highlighter-rouge">check-expects</code>)</strong>: Examples of what inputs lead to what outputs</p>

<p><strong>The Funtion Body</strong>: the function itself</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; A NumericGrade is a real number in [0,100]</span>
<span class="c1">; Interpretation: A student's numeric grade in Fundies I.</span>

<span class="c1">; A LetterGrade is a one of</span>
<span class="c1">; - "A"</span>
<span class="c1">; - "B"</span>
<span class="c1">; - "C"</span>
<span class="c1">; - "D"</span>
<span class="c1">; - "F" ; An enumerated data definition</span>
<span class="c1">; Interpretation: A student's letter grade is Fundies I.</span>

<span class="c1">; num-&gt;grade : NumericGrade -&gt; LetterGrade</span>
<span class="c1">; Given a numeric grade, produces a letter grade</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">num-&gt;grade</span> <span class="mi">93</span><span class="p">)</span> <span class="s">"A"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">num-&gt;grade</span> <span class="mi">88</span><span class="p">)</span> <span class="s">"B"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">num-&gt;grade</span> <span class="mi">72</span><span class="p">)</span> <span class="s">"C"</span><span class="p">)</span>
<span class="c1">; Unreasonable Examples</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">num-&gt;grade</span> <span class="mi">-10</span><span class="p">)</span> <span class="s">"F"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">num-&gt;grade</span> <span class="mi">101</span><span class="p">)</span> <span class="s">"A"</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">num-&gt;grade</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond</span>
		<span class="p">[(</span><span class="nb">&gt;=</span> <span class="nv">n</span> <span class="mi">90</span><span class="p">)</span> <span class="s">"A"</span><span class="p">]</span>
		<span class="p">[(</span><span class="nb">&gt;=</span> <span class="nv">n</span> <span class="mi">80</span><span class="p">)</span> <span class="s">"B"</span><span class="p">]</span>
		<span class="p">[(</span><span class="nb">&gt;=</span> <span class="nv">n</span> <span class="mi">70</span><span class="p">)</span> <span class="s">"C"</span><span class="p">]</span>
		<span class="p">[(</span><span class="nb">&gt;=</span> <span class="nv">n</span> <span class="mi">60</span><span class="p">)</span> <span class="s">"D"</span><span class="p">]</span>
		<span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">40</span><span class="p">)</span> <span class="s">"F"</span><span class="p">]))</span>


<span class="c1">; A LetterGrade is a one of</span>
<span class="c1">; - "A"</span>
<span class="c1">; - "B"</span>
<span class="c1">; - "C"</span>
<span class="c1">; - "D"</span>
<span class="c1">; - "F"</span>
<span class="c1">; Given a letter grade, determine if it is a passing grade.</span>
<span class="c1">; grade-&gt;passing? : LetterGrade -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">grade-&gt;passing?</span> <span class="nv">lg</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond</span>
	<span class="p">[(</span><span class="nf">string-equals?</span> <span class="nv">lg</span> <span class="s">"A"</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
	<span class="p">[(</span><span class="nf">string-equals?</span> <span class="nv">lg</span> <span class="s">"B"</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
	<span class="p">[(</span><span class="nf">string-equals?</span> <span class="nv">lg</span> <span class="s">"C"</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
	<span class="p">[(</span><span class="nf">string-equals?</span> <span class="nv">lg</span> <span class="s">"D"</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]</span>
	<span class="p">[(</span><span class="nf">string-equals?</span> <span class="nv">lg</span> <span class="s">"F"</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]))</span>


</code></pre></div></div>

<h1 id="lecture-5---extended-how-to-write-functions">Lecture 5 - Extended How to Write Functions</h1>

<h3 id="recap-on-lecture-4---how-to-write-functions-">Recap on <a href="Lecture%204%20-%20How%20to%20Write%20Functions%20f068d9b1c2884de4923c8927ce53740c.md">Lecture 4 - How to Write Functions</a> :</h3>

<p>Two things you need to design for a program: - Data - You will rarely need to accept all numbers. It‚Äôs a subset of all real numbers (‚Ñï). Examples of this are GPA‚Äôs are between 0 and 4 - Functions</p>

<hr />

<h3 id="lecture-5">Lecture 5</h3>

<p>Example: convert temperature from celcius to fahrenheit</p>

<p>Note: use <strong>VAR</strong> to represent the variable ‚ÄòVAR‚Äô in comments. Essentially quotation marks</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Celcius is a Number greater than or equal to -273</span>
<span class="c1">; Interpretation: A temperature expressed in celcius.</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">celcius-ex-freezing</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">celcius-ex-boiling</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1">; celcius-template : Celcius -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">celcius-template</span> <span class="nv">ctemp</span><span class="p">)</span>
  <span class="p">(</span><span class="o">...</span> <span class="nv">ctemp</span> <span class="o">...</span><span class="p">))</span>
<span class="c1">; Not too much info can be given in the template, but use ctemp</span>

<span class="c1">; Fahrenheit is a Number greater than or equal to -460</span>
<span class="c1">; Interpretation: A tempature expressed in fahrenheit</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">fahrenheit-ex-freezing</span> <span class="mi">32</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">farhrenheit-ex-boiling</span> <span class="mi">212</span><span class="p">)</span>

<span class="c1">; fahrenheit-template : Fahrenheit -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fahrenheit-template</span> <span class="nv">ftemp</span><span class="p">)</span>
  <span class="p">(</span><span class="o">...</span> <span class="nv">ftemp</span> <span class="o">...</span><span class="p">))</span> <span class="c1">; Not useful now, but just in case fahrenheit is the input</span>

<span class="c1">; c-&gt;f : Celcius -&gt; Fahrenheit</span>
<span class="c1">; Converts the given _ctemp_ in celcius to a</span>
<span class="c1">; temperature in fahrenheit.</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">c-&gt;f</span> <span class="nv">celcius-ex-freezing</span><span class="p">)</span> <span class="nv">fahrenheit-ex-freezing</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">c-&gt;f</span> <span class="nv">celcius-ex-boiling</span><span class="p">)</span> <span class="nv">farhrenheit-ex-boiling</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">c-&gt;f</span> <span class="nv">ctemp</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">9</span> <span class="mi">5</span><span class="p">)</span> <span class="nv">ctemp</span><span class="p">)</span> <span class="mi">32</span><span class="p">))</span>
</code></pre></div></div>

<p>Example 2: Design a traffic light</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
<span class="c1">; A TrafficLight is a:</span>
<span class="c1">; - "Red"</span>
<span class="c1">; - "Yellow"</span>
<span class="c1">; - "Green"</span>
<span class="c1">; Interpretation: The color of the active lightbulb in a standard U.S. traffic light.</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">TL-RED</span> <span class="s">"Red"</span><span class="p">)</span> <span class="c1">; Constants are used to you don't make capitalization mistakes</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">TL-YELLOW</span> <span class="s">"Yellow"</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">TL-GREEN</span> <span class="s">"Green"</span><span class="p">)</span>

<span class="c1">; tl-template : TrafficLight -&gt; ?</span>
<span class="c1">;(define (tl-template tl)</span>
<span class="c1">;  (cond</span>
<span class="c1">;    [(string=? tl TL-RED) test-1 ...]</span>
<span class="c1">;    [(string=? tl TL-YELLOW) test-2 ...]</span>
<span class="c1">;    [(string=? tl TL-GREEN) test-3 ...]))</span>

<span class="c1">; Takes a __TrafficLight__ and returns an image of the corresponding light (__TrafficImage__)</span>
<span class="c1">; A TrafficImage is a circle with color red, yellow, or green</span>
<span class="c1">; draw-traffic-light : TrafficLight -&gt; TrafficImage</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">draw-light</span> <span class="nv">TL-RED</span><span class="p">)</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">40</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-traffic-light</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">circle</span> <span class="mi">40</span> <span class="s">"solid"</span> <span class="nv">tl</span><span class="p">))</span>

<span class="p">(</span><span class="nf">draw-traffic-light</span> <span class="nv">TL-GREEN</span><span class="p">)</span>

<span class="c1">; ran out of time for the signature :/</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">next-light</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-RED</span><span class="p">)</span> <span class="nv">TL-GREEN</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-YELLOW</span><span class="p">)</span> <span class="nv">TL-RED</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-GREEN</span><span class="p">)</span> <span class="nv">TL-YELLOW</span><span class="p">]))</span>

</code></pre></div></div>
<h1 id="lecture-6---big-bang-and-helper-functions">Lecture 6 - Big Bang and Helper Functions</h1>

<p>HW 2 - Do with the same partners at HW1</p>

<h2 id="recall-from-lecture-5---extended-how-to-write-functions">Recall from <a href="Lecture%205%20-%20Extended%20How%20to%20Write%20Functions%20aa802bb5a45944bdb0a8f925d6d5de21.md">Lecture 5 - Extended How to Write Functions</a></h2>

<p>Writing a function that handles TrafficLights</p>

<p>Datatype TrafficLight is an <code class="language-plaintext highlighter-rouge">enumerated data list</code> with three different possible String possibilities</p>

<ul>
  <li>‚ÄúGreen‚Äù</li>
  <li>‚ÄúYellow‚Äù</li>
  <li>‚ÄúRed‚Äù</li>
</ul>

<p>Functions:</p>

<p><code class="language-plaintext highlighter-rouge">next-light</code> - Given a traffic light, return the next color</p>

<ul>
  <li>Only three different possible examples. Below is the exhuastive set of examples (which means that it‚Äôs essentially your function definition)
    <ul>
      <li>Red ‚ÜíGreen</li>
      <li>Yellow ‚ÜíRed</li>
      <li>Green ‚ÜíYellow</li>
    </ul>
  </li>
</ul>

<h3 id="animation">Animation</h3>

<ul>
  <li>Can‚Äôt use <code class="language-plaintext highlighter-rouge">animate</code> because it returns an incremented number which isn‚Äôt compatable with the TrafficLight datatype</li>
</ul>

<p>so instead we have to use‚Ä¶</p>

<h3 id="big-bang">Big-Bang</h3>

<ul>
  <li>More powerful than animate</li>
</ul>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">big-bang</span>
	<span class="nv">TL-RED</span> <span class="c1">; Initial State</span>
	<span class="p">[</span><span class="nf">on-draw</span> <span class="nv">draw-light</span><span class="p">]</span> <span class="c1">; Do this event every tick)</span>
	<span class="p">[</span><span class="nf">on-tick</span> <span class="nv">next-light</span><span class="p">]</span> <span class="mf">0.25</span><span class="p">)</span> <span class="c1">; What to do every tick (incrementation</span>
	<span class="c1">; The 0.25 denotes the rate of animation</span>

</code></pre></div></div>

<p>How Big-Bang works (it requires 2htdp/universe)</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">on-draw</code> on initial state</li>
  <li><code class="language-plaintext highlighter-rouge">on-tick</code> creates new scene with given state</li>
  <li>There can be more event handlers (see documentation for more information)</li>
</ol>

<h3 id="traffic-light-example">Traffic Light Example</h3>

<p>Return a full image of traffic light with all colors and have the active on solid (with the others outlined)</p>

<h3 id="helper-functions">Helper Functions</h3>

<ul>
  <li>A function that simplifies the main function by doing repeatative tasks in a different function</li>
</ul>

<p>Example:</p>

<p>Draw a TrafficLight bulb with color <strong>tl</strong> and the corresponding outlined/solid</p>

<p>If you have a <code class="language-plaintext highlighter-rouge">cond</code> with only two possibilities, use an <code class="language-plaintext highlighter-rouge">if</code> statement which is structured as follows: <code class="language-plaintext highlighter-rouge">(if (condition) (IF_TRUE) (IF_FALSE))</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Draw a traffic light blub with color _tl_, that is either on or off, depending</span>
<span class="c1">; on the color of the active light.</span>
<span class="c1">; (string=? tl active-tl)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-bulb/v2</span> <span class="nv">tl</span> <span class="nv">active-tl</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">circle</span>
   <span class="mi">30</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">active-tl</span><span class="p">)</span>
       <span class="s">"solid"</span>
       <span class="s">"outline"</span><span class="p">)</span>
   <span class="nv">tl</span><span class="p">))</span>
</code></pre></div></div>

<p>Full Code from Class:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
<span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>

<span class="c1">; A TrafficLight is a:</span>
<span class="c1">; - "Red"</span>
<span class="c1">; - "Yellow"</span>
<span class="c1">; - "Green"</span>
<span class="c1">; Interpretation: The color of the active lightbulb in a standard U.S. traffic light.</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">TL-RED</span> <span class="s">"Red"</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">TL-YELLOW</span> <span class="s">"Yellow"</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">TL-GREEN</span> <span class="s">"Green"</span><span class="p">)</span>

<span class="c1">; tl-template : TrafficLight -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">tl-template</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-RED</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-YELLOW</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-GREEN</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>

<span class="c1">; A TrafficImage is a circle with color red, yellow, or green</span>

<span class="c1">; draw-light : TrafficLight -&gt; Image</span>
<span class="c1">; Given a traffic light, produces an image of the traffic light.</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">draw-light</span> <span class="nv">TL-RED</span><span class="p">)</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span> <span class="s">"Red"</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-light</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-RED</span><span class="p">)</span>   <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span>  <span class="s">"red"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-YELLOW</span><span class="p">)</span>   <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span>  <span class="s">"yellow"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-GREEN</span><span class="p">)</span>   <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span>  <span class="s">"green"</span><span class="p">)]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-light/v2</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span>
          <span class="p">(</span><span class="k">cond</span>
            <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-RED</span><span class="p">)</span> <span class="s">"red"</span><span class="p">]</span>
            <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-YELLOW</span><span class="p">)</span> <span class="s">"yellow"</span><span class="p">]</span>
            <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-GREEN</span><span class="p">)</span> <span class="s">"green"</span><span class="p">])))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-light/v3</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span> <span class="nv">tl</span><span class="p">))</span>

<span class="c1">; Given a TrafficLight, produce a TrafficLight that represents</span>
<span class="c1">; the next color of a traffic light in the standard sequence.</span>
<span class="c1">; next-light : TrafficLight -&gt; TrafficLight</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">next-light</span> <span class="nv">TL-RED</span><span class="p">)</span> <span class="nv">TL-GREEN</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">next-light</span> <span class="nv">TL-YELLOW</span><span class="p">)</span> <span class="nv">TL-RED</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">next-light</span> <span class="nv">TL-GREEN</span><span class="p">)</span> <span class="nv">TL-YELLOW</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">next-light</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-RED</span><span class="p">)</span> <span class="nv">TL-GREEN</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-YELLOW</span><span class="p">)</span> <span class="nv">TL-RED</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">TL-GREEN</span><span class="p">)</span> <span class="nv">TL-YELLOW</span><span class="p">]))</span>

<span class="c1">;(big-bang</span>
<span class="c1">;    TL-RED</span>
<span class="c1">;  [on-draw draw-light/v3]</span>
<span class="c1">;  [on-tick next-light 0.25])</span>

<span class="c1">; draw-light/v4 : TrafficLight -&gt; Image</span>
<span class="c1">; Draws a traffic light, with the active bulb lit and the two inactive blubs dimmed.</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">red-light-ex</span>
  <span class="p">(</span><span class="nf">above</span>
   <span class="p">(</span><span class="nf">circle</span> <span class="mi">15</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">circle</span> <span class="mi">15</span> <span class="s">"outline"</span> <span class="s">"yellow"</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">circle</span> <span class="mi">15</span> <span class="s">"outline"</span> <span class="s">"green"</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">yellow-light-ex</span>
  <span class="p">(</span><span class="nf">above</span>
   <span class="p">(</span><span class="nf">circle</span> <span class="mi">15</span> <span class="s">"outline"</span> <span class="s">"red"</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">circle</span> <span class="mi">15</span> <span class="s">"solid"</span> <span class="s">"yellow"</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">circle</span> <span class="mi">15</span> <span class="s">"outline"</span> <span class="s">"green"</span><span class="p">)))</span>

<span class="c1">; Draw a traffic light blub with color _tl_, that is either on or off, depending</span>
<span class="c1">; on the color of the active light.</span>
<span class="c1">; (string=? tl active-tl)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-bulb/v1</span> <span class="nv">tl</span> <span class="nv">active-tl</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span> <span class="nv">tl</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-bulb/v2</span> <span class="nv">tl</span> <span class="nv">active-tl</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">circle</span>
   <span class="mi">30</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">tl</span> <span class="nv">active-tl</span><span class="p">)</span>
       <span class="s">"solid"</span>
       <span class="s">"outline"</span><span class="p">)</span>
   <span class="nv">tl</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span>
 <span class="p">(</span><span class="nf">draw-bulb/v2</span> <span class="nv">TL-RED</span> <span class="nv">TL-RED</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span>
 <span class="p">(</span><span class="nf">draw-bulb/v2</span> <span class="nv">TL-RED</span> <span class="nv">TL-GREEN</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">circle</span> <span class="mi">30</span> <span class="s">"outline"</span> <span class="s">"red"</span><span class="p">))</span>

<span class="c1">;(define (draw-light/v4 tl)</span>
<span class="c1">;  (above</span>
<span class="c1">;    (cond</span>
<span class="c1">;      [(string=? tl TL-RED)</span>
<span class="c1">;        (circle 15 "solid" "red")</span>
<span class="c1">;        (circle 15 "outline" "yellow")</span>
<span class="c1">;        (circle 15 "outline" "green")]</span>
<span class="c1">;      [(string=? tl TL-YELLOW)</span>
<span class="c1">;        (circle 15 "outline" "red")</span>
<span class="c1">;        (circle 15 "solid" "yellow")</span>
<span class="c1">;        (circle 15 "outline" "green")]</span>
<span class="c1">;      [(string=? tl TL-GREEN) ...]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-light/v4</span> <span class="nv">tl</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">above</span>
   <span class="p">(</span><span class="nf">draw-bulb/v2</span> <span class="nv">TL-RED</span> <span class="nv">tl</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">draw-bulb/v2</span> <span class="nv">TL-YELLOW</span> <span class="nv">tl</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">draw-bulb/v2</span> <span class="nv">TL-GREEN</span> <span class="nv">tl</span><span class="p">)))</span>


<span class="p">(</span><span class="nf">big-bang</span>
    <span class="nv">TL-RED</span>
  <span class="p">[</span><span class="nf">on-draw</span> <span class="nv">draw-light/v4</span><span class="p">]</span>
  <span class="p">[</span><span class="nf">on-tick</span> <span class="nv">next-light</span> <span class="mf">0.25</span><span class="p">])</span>
</code></pre></div></div>

<h1 id="lecture-7---structures">Lecture 7 - Structures</h1>

<p>HW: Give at least 3 ‚Äòinterseting‚Äô examples</p>

<ul>
  <li>Have no Halloween colors</li>
  <li>Don‚Äôt mindlessly tweak numbers</li>
</ul>

<h3 id="data--examples">Data + Examples</h3>

<ul>
  <li>Make sure to test with the number 0</li>
</ul>

<p>Information vs. Data: Information is the interpretation of data</p>

<ul>
  <li><strong>Atomic Data</strong>
    <ul>
      <li>Strings</li>
      <li>Booleans</li>
      <li>Numbers</li>
    </ul>
  </li>
  <li><strong>Interals</strong>
    <ul>
      <li>Ranges of numbers</li>
    </ul>
  </li>
  <li><strong>Enumerated Data</strong>
    <ul>
      <li>ex. TrafficLight</li>
      <li>Only a certain amount of options (usually a String)</li>
    </ul>
  </li>
  <li><strong>Structured Data</strong>
    <ul>
      <li>Mix of different data types</li>
      <li>Example: A student at Northeastern
        <ul>
          <li>First name (String)</li>
          <li>Last name (String)</li>
          <li>GPA (Number in range [0.0, 4.0])</li>
          <li>on-coop (Boolean)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>BAD WAY of representing this data:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"Jane Doe 3.9 #false"</span>
</code></pre></div></div>

<p>This is bad because it‚Äôs all in a single string. Someone with a first name with a space in it can break it. For example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"Jin Ho Kim 3.9 #false"</span>
</code></pre></div></div>

<h2 id="structures">Structures</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">student</span> <span class="p">[</span><span class="nf">first</span> <span class="nv">last</span> <span class="nv">gpa</span> <span class="nv">on-coop</span><span class="p">])</span>
</code></pre></div></div>

<p>Creates ‚Äòconstructor‚Äô function that tkes 4 arguments (which correspond to the 4 inputs)</p>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">make-student</span> <span class="s">"Jin Ho"</span> <span class="s">"Kim"</span> <span class="mf">3.9</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span> <span class="c1">; This is an extual value</span>
</code></pre></div></div>

<h3 id="accessor-functions">Accessor Functions</h3>

<p>Accessor functions are also created</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">student-first</span> <span class="nv">example-student-1</span><span class="p">)</span> <span class="c1">; returns the first name of __example-student-1__</span>
</code></pre></div></div>

<p>Wait! What if we did <code class="language-plaintext highlighter-rouge">(make-student student 0 0 0 0)</code>, after all, those are four inputs.</p>

<p>This is why we need a good data definition</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; A GPA is a Number in the range [0.0, 4.0]</span>
<span class="c1">; Data definition:</span>
<span class="c1">; A student is a _(make-student String String GPA Boolean)_</span>
<span class="c1">;</span>
<span class="c1">; Interpretation: A _(make-student first last gpa on-coop)_</span>
<span class="c1">; represents a student with name _first last_ and GPA _gpa_, and</span>
<span class="c1">; _on-coop_ is _#true_ if they are presently on a co-op.</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">student</span> <span class="p">[</span><span class="nf">first</span> <span class="nv">last</span> <span class="nv">gpa</span> <span class="nv">on-coop</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="templates">Templates</h3>

<p>What does a template for a <code class="language-plaintext highlighter-rouge">student</code>look like?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; student-template : student -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">student-template</span> <span class="nv">student</span><span class="p">)</span>
  <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">student-first</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">student-last</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">student-gpa</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">student-on-coop</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="functions-with-structures">Functions with Structures</h2>

<p>You can‚Äôt change a structure, so functions have to return a different structure.</p>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; toggle-coop : student -&gt; student</span>
<span class="c1">; _(toggle-coop s)_ consumes a student _s_ and produces student</span>
<span class="c1">; that that is identical to _s_, but with the opposite co-op</span>
<span class="c1">; status.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">toggle-coop</span> <span class="nv">student</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-student</span>
    <span class="p">(</span><span class="nf">student-first</span> <span class="nv">student</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">student-last</span> <span class="nv">student</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">student-gpa</span> <span class="nv">student</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nf">student-on-coop</span> <span class="nv">student</span><span class="p">))))</span>
</code></pre></div></div>

<h2 id="example-ball-in-motion-in-two-dimensions">Example: Ball in motion in two dimensions</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Data definition:</span>
<span class="c1">; A ball is a (make-ball Real Real Real Real)</span>
<span class="c1">; Interpretation:</span>
<span class="c1">; A _(make-ball x y vx vy)_ represents a ball at position (x,y)</span>
<span class="c1">; moving with velocity (vx, vy).</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">ball</span> <span class="p">[</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">vx</span> <span class="nv">vy</span><span class="p">])</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ball-template</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

<span class="c1">; move-ball : ball -&gt; ball</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-ball</span>
   <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">))</span>
   <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ball-example-1</span> <span class="p">(</span><span class="nf">make-ball</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-1</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">make-ball</span> <span class="mi">10</span> <span class="mi">0</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ball-example-2</span> <span class="p">(</span><span class="nf">make-ball</span> <span class="mi">3</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">10</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-2</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">make-ball</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">7</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">10</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">ball-example-1</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nf">make-ball</span> <span class="mi">1</span><span class="nv">+2i</span> <span class="s">"hi"</span> <span class="no">#t</span><span class="nv">rue</span> <span class="mi">5</span><span class="p">)</span>

<span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
<span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>

<span class="c1">; draw-ball : ball -&gt; Image</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-ball</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">place-image</span>
   <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"white"</span><span class="p">)))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ; Kinds of data:
    ; - Atomic data, e.g., strings, booleans, numbers
    ; - Intervals, e.g., ranges of numbers
    ; - Enumerated data, e.g. TrafficLight
    ; - Structured data

    ; Data definition that represents first name, last
    ; last, GPA, and on-coop-or-not

    (define bad-example-student
      "Jin Ho Kim 3.9 #false")

    ; A GPA is a Number in the range [0.0, 4.0]

    ; Data definition:
    ; A student is a _(make-student String String GPA Boolean)_
    ;
    ; Interpretation: A _(make-student first last gpa on-coop)_
    ; represents a student with name _first last_ and GPA _gpa_, and
    ; _on-coop_ is _#true_ if they are presently on a co-op.
    (define-struct student [first last gpa on-coop])

    (define example-student-2
      (make-student "Arjun" "Guha" 3.4 #false))

    ; student-template : student -&gt; ?
    (define (student-template student)
      (... (student-first student) ...
           (student-last student) ...
           (student-gpa student) ...
           (student-on-coop student) ...))

    ; toggle-coop : student -&gt; student
    ; _(toggle-coop s)_ consumes a student _s_ and produces student
    ; that that is identical to _s_, but with the opposite co-op
    ; status.
    (define (toggle-coop student)
      (make-student
        (student-first student)
        (student-last student)
        (student-gpa student)
        (not (student-on-coop student))))

    (define example-student-1
      (make-student "Jin Ho" "Kim" 3.9 #false))

    (check-expect (toggle-coop example-student-1)
                  (make-student "Jin Ho" "Kim" 3.9 #true))
    ; Accessor
    (student-gpa example-student-1)

    ; Data definition:
    ; A ball is a (make-ball Real Real Real Real)
    ; Interpretation:
    ; A _(make-ball x y vx vy)_ represents a ball at position (x,y)
    ; moving with velocity (vx, vy).
    (define-struct ball [x y vx vy])

    (define (ball-template b)
      (... (ball-x b) ...
           (ball-y b) ...
           (ball-vx b) ...
           (ball-vy b) ...))

    ; move-ball : ball -&gt; ball
    (define (move-ball b)
      (make-ball
       (+ (ball-x b) (ball-vx b))
       (+ (ball-y b) (ball-vy b))
       (ball-vx b)
       (ball-vy b)))

    (define ball-example-1 (make-ball 0 0 10 0))

    (check-expect (move-ball ball-example-1)
                  (make-ball 10 0 10 0))

    (define ball-example-2 (make-ball 3 7 5 10))

    (check-expect (move-ball ball-example-2)
                  (make-ball (+ 3 5) (+ 7 10) 5 10))

    (check-expect (ball-vx ball-example-1) 10)
    (make-ball 1+2i "hi" #true 5)

    (require 2htdp/image)
    (require 2htdp/universe)

    ; draw-ball : ball -&gt; Image
    (define (draw-ball b)
      (place-image
       (circle 10 "solid" "red")
       (ball-x b)
       (ball-y b)
       (rectangle 200 200 "solid" "white")))

    (define ex-x 3)
    (define ex-y 7)
    (define ball-example-2/v2 (make-ball ex-x ex-y 5 10))
</pre>
</details>

<h1 id="lecture-8---extended-structures">Lecture 8 - Extended Structures</h1>

<p>Recall from <a href="Lecture%207%20-%20Structures%204757717f3fc74c33ba6367130e541841.md">Lecture 7 - Structures</a></p>

<p>Structures are values that you can think of as a box with ‚Äòn‚Äô number of compartments (‚Äòn‚Äô is the number of inputs you spesifiy)</p>

<p><strong>The difference between value and expression</strong></p>

<p>Value: The data</p>

<p>Expression: A task for the computer to simplify further (ex. <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>)</p>

<p>NOTE: Values are expressions</p>

<ul>
  <li>For example, typing <code class="language-plaintext highlighter-rouge">13</code>, returns <code class="language-plaintext highlighter-rouge">13</code></li>
</ul>

<h2 id="structures-1">Structures</h2>

<p><code class="language-plaintext highlighter-rouge">define-struct</code></p>

<ul>
  <li>Only defines constructor functions</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">student?</code> (replace with structure name) is a predicate that returns if a value is of type <code class="language-plaintext highlighter-rouge">student</code> (or whatever other structure)</p>

<h3 id="structure-function-template">Structure Function Template</h3>

<ul>
  <li>Take things ‚Äòout of the box‚Äô</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; student-template : student -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">student-template</span> <span class="nv">student</span><span class="p">)</span>
	<span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">student-first</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
			 <span class="p">(</span><span class="nf">student-last</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
			 <span class="p">(</span><span class="nf">student-gpa</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
			 <span class="p">(</span><span class="nf">student-on-coop</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="ball-example">Ball Example</h2>

<p>We want to make a function <code class="language-plaintext highlighter-rouge">move-ball</code>that moves the ball. Every call, add the velocity to the position for the new position.</p>

<p>Remember: You don‚Äôt need to use every attribute of <code class="language-plaintext highlighter-rouge">ball</code> (structure) for every funciton</p>

<ul>
  <li>ex. <code class="language-plaintext highlighter-rouge">draw-ball</code> doesn‚Äôt use the velocity</li>
</ul>

<h2 id="two-balls">Two Balls</h2>

<p>DO NOT DO THIS:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">two-balls</span> <span class="p">[</span><span class="nf">x1</span> <span class="nv">y1</span> <span class="nv">vx1</span> <span class="nv">vy1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">vx2</span> <span class="nv">vy2</span><span class="p">]))</span>
</code></pre></div></div>

<p>As programmers, we want to reuse code (plus this is ugly to read)</p>

<p>Instead do:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">two-balls</span> <span class="p">[</span><span class="nf">ball1</span> <span class="nv">ball2</span><span class="p">])</span>
</code></pre></div></div>

<p>This allows you to do this:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">example-ball-1</span> <span class="nv">example-ball-2</span><span class="p">)</span> <span class="c1">; Nested structure</span>
</code></pre></div></div>

<p>It is uncommon to have structure names with hyphens</p>

<h3 id="template-for-two-balls">Template for <code class="language-plaintext highlighter-rouge">two-balls</code></h3>

<ul>
  <li>You can have nested templates</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; two-balls-template : Two-Balls -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">two-balls-template</span> <span class="nv">tb</span><span class="p">)</span>
	<span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span>
	     <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>Templates let‚Äôs you break down what you have to work with</li>
</ul>

<p>You don‚Äôt have to understand everything at any given time</p>

<h3 id="draw-two-balls"><code class="language-plaintext highlighter-rouge">draw-two-balls</code></h3>

<ul>
  <li>Remember to use helper functions
    <ul>
      <li>We already have <code class="language-plaintext highlighter-rouge">draw-ball</code></li>
    </ul>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; draw-two-balls : Two-Balls -&gt; Image</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
	<span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">draw-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span>
		   <span class="p">(</span><span class="nf">draw-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<p>This doesn‚Äôt work right now because both balls have backgrounds (that aren‚Äôt transparent)</p>

<ul>
  <li>
    <p>Lecture 8 Code</p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
  <span class="c1">;; Based on code from Lecture 7.</span>

  <span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">bad-student-example</span> <span class="s">"Phyo Ba Kyu 3.1 #false"</span><span class="p">)</span>

  <span class="c1">;; A GPA is a Number in the range [0.0, 4.0].</span>

  <span class="c1">;; A Student is a _(make-student String String GPA Boolean)_</span>
  <span class="c1">;;</span>
  <span class="c1">;; Interpretation: A _(make-student first last gpa on-coop)_ represents a</span>
  <span class="c1">;; student with name _first last_ and GPA _gpa_. The boolean _on-coop_ indicates</span>
  <span class="c1">;; whether or not the student is presently on a co-op.</span>
  <span class="p">(</span><span class="nf">define-struct</span> <span class="nv">student</span> <span class="p">[</span><span class="nf">first</span> <span class="nv">last</span> <span class="nv">gpa</span> <span class="nv">on-coop</span><span class="p">])</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">example-student-1</span> <span class="p">(</span><span class="nf">make-student</span> <span class="s">"Arjun"</span> <span class="s">"Guha"</span> <span class="mf">3.4</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">example-student-2</span> <span class="p">(</span><span class="nf">make-student</span> <span class="s">"Phyo"</span> <span class="s">"Ba Kyu"</span> <span class="mf">3.1</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">))</span>

  <span class="c1">;; student-template : student -&gt; ?</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">student-template</span> <span class="nv">student</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">student-first</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">student-last</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">student-gpa</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">student-on-coop</span> <span class="nv">student</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

  <span class="c1">;; A Ball is a _(make-ball Real Real Real Real)_.</span>
  <span class="c1">;;</span>
  <span class="c1">;; Interpretation: A _(make-ball x y vx vy)_ represents a ball at position</span>
  <span class="c1">;; (_x_,_y_), moving with velocity (_vx_, _vy_).</span>
  <span class="p">(</span><span class="nf">define-struct</span> <span class="nv">ball</span> <span class="p">[</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">vx</span> <span class="nv">vy</span><span class="p">])</span>

  <span class="c1">;; A Ball at the origin, moving horizontally.</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">ball-example-1</span> <span class="p">(</span><span class="nf">make-ball</span> <span class="mi">100</span> <span class="mi">100</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">))</span>

  <span class="c1">;; A Ball moving diagonally, going up faster than it is moving right.</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">ball-example-2</span> <span class="p">(</span><span class="nf">make-ball</span> <span class="mi">25</span> <span class="mi">25</span> <span class="mi">5</span> <span class="mi">10</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ball-template</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

  <span class="c1">;; move-ball : Ball -&gt; Ball</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-ball</span>
     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">)))</span>

  <span class="c1">;(check-expect (move-ball ball-example-1) (make-ball 10 0 10 0))</span>
  <span class="c1">;(check-expect (move-ball ball-example-2) (make-ball (+ 3 5) (+ 7 10) 5 10))</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">BACKGROUND</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"grey"</span><span class="p">))</span>

  <span class="c1">;; draw-ball : Ball -&gt; Image</span>
  <span class="c1">;; Draws a ball on _BACKGROUND_.</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-ball</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">place-image</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">BACKGROUND</span><span class="p">))</span>

  <span class="c1">;; A Two-Balls is a _(make-two-balls Ball Ball)_.</span>
  <span class="c1">;; Interpretation: A Two-Balls represents two balls moving independently.</span>
  <span class="p">(</span><span class="nf">define-struct</span> <span class="nv">two-balls</span> <span class="p">[</span><span class="nf">ball1</span> <span class="nv">ball2</span><span class="p">])</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">ex-tb-1</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-2</span><span class="p">)</span> <span class="nv">ball-example-1</span><span class="p">))</span>

  <span class="c1">; two-balls-template : Two-Balls -&gt; ?</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">two-balls-template/v1</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">two-balls-template/v2</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-y</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span>
         <span class="c1">; etc.</span>
         <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">two-balls-template</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span><span class="p">))</span>

  <span class="c1">; move-two-balls : Two-Balls -&gt; Two-Balls</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">move-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-two-balls</span>
     <span class="p">(</span><span class="nf">move-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">move-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))))</span>

  <span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">move-two-balls</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">ball-example-1</span> <span class="nv">ball-example-2</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">make-two-balls</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-1</span><span class="p">)</span>
                                <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-2</span><span class="p">)))</span>

  <span class="o">#</span><span class="nv">|</span>
  <span class="p">(</span><span class="nf">move-two-balls</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">ball-example-1</span> <span class="nv">ball-example-2</span><span class="p">))</span>

  <span class="p">(</span><span class="nf">make-two-balls</span>
   <span class="p">(</span><span class="nf">move-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">ball-example-1</span> <span class="nv">ball-example-2</span><span class="p">)))</span>
   <span class="p">(</span><span class="nf">move-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">ball-example-1</span> <span class="nv">ball-example-2</span><span class="p">))))</span>

        <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">ball-example-1</span> <span class="nv">ball-example-2</span><span class="p">))</span>
        <span class="nv">ball-example-1</span>

  <span class="p">(</span><span class="nf">make-two-balls</span>
   <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-1</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">move-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">ball-example-1</span> <span class="nv">ball-example-2</span><span class="p">))))</span>

         <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="nv">ball-example-1</span> <span class="nv">ball-example-2</span><span class="p">))</span>
         <span class="nv">ball-example-2</span>

  <span class="p">(</span><span class="nf">make-two-balls</span>
   <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-1</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-2</span><span class="p">))</span>
  <span class="nv">|</span><span class="o">#</span>

  <span class="c1">; draw-two-balls : Ball -&gt; Image</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">overlay</span> <span class="p">(</span><span class="nf">draw-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">draw-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))))</span>
</code></pre></div>    </div>
    <h1 id="lecture-9---expanding-bigbang-and-short-circuits">Lecture 9 - Expanding BigBang and Short Circuits</h1>
  </li>
</ul>

<p>Piazza has clarification on homework</p>

<p>Homework</p>

<ul>
  <li>Auto-grader catches syntax and style and it‚Äôs free points‚Ä¶USE IT</li>
  <li>Refer to the style guide on the course website</li>
</ul>

<h3 id="recall-from">Recall from</h3>

<p>[[Lecture 8 - Extended Structures]]</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">ball</span> <span class="p">[</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">vx</span> <span class="nv">vy</span><span class="p">])</span>
</code></pre></div></div>

<p>Nested structured data:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">two-balls</span> <span class="p">[</span><span class="nf">ball1</span> <span class="nv">ball2</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="templates-1">Templates</h3>

<p>Templates are essentially the reverse of the constructor function (they unpack the box instead of create the box)</p>

<p>Funciton templates should also be nested for simplicity also as a reminder that you need a helper function</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">two-balls-template</span> <span class="nv">tb</span><span class="p">)</span>
  <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<hr />

<p>Recall the issue with <code class="language-plaintext highlighter-rouge">draw-ball</code> that it draws two backgrounds and one completly obstructs the other. This is because the function <code class="language-plaintext highlighter-rouge">draw-ball</code> doesn‚Äôt compose nicely and so we should change the function.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; draw-ball : Ball -&gt; Image</span>
<span class="c1">;; Draws a ball on given background</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-ball-on</span> <span class="nv">background</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">place-image</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">background</span><span class="p">))</span>
</code></pre></div></div>

<p>We now can have the first ball background image be ball2‚Äôs image:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; draw-two-balls : Ball -&gt; Image</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">draw-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span>
		<span class="p">(</span><span class="nf">draw-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))))</span>
</code></pre></div></div>

<h2 id="lets-make-a-game">Let‚Äôs Make a Game!</h2>

<p>Often times small changes break examples so writing expressions instead of literal values in <code class="language-plaintext highlighter-rouge">check-expects</code> can prove to be more robust</p>

<p><code class="language-plaintext highlighter-rouge">big-bang</code>can look for key presses as well (see documentation for a full list of things that <code class="language-plaintext highlighter-rouge">big-bang</code>can do)</p>

<p><code class="language-plaintext highlighter-rouge">on-key</code> - called on any key press</p>

<p>[ ]‚Äôs ()‚Äôs and {}‚Äôs are all handled the same in Racket, but there are conventions</p>

<p><code class="language-plaintext highlighter-rouge">on-key</code> sends both the state of the world and key that was pressed</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">on-key</span> <span class="nv">handle-key-pressed</span><span class="p">]</span>
</code></pre></div></div>

<p>Top down programming is trying programming with ‚Äòplaceholders‚Äô and filling in the gaps later. A higher level view of what‚Äôs going on</p>

<p>Bottom up programming is building all of the helper functions first. This is useful if you understand everything about a given project</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; flip-two-balls : Two-Balls -&gt; Two-Balls</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">flip-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-two-balls</span> <span class="p">(</span><span class="nf">flip-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span>
                  <span class="p">(</span><span class="nf">flip-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))))</span>

<span class="c1">;; handle-key-pressed : Two-Balls String -&gt; Two-Balls</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">handle-key-pressed</span> <span class="nv">tb</span> <span class="nv">key</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">key=?</span> <span class="nv">key</span> <span class="s">"f"</span><span class="p">)</span> <span class="p">(</span><span class="nf">flip-two-balls</span> <span class="nv">tb</span><span class="p">)]</span>
    <span class="p">[</span><span class="k">else</span> <span class="nv">tb</span><span class="p">]))</span>
</code></pre></div></div>

<h3 id="signatures">Signatures</h3>

<p>Yes, <code class="language-plaintext highlighter-rouge">big-bang</code> shows an animation, but it returns the same data type as the initial state of the world thus the signature would be:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; start-game : Two-Balls -&gt; Two-Balls</span>
</code></pre></div></div>

<h2 id="short-circuits">Short Circuits</h2>

<p>Recall from</p>

<table>
  <tbody>
    <tr>
      <td>[[../CS1800 Discrete Structures</td>
      <td>CS1800: Discrete Structures]]</td>
    </tr>
  </tbody>
</table>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">and</span> <span class="no">#t</span><span class="nv">rue</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span> <span class="c1">; returns true</span>
</code></pre></div></div>

<p>With the example of <code class="language-plaintext highlighter-rouge">(and #false #true)</code> you don‚Äôt even need to evaluate the right hand side because it‚Äôll always be false</p>

<p>This is the same with <code class="language-plaintext highlighter-rouge">(or #true #false</code>.</p>

<p>Foo and bar are placeholders for text in computer science. Never call a finished product foo or bar</p>

<p><strong>Why is this useful?</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; A StringOrNumber is either:</span>
<span class="c1">; - string</span>
<span class="c1">; - Number</span>
<span class="c1">; is-hi? : StringOrNumber -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">foo</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">; the proper name should be is-hi?</span>
	<span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">string?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">x</span> <span class="s">"hi"</span><span class="p">))</span>
</code></pre></div></div>

<p>In this case, we can throw any data type at it and it will either return <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>. If it‚Äôs not a string, the first expression will be <code class="language-plaintext highlighter-rouge">false</code> so there‚Äôs no need to check the 2nd expression.</p>

<ul>
  <li>
    <p>Lecture 9 Code</p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
  <span class="c1">;; Based on code from Lecture 8.</span>

  <span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/image</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">require</span> <span class="mi">2</span><span class="nv">htdp/universe</span><span class="p">)</span>

  <span class="c1">;; A Ball is a _(make-ball Real Real Real Real)_.</span>
  <span class="c1">;;</span>
  <span class="c1">;; Interpretation: A _(make-ball x y vx vy)_ represents a ball at position</span>
  <span class="c1">;; (_x_,_y_), moving with velocity (_vx_, _vy_).</span>
  <span class="p">(</span><span class="nf">define-struct</span> <span class="nv">ball</span> <span class="p">[</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">vx</span> <span class="nv">vy</span><span class="p">])</span>

  <span class="c1">;; A Ball at the origin, moving horizontally.</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">ball-example-1</span> <span class="p">(</span><span class="nf">make-ball</span> <span class="mi">100</span> <span class="mi">100</span> <span class="mi">5</span> <span class="mi">0</span><span class="p">))</span>
  <span class="c1">;; A Ball moving diagonally, going up faster than it is moving right.</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">ball-example-2</span> <span class="p">(</span><span class="nf">make-ball</span> <span class="mi">25</span> <span class="mi">25</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

  <span class="c1">;; ball-template : Ball -&gt; ?</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ball-template</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

  <span class="c1">;; move-ball : Ball -&gt; Ball</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-ball</span>
     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">)))</span>

  <span class="c1">;(check-expect (move-ball ball-example-1) (make-ball 110 100 10 0))</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">BACKGROUND</span> <span class="p">(</span><span class="nf">rectangle</span> <span class="mi">200</span> <span class="mi">200</span> <span class="s">"solid"</span> <span class="s">"grey"</span><span class="p">))</span>

  <span class="c1">;; draw-ball : Ball -&gt; Image</span>
  <span class="c1">;; Draws a ball on _BACKGROUND_.</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-ball</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">place-image</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">BACKGROUND</span><span class="p">))</span>

  <span class="c1">;; A Two-Balls is a _(make-two-balls Ball Ball)_.</span>
  <span class="c1">;; Interpretation: A Two-Balls represents two balls moving independently.</span>
  <span class="p">(</span><span class="nf">define-struct</span> <span class="nv">two-balls</span> <span class="p">[</span><span class="nf">ball1</span> <span class="nv">ball2</span><span class="p">])</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">ex-tb-1</span> <span class="p">(</span><span class="nf">make-two-balls</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-2</span><span class="p">)</span> <span class="nv">ball-example-1</span><span class="p">))</span>

  <span class="c1">;; two-balls-template : Two-Balls -&gt; ?</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">two-balls-template</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">ball-template</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))</span> <span class="o">...</span><span class="p">))</span>

  <span class="c1">;; move-two-balls : Two-Balls -&gt; Two-Balls</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">move-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-two-balls</span>
     <span class="p">(</span><span class="nf">move-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">move-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))))</span>

  <span class="o">#</span><span class="c1">;(check-expect (move-two-balls (make-two-balls ball-example-1 ball-example-2))</span>
                <span class="p">(</span><span class="nf">make-two-balls</span> <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-1</span><span class="p">)</span>
                                <span class="p">(</span><span class="nf">move-ball</span> <span class="nv">ball-example-2</span><span class="p">)))</span>

  <span class="c1">;; draw-two-balls : Ball -&gt; Image</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">draw-ball-on</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">draw-ball-on</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">)</span> <span class="nv">BACKGROUND</span><span class="p">)))</span>

  <span class="c1">;(draw-ball ball-example-1)</span>
  <span class="c1">;(draw-ball ball-example-2)</span>

  <span class="c1">;; draw-ball-on : Ball Image -&gt; Image</span>
  <span class="c1">;; Draws a ball on _BACKGROUND_.</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-ball-on</span> <span class="nv">b</span> <span class="nv">background</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">place-image</span> <span class="p">(</span><span class="nf">circle</span> <span class="mi">10</span> <span class="s">"solid"</span> <span class="s">"red"</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">background</span><span class="p">))</span>

  <span class="c1">;; flip-ball : Ball -&gt; Ball</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">flip-ball</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-ball</span> <span class="p">(</span><span class="nf">ball-x</span> <span class="nv">b</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">ball-y</span> <span class="nv">b</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">*</span> <span class="mf">-0.9</span> <span class="p">(</span><span class="nf">ball-vx</span> <span class="nv">b</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">*</span> <span class="mf">-0.9</span> <span class="p">(</span><span class="nf">ball-vy</span> <span class="nv">b</span><span class="p">))))</span>

  <span class="c1">;; flip-two-balls : Two-Balls -&gt; Two-Balls</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">flip-two-balls</span> <span class="nv">tb</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-two-balls</span> <span class="p">(</span><span class="nf">flip-ball</span> <span class="p">(</span><span class="nf">two-balls-ball1</span> <span class="nv">tb</span><span class="p">))</span>
                    <span class="p">(</span><span class="nf">flip-ball</span> <span class="p">(</span><span class="nf">two-balls-ball2</span> <span class="nv">tb</span><span class="p">))))</span>

  <span class="c1">;; handle-key-pressed : Two-Balls String -&gt; Two-Balls</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">handle-key-pressed</span> <span class="nv">tb</span> <span class="nv">key</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nf">key=?</span> <span class="nv">key</span> <span class="s">"f"</span><span class="p">)</span> <span class="p">(</span><span class="nf">flip-two-balls</span> <span class="nv">tb</span><span class="p">)]</span>
      <span class="p">[</span><span class="k">else</span> <span class="nv">tb</span><span class="p">]))</span>

  <span class="c1">;; start-game : Two-Balls -&gt; Two-Balls</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">start-game</span> <span class="nv">init-tb</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">big-bang</span> <span class="nv">init-tb</span>
      <span class="p">[</span><span class="nf">on-draw</span> <span class="nv">draw-two-balls</span><span class="p">]</span>
      <span class="p">[</span><span class="nf">on-tick</span> <span class="nv">move-two-balls</span> <span class="mf">0.05</span><span class="p">]</span>
      <span class="p">[</span><span class="nf">on-key</span> <span class="nv">handle-key-pressed</span><span class="p">]))</span>

  <span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

  <span class="c1">;(and (and #true #false) (or #false #true))</span>

  <span class="c1">;; A StringOrNumber is either:</span>
  <span class="c1">;; - string</span>
  <span class="c1">;; - number</span>

  <span class="c1">;; is-hi? : StringOrNumber -&gt; Boolean</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">is-hi?</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">string?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">x</span> <span class="s">"hi"</span><span class="p">)))</span>
</code></pre></div>    </div>
    <h1 id="lecture-10---unions-and-structures">Lecture 10 - Unions and Structures</h1>
  </li>
</ul>

<p>We are building up to recurrsion</p>

<p>Remeber that office hours are almost all of the time. Recommended to go on Monday</p>

<hr />

<h2 id="unions---unbounded-number-of-things">Unions - Unbounded Number of Things</h2>

<h3 id="pie-data-definition">Pie Data Definition</h3>

<ul>
  <li>Type and are they nut free?</li>
</ul>

<h3 id="pies">Pies</h3>

<ul>
  <li>Pecan Pies</li>
  <li>Cream Pies</li>
  <li>Fruit Pies
    <ul>
      <li>For every fruit pie, we need to know its type and if it has nuts</li>
    </ul>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Problem: Design a data definition to represent a pie. There are three kinds</span>
<span class="c1">;; of pies to consider: pecan pies, cream pies, and fruit pies. For every fruit</span>
<span class="c1">;; pie, we need to know its type, and if it is nut-free. For example, an apple</span>
<span class="c1">;; pie may contain nuts, whereas a lemon chiffron pie is nut-free.</span>

<span class="c1">;; A Pie is one of:</span>
<span class="c1">;; - (make-fruit-fill String Boolean)</span>
<span class="c1">;; - "pecan"</span>
<span class="c1">;; - "cream"</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: "pecan" represents a pecan pie, "cream" represents</span>
<span class="c1">;; a cream pie, and (make-fruit-fill type nut-free) represents a</span>
<span class="c1">;; fruit pie of type _type_ and _nut-free_ indicates if it is nut free.</span>
</code></pre></div></div>

<p>Notice the <code class="language-plaintext highlighter-rouge">(make-fruit-fill String Boolean)</code> . We don‚Äôt need to make another data definition for this because functions should never have to deal with fruit-filled pies in isolation</p>

<p>This data definition is a union (not an enumeration) because there are infinite <code class="language-plaintext highlighter-rouge">(make-fruit-fill String Boolean)</code>‚Äôs.</p>

<h2 id="template">Template</h2>

<ul>
  <li>Fruit pies are a different type than the rest therefore we need to handle each condition differently.</li>
  <li>Remeber: templates unpack the box as much as possible</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pie-template</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)</span> <span class="o">...</span>
                          <span class="p">(</span><span class="nf">fruit-fill-nut-free</span> <span class="nv">p</span><span class="p">)</span> <span class="o">...</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>
</code></pre></div></div>

<p>Recall Short Circuiting</p>

<p>[[Lecture 9 - Expanding BigBang and Short Circuits]]</p>

<p>You can do the same thing through conditionals as well.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pie-&gt;filling/v2</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">)</span> <span class="s">"pecan"</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">)</span> <span class="s">"cream"</span><span class="p">]))</span>
</code></pre></div></div>

<p>If it gets the 2nd condition, we know it‚Äôs not a <code class="language-plaintext highlighter-rouge">fruit-fill</code> therefore we knew that it‚Äôs a string.</p>

<p><strong>We can also do this:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Design a function called pie-&gt;filling that produces a string</span>
<span class="c1">;; describing the filling.</span>
<span class="c1">;; pie-&gt;filling : Pie -&gt; String</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pie-&gt;filling</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">string?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">))</span> <span class="s">"pecan"</span><span class="p">]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">string?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">))</span> <span class="s">"cream"</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)]))</span>
</code></pre></div></div>

<p>This example is more robust because you can reorder things and it‚Äôs more readable to humans.</p>

<p>If you have an if that returns <code class="language-plaintext highlighter-rouge">#true</code> or <code class="language-plaintext highlighter-rouge">#false</code>, you can make it more compact by just writing the condition (if it‚Äôs the inverse, add <code class="language-plaintext highlighter-rouge">(not</code> to the beginning).</p>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; requires-baking? : Pie -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">requires-baking?</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span>
     <span class="c1">;(... (fruit-fill-type p) ...</span>
     <span class="c1">;                     (fruit-fill-nut-free p) ...)</span>
     <span class="c1">;(if (string=? "lemon chiffron" (fruit-fill-type p))</span>
     <span class="c1">;    #false</span>
     <span class="c1">;    #true)</span>
     <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">string=?</span> <span class="s">"lemon chiffron"</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)))]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]))</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Full Pie Example Code</p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;; Problem: Design a data definition to represent a pie. There are three kinds</span>
  <span class="c1">;; of pies to consider: pecan pies, cream pies, and fruit pies. For every fruit</span>
  <span class="c1">;; pie, we need to know its type, and if it is nut-free. For example, an apple</span>
  <span class="c1">;; pie may contain nuts, whereas a lemon chiffron pie is nut-free.</span>

  <span class="c1">;; A Pie is one of:</span>
  <span class="c1">;; - (make-fruit-fill String Boolean)</span>
  <span class="c1">;; - "pecan"</span>
  <span class="c1">;; - "cream"</span>
  <span class="c1">;;</span>
  <span class="c1">;; Interpretation: "pecan" represents a pecan pie, "cream" represents</span>
  <span class="c1">;; a cream pie, and (make-fruit-fill type nut-free) represents a</span>
  <span class="c1">;; fruit pie of type _type_ and _nut-free_ indicates if it is nut free.</span>
  <span class="p">(</span><span class="nf">define-struct</span> <span class="nv">fruit-fill</span> <span class="p">(</span><span class="nf">type</span> <span class="nv">nut-free</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pie-template</span> <span class="nv">p</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)</span> <span class="o">...</span>
                            <span class="p">(</span><span class="nf">fruit-fill-nut-free</span> <span class="nv">p</span><span class="p">)</span> <span class="o">...</span><span class="p">)]</span>
      <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
      <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">ex-pecan</span> <span class="s">"pecan"</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">ex-cream</span> <span class="s">"cream"</span><span class="p">)</span>
  <span class="c1">;(define ex-apple-pie "apple pie NO NUTS")</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">ex-apple-pie</span> <span class="p">(</span><span class="nf">make-fruit-fill</span> <span class="s">"apple"</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">ex-lf</span> <span class="p">(</span><span class="nf">make-fruit-fill</span> <span class="s">"lemon chiffron"</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">))</span>

  <span class="c1">;; Design a function called pie-&gt;filling that produces a string</span>
  <span class="c1">;; describing the filling.</span>
  <span class="c1">;; pie-&gt;filling : Pie -&gt; String</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pie-&gt;filling</span> <span class="nv">p</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">string?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">))</span> <span class="s">"pecan"</span><span class="p">]</span>
      <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">string?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">))</span> <span class="s">"cream"</span><span class="p">]</span>
      <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)]))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pie-&gt;filling/v2</span> <span class="nv">p</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)]</span>
      <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">)</span> <span class="s">"pecan"</span><span class="p">]</span>
      <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">)</span> <span class="s">"cream"</span><span class="p">]))</span>

  <span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">pie-&gt;filling</span> <span class="nv">ex-pecan</span><span class="p">)</span> <span class="s">"pecan"</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">pie-&gt;filling</span> <span class="nv">ex-apple-pie</span><span class="p">)</span> <span class="s">"apple"</span><span class="p">)</span>

  <span class="c1">;; Design a function called requires-&gt;baking? To check if a PIe requires</span>
  <span class="c1">;; baking. Pecan pies, and all fruit pies, but not the lemon chiffron,</span>
  <span class="c1">;; require baking.</span>

  <span class="c1">;; requires-baking? : Pie -&gt; Boolean</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">requires-baking?</span> <span class="nv">p</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nf">fruit-fill?</span> <span class="nv">p</span><span class="p">)</span>
       <span class="c1">;(... (fruit-fill-type p) ...</span>
       <span class="c1">;                     (fruit-fill-nut-free p) ...)</span>
       <span class="c1">;(if (string=? "lemon chiffron" (fruit-fill-type p))</span>
       <span class="c1">;    #false</span>
       <span class="c1">;    #true)</span>
       <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">string=?</span> <span class="s">"lemon chiffron"</span> <span class="p">(</span><span class="nf">fruit-fill-type</span> <span class="nv">p</span><span class="p">)))]</span>
      <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"pecan"</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
      <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">p</span> <span class="s">"cream"</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]))</span>

  <span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">requires-baking?</span> <span class="nv">ex-lf</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">requires-baking?</span> <span class="nv">ex-apple-pie</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="location-example">Location Example</h3>

<p>Template:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A GeoCoord is one of:</span>
<span class="c1">;; - Location</span>
<span class="c1">;; - PositiveNumber</span>
<span class="c1">;; - NegativeNumber</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: It represents either a location on the</span>
<span class="c1">;; Earth's surface, an altitude in the air (positive number),</span>
<span class="c1">;; or a depth in the sea (negative number).</span>

<span class="c1">;; Problem: Complete the data definion for GeoCoord</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">geocoord-template</span> <span class="nv">gc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="c1">;[(location? gc) (... (location-latitude gc) ...</span>
    <span class="c1">;                     (location-longitude gc) ...)]</span>
    <span class="p">[(</span><span class="nf">location?</span> <span class="nv">gc</span><span class="p">)</span> <span class="p">(</span><span class="nf">location-template</span> <span class="nv">gc</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">&gt;=</span> <span class="nv">gc</span> <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="c1">;[(and (number? gc) (&gt;= gc 0)) ???]</span>
    <span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">gc</span> <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>
</code></pre></div></div>

<p>This is also a <strong>union</strong>.</p>

<ul>
  <li>
    <p>Full GeoCoord Example Code</p>

    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;; A Location is a (make-location Number Number).</span>
  <span class="c1">;;</span>
  <span class="c1">;; Interpretation: A (make-location lat long) is a coordinate</span>
  <span class="c1">;; on the Earth's surface.</span>

  <span class="p">(</span><span class="nf">define-struct</span> <span class="nv">location</span> <span class="p">[</span><span class="nf">latitude</span> <span class="nv">longitude</span><span class="p">])</span>

  <span class="c1">;; Example Locations</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">boston-location</span> <span class="p">(</span><span class="nf">make-location</span> <span class="mi">42</span> <span class="mi">71</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">area51-location</span> <span class="p">(</span><span class="nf">make-location</span> <span class="mi">37</span> <span class="mi">115</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">crater-lake-location</span> <span class="p">(</span><span class="nf">make-location</span> <span class="mi">42</span> <span class="mi">133</span><span class="p">))</span>

  <span class="c1">;; location-temp : Location -&gt; ?</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">location-temp</span> <span class="nv">loc</span><span class="p">)</span>
    <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">location-latitude</span> <span class="nv">loc</span><span class="p">)</span> <span class="o">...</span>
         <span class="p">(</span><span class="nf">location-longitude</span> <span class="nv">loc</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

  <span class="c1">;; A GeoCoord is one of:</span>
  <span class="c1">;; - Location</span>
  <span class="c1">;; - PositiveNumber</span>
  <span class="c1">;; - NegativeNumber</span>
  <span class="c1">;;</span>
  <span class="c1">;; Interpretation: It represents either a location on the</span>
  <span class="c1">;; Earth's surface, an altitude in the air (positive number),</span>
  <span class="c1">;; or a depth in the sea (negative number).</span>

  <span class="c1">;; Problem: Complete the data definion for GeoCoord</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">geocoord-template</span> <span class="nv">gc</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="c1">;[(location? gc) (... (location-latitude gc) ...</span>
      <span class="c1">;                     (location-longitude gc) ...)]</span>
      <span class="p">[(</span><span class="nf">location?</span> <span class="nv">gc</span><span class="p">)</span> <span class="p">(</span><span class="nf">location-template</span> <span class="nv">gc</span><span class="p">)]</span>
      <span class="p">[(</span><span class="nb">&gt;=</span> <span class="nv">gc</span> <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
      <span class="c1">;[(and (number? gc) (&gt;= gc 0)) ???]</span>
      <span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">gc</span> <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>
</code></pre></div>    </div>
    <h1 id="lecture-11---working-with-unions">Lecture 11 - Working with Unions</h1>
  </li>
</ul>

<p>For HW examples you need at least 3 examples. Make sure you have no Halloween colors!</p>

<p>Structured data and unions are more powerful than we have demonstrated so far.</p>

<p><strong>Example with Employees:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">fulltime</span> <span class="p">[</span><span class="nf">name</span> <span class="nv">salary</span><span class="p">])</span>
<span class="c1">;; A FullTime is a (make-fulltime String Number)</span>
<span class="c1">;; Interpretation: A (make-fulltime n s) represents</span>
<span class="c1">;; a full time employee named n with annual salary s.</span>
</code></pre></div></div>

<p>When you write a template, you tell yourself that functions that use the structure should use at least one piece of information from the structure.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; fulltime-temp : FullTime -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fulltime-template</span> <span class="nv">ft</span><span class="p">)</span>
  <span class="c1">; Translation: Do something with (fulltime-name ft) and/or</span>
  <span class="c1">; (fulltime-salary ft)</span>
  <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">fulltime-name</span> <span class="nv">ft</span><span class="p">)</span> <span class="o">...</span> <span class="p">(</span><span class="nf">fulltime-salary</span> <span class="nv">ft</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<p>Formal Definitions:</p>

<ul>
  <li>What we‚Äôve been doing; written in pseudo code</li>
</ul>

<p>Informal Definitions:</p>

<ul>
  <li>The English interpretation of what you want to do; expressed in comments.</li>
  <li>Don‚Äôt do this</li>
</ul>

<p><strong>Both <code class="language-plaintext highlighter-rouge">fulltime</code> and <code class="language-plaintext highlighter-rouge">interns</code> are employees.</strong></p>

<h3 id="data-definition---union">Data Definition - Union</h3>

<p>See</p>

<p>[[Lecture 10 - Unions and Structures]]</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; An Employee is one of:</span>
<span class="c1">;; - FullTime</span>
<span class="c1">;; - Intern</span>
<span class="c1">;; Interpretation: An Employee of our prestigious company.</span>
</code></pre></div></div>

<p>If we don‚Äôt use a structure directly (for example, <code class="language-plaintext highlighter-rouge">FullTime</code> or <code class="language-plaintext highlighter-rouge">Intern</code>), we do not need a template for it.</p>

<h3 id="template-1">Template</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">employee-template</span> <span class="nv">emp</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">fulltime?</span> <span class="nv">emp</span><span class="p">)</span>
     <span class="c1">; Call a helper function with emp, that consumes</span>
     <span class="c1">; a Fulltime</span>
     <span class="p">(</span><span class="nf">fulltime-template</span> <span class="nv">emp</span><span class="p">)]</span>
    <span class="c1">; Call a helper function with emp, that consumes an Intern.</span>
    <span class="p">[(</span><span class="nf">intern?</span> <span class="nv">emp</span><span class="p">)</span> <span class="p">(</span><span class="nf">intern-template</span> <span class="nv">emp</span><span class="p">)]))</span>
</code></pre></div></div>

<h3 id="making-a-function-that-works-with-unions">Making a Function that Works with Unions</h3>

<p>Make a conditional with checks for what structure it is then call different helper functions for each possibility.</p>

<p>Ex: Monthly Pay</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; monthly-pay : Employee -&gt; Number</span>
<span class="c1">;; Purpose: Produces the monthly pay for an employee.</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">monthly-pay</span> <span class="nv">employee-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">monthly-pay</span> <span class="nv">employee-2</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">75000</span> <span class="mi">12</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">monthly-pay</span> <span class="nv">emp</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">fulltime?</span> <span class="nv">emp</span><span class="p">)</span> <span class="p">(</span><span class="nf">fulltime-&gt;monthly-pay</span> <span class="nv">emp</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">intern?</span> <span class="nv">emp</span><span class="p">)</span> <span class="p">(</span><span class="nf">intern-&gt;monthly-pay</span> <span class="nv">emp</span><span class="p">)]))</span>
</code></pre></div></div>

<p>Unions with multiple structures is very common in the real world</p>

<h3 id="data-definition-with-no-examples">Data Definition with No Examples</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; An NNN is a non-negative number</span>
</code></pre></div></div>

<p>In the example of <code class="language-plaintext highlighter-rouge">NNN</code>, it is self-explainitory therefore we do not need a data definition for it</p>

<p>You need a template for homework in this calss. If code works but no documentation/template/data definition, you will get about a 30%</p>

<h3 id="templates-with-unions">Templates with Unions</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Define the types of data:</span>
<span class="c1">; - (make-[structure] ...)</span>
<span class="c1">; - (make-[other_structure] ...)</span>
</code></pre></div></div>

<h2 id="species-example">Species Example</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; An NNN is a non-negative number</span>

<span class="c1">; A Species is one of:</span>
<span class="c1">; - "dog"</span>
<span class="c1">; - "cat"</span>
<span class="c1">; - "goldfish"</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">species-template</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="s">"dog"</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="s">"cat"</span><span class="p">)</span> <span class="o">..</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="s">"goldfish"</span><span class="p">)</span> <span class="o">..</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">pet</span> <span class="p">[</span><span class="nf">species</span> <span class="nv">age</span> <span class="nv">weight</span><span class="p">])</span>
<span class="c1">; A Pet is a (make-pet Species NNN NNN)</span>
<span class="c1">; interpretation A (make-pet s a w) represents a pet, where s is the</span>
<span class="c1">; species of animal, with age a in human years, and weight w in pounds.</span>

<span class="c1">;; TODO: Examples and template</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-goldfish</span> <span class="p">(</span><span class="nf">make-pet</span> <span class="s">"goldfish"</span> <span class="mi">19</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">4</span> <span class="mi">16</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-goldfish/v2</span> <span class="p">(</span><span class="nf">make-pet</span> <span class="s">"goldfish"</span> <span class="mi">19</span> <span class="mi">4</span><span class="nv">/16</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-cat</span> <span class="p">(</span><span class="nf">make-pet</span> <span class="s">"cat"</span> <span class="mi">18</span> <span class="mi">17</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-dog</span> <span class="p">(</span><span class="nf">make-pet</span> <span class="s">"dog"</span> <span class="mi">6</span> <span class="mi">50</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pet-template</span> <span class="nv">p</span><span class="p">)</span>
  <span class="c1">; It is a (make-pet ...). Remember to use (pet-species p),</span>
  <span class="c1">; (pet-age p), and/or (pet-weight p).</span>
  <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">pet-species</span> <span class="nv">p</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">pet-age</span> <span class="nv">p</span><span class="p">)</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">pet-weight</span> <span class="nv">p</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span>

<span class="c1">;;-------------------------------------------------------------------</span>

<span class="c1">; Design the function pet-years. It consumes a Pet and returns a</span>
<span class="c1">; sentence with the pet‚Äôs age in the animal‚Äôs own years (i.e., dog years,</span>
<span class="c1">; cat years or goldfish years). The sentence should be of the form</span>
<span class="c1">; "N in animal years" where N is the age in dog years or cat years.</span>
<span class="c1">; E.g., for a pet dog of age 10 in human years, pet-years produces</span>
<span class="c1">; "70 in animal years".</span>

<span class="c1">;  One human year is 7 dog years.</span>
<span class="c1">;  One human year is 4 cat years.</span>
<span class="c1">;  One human year is 5 goldfish years.</span>

<span class="c1">;; Produces a factor to multiply a species age in human years, to get</span>
<span class="c1">;; species animal age.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">species-to-human-years</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="s">"dog"</span><span class="p">)</span> <span class="mi">7</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="s">"Cat"</span><span class="p">)</span> <span class="mi">4</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="s">"goldfish"</span><span class="p">)</span> <span class="mi">5</span><span class="p">]))</span>

<span class="c1">;; pet-years : Pet -&gt; String</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pet-years</span> <span class="nv">p</span><span class="p">)</span>
  <span class="c1">; It is a (make-pet ...). Remember to use (pet-species p),</span>
  <span class="c1">; (pet-age p), and/or (pet-weight p).</span>
  <span class="p">(</span><span class="nb">string-append</span>
   <span class="p">(</span><span class="nb">number-&gt;string</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">species-to-human-years</span> <span class="p">(</span><span class="nf">pet-species</span> <span class="nv">p</span><span class="p">))</span>  <span class="p">(</span><span class="nf">pet-age</span> <span class="nv">p</span><span class="p">)))</span>
   <span class="s">" in animal years"</span><span class="p">))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;;-----------------------------------------------------------------------------
    ;; Problem: We have interns, who work at an hourly rate, and
    ;; full-time employees, who are salaried. We need to keep track
    ;; of these employees, and print out their paychecks once every
    ;; month.

    (define-struct fulltime [name salary])
    ;; A FullTime is a (make-fulltime String Number)
    ;; Interpretation: A (make-fulltime n s) represents
    ;; a full time employee named n with annual salary s.

    (define fulltime-1 (make-fulltime "Josiah Carberry" 75000))
    (define fulltime-2 (make-fulltime "Truman Grayson" 61424))

    ;; fulltime-temp : FullTime -&gt; ?
    (define (fulltime-template ft)
      ; Translation: Do something with (fulltime-name ft) and/or
      ; (fulltime-salary ft)
      (... (fulltime-name ft) ... (fulltime-salary ft) ...))

    ; (/ hours week)
    (define-struct intern [name wage hours/week])
    ;; An Intern is a (make-intern String Number Number)
    ;; Interpretation: A (make-intern n w h) represents an intern
    ;; with name n, hourly wage w, and hours worked per week h.

    (define intern-1 (make-intern "Joe" 15 30))

    (define (intern-template int)
      ; Remember to use (intern-name int), (intern-wage int), or
      ; (intern-hours/week int)
      (... (intern-name int) ...
           (intern-wage int) ...
           (intern-hours/week int) ...))

    ;; An Employee is one of:
    ;; - FullTime
    ;; - Intern
    ;; Interpretation: An Employee of our prestigious company.

    (define employee-1 intern-1)
    (define employee-2 fulltime-1)

    (define (employee-template emp)
      (cond
        [(fulltime? emp)
         ; Call a helper function with emp, that consumes
         ; a Fulltime
         (fulltime-template emp)]
        ; Call a helper function with emp, that consumes an Intern.
        [(intern? emp) (intern-template emp)]))

    ;;------------------------------------------------------
    ;; Design the function monthly-pay
    ;; Assume an intern works exactly 4 weeks per month

    ;; monthly-pay : Employee -&gt; Number
    ;; Purpose: Produces the monthly pay for an employee.

    (check-expect (monthly-pay employee-1) (* 15 30 4))
    (check-expect (monthly-pay employee-2) (/ 75000 12))

    (define (monthly-pay emp)
      (cond
        [(fulltime? emp) (fulltime-&gt;monthly-pay emp)]
        [(intern? emp) (intern-&gt;monthly-pay emp)]))

    ;; fulltime-&gt;monthly-pay : Fulltime -&gt; Number
    ;; Purpose: Produces the monthly pay of a fulltime employee.
    (define (fulltime-&gt;monthly-pay ft)
      (/ (fulltime-salary ft) 12))

    ;; intern-&gt;monthly-pay : Intern -&gt; Number
    (define (intern-&gt;monthly-pay int)
      (* (intern-wage int) (intern-hours/week int) 4))

    ;;-------------------------------------------------------------------

    ;; An NNN is a non-negative number

    ; A Species is one of:
    ; - "dog"
    ; - "cat"
    ; - "goldfish"
    (define (species-template s)
      (cond
        [(string=? s "dog") ...]
        [(string=? s "cat") ..]
        [(string=? s "goldfish") ..]))

    (define-struct pet [species age weight])
    ; A Pet is a (make-pet Species NNN NNN)
    ; interpretation A (make-pet s a w) represents a pet, where s is the
    ; species of animal, with age a in human years, and weight w in pounds.

    ;; TODO: Examples and template
    (define ex-goldfish (make-pet "goldfish" 19 (/ 4 16)))
    (define ex-goldfish/v2 (make-pet "goldfish" 19 4/16))
    (define ex-cat (make-pet "cat" 18 17))
    (define ex-dog (make-pet "dog" 6 50))

    (define (pet-template p)
      ; It is a (make-pet ...). Remember to use (pet-species p),
      ; (pet-age p), and/or (pet-weight p).
      (... (pet-species p) ...
           (pet-age p) ...
           (pet-weight p) ...))

    ;;-------------------------------------------------------------------

    ; Design the function pet-years. It consumes a Pet and returns a
    ; sentence with the pet‚Äôs age in the animal‚Äôs own years (i.e., dog years,
    ; cat years or goldfish years). The sentence should be of the form
    ; "N in animal years" where N is the age in dog years or cat years.
    ; E.g., for a pet dog of age 10 in human years, pet-years produces
    ; "70 in animal years".

    ;  One human year is 7 dog years.
    ;  One human year is 4 cat years.
    ;  One human year is 5 goldfish years.

    ;; Produces a factor to multiply a species age in human years, to get
    ;; species animal age.
    (define (species-to-human-years s)
      (cond
        [(string=? s "dog") 7]
        [(string=? s "Cat") 4]
        [(string=? s "goldfish") 5]))

    ;; pet-years : Pet -&gt; String
    (define (pet-years p)
      ; It is a (make-pet ...). Remember to use (pet-species p),
      ; (pet-age p), and/or (pet-weight p).
      (string-append
       (number-&gt;string (* (species-to-human-years (pet-species p))  (pet-age p)))
       " in animal years"))
</pre>
</details>

<h1 id="lecture-12---into-to-self-referential-data">Lecture 12 - Into to Self Referential Data</h1>

<p>Saturday 10th - Exam study session (4-6pm)</p>

<p>The lab tomorrow (Oct. 6th) explains how to take an exam</p>

<p>Exam</p>

<ul>
  <li>Similar to the homework problems</li>
</ul>

<h2 id="intro-into-self-referential-data">Intro into Self Referential Data</h2>

<p>What if we want a lab with an arbitrary amount of TA‚Äôs?</p>

<p>We could do:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">lab-with-1ta</span> <span class="p">[</span><span class="nf">Name</span> <span class="nv">Number</span><span class="p">])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">lab-with-2tas</span> <span class="p">[</span><span class="nf">Name</span> <span class="nv">Name</span> <span class="nv">Number</span><span class="p">])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">lab-with-3tas</span> <span class="p">[</span><span class="nf">Name</span> <span class="nv">Name</span> <span class="nv">Name</span> <span class="nv">Number</span><span class="p">])</span>
</code></pre></div></div>

<p>This is BAD PRACTICE!</p>

<ul>
  <li>It‚Äôs not scalible</li>
</ul>

<h3 id="how-do-we-have-an-arbatrary-amount-of-tas">How do we have an arbatrary amount of TAs?</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">lab</span> <span class="p">[</span><span class="nf">section</span><span class="p">])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">add-ta</span> <span class="p">[</span><span class="nf">name</span> <span class="nv">rest-lab</span><span class="p">])</span>
<span class="c1">;; A FundiesLab is one of:</span>
<span class="c1">;; - (make-lab Natural)</span>
<span class="c1">;; - (make-add-ta String FundiesLab)</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: A FundiesLab is either a (make-lab n), where n is the section</span>
<span class="c1">;; number of the lab (and it has no TAs assigned); or a (make-add-ta name l),</span>
<span class="c1">;; name is the name of a TA to add to the lab l.</span>
</code></pre></div></div>

<p>In the definition of <code class="language-plaintext highlighter-rouge">FundiesLab</code>, you use a <code class="language-plaintext highlighter-rouge">FundiesLab</code> itself</p>

<p>In this method, you can have arbitrary number of TA‚Äôs</p>

<p>You can also ‚Äúadd‚Äù TA‚Äôs to any already defined lab</p>

<h3 id="template-2">Template</h3>

<p>How can we unpack the box here?</p>

<ul>
  <li>Check to see if it‚Äôs a <code class="language-plaintext highlighter-rouge">lab</code></li>
  <li>Check to see if it‚Äôs an <code class="language-plaintext highlighter-rouge">add-ta</code> (in which case we need to do more work)</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; fundies-lab-template : FundiesLab -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fundies-lab-template</span> <span class="nv">fl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">lab?</span> <span class="nv">fl</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">lab-section</span> <span class="nv">fl</span><span class="p">)</span> <span class="o">...</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">add-ta?</span> <span class="nv">fl</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">add-ta-name</span> <span class="nv">fl</span><span class="p">)</span> <span class="o">...</span>
                       <span class="p">(</span><span class="nf">fundies-lab-template</span> <span class="p">(</span><span class="nf">add-ta-rest-lab</span> <span class="nv">fl</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<p>Notice how the function <code class="language-plaintext highlighter-rouge">fundies-lab-template</code> is called inside of itself</p>

<p>This is called a <strong>RECURSIVE</strong> function</p>

<h3 id="example-function-1">Example Function 1</h3>

<p>Count the number of TA‚Äôs in a given lab</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Problem: Design a function to count the number of TAs in a lab.</span>
<span class="c1">;(check-expect (count-tas lab-ex-1)  0)</span>
<span class="c1">;(check-expect (count-tas lab-ex-2)  1)</span>
<span class="c1">;(check-expect (count-tas lab-ex-3)  2)</span>
<span class="c1">;; count-tas : FundiesLab -&gt;  Natural</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">count-tas</span> <span class="nv">fl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">lab?</span> <span class="nv">fl</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">add-ta?</span> <span class="nv">fl</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">count-tas</span> <span class="p">(</span><span class="nf">add-ta-rest-lab</span> <span class="nv">fl</span><span class="p">)))]))</span>
</code></pre></div></div>

<h3 id="example-function-2">Example Function 2</h3>

<p>Check if ‚ÄúDaniel Goldstein‚Äù is a member of any given lab</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Design a function to check if "Daniel Goldstein" is a member of</span>
<span class="c1">;; a lab.</span>
<span class="c1">;; has-daniel? :: FundiesLab -&gt; Boolean</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">has-daniel?</span> <span class="nv">lab-ex-2</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">has-daniel?</span> <span class="nv">lab-ex-3</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">has-daniel?-bad-style</span> <span class="nv">fl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">lab?</span> <span class="nv">fl</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">add-ta?</span> <span class="nv">fl</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=?</span> <span class="s">"Daniel Goldstein"</span> <span class="p">(</span><span class="nf">add-ta-name</span> <span class="nv">fl</span><span class="p">))</span>
                      <span class="no">#t</span><span class="nv">rue</span>
                      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">has-daniel?-bad-style</span> <span class="p">(</span><span class="nf">add-ta-rest-lab</span> <span class="nv">fl</span><span class="p">))</span>
                          <span class="no">#t</span><span class="nv">rue</span>
                          <span class="no">#f</span><span class="nv">alse</span><span class="p">))]))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">lab-ex-4</span> <span class="p">(</span><span class="nf">make-add-ta</span> <span class="s">"Aislin Black"</span>
                              <span class="p">(</span><span class="nf">make-add-ta</span> <span class="s">"Daniel Goldstein"</span> <span class="p">(</span><span class="nf">make-lab</span> <span class="mi">30</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">has-daniel?</span> <span class="nv">lab-ex-4</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">has-daniel?</span> <span class="nv">fl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">lab?</span> <span class="nv">fl</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">add-ta?</span> <span class="nv">fl</span><span class="p">)</span> <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">string=?</span> <span class="s">"Daniel Goldstein"</span> <span class="p">(</span><span class="nf">add-ta-name</span> <span class="nv">fl</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">has-daniel?</span> <span class="p">(</span><span class="nf">add-ta-rest-lab</span> <span class="nv">fl</span><span class="p">)))]))</span>
</code></pre></div></div>

<h3 id="example-function-3">Example Function 3</h3>

<p>Create a String of a <code class="language-plaintext highlighter-rouge">FundiesLab</code> which describes itself</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Design a function that consumes a FundiesLab and produces a string</span>
<span class="c1">;; describing it.</span>
<span class="c1">;(check-expect (describe-lab lab-ex-3) "Lab 20: Aislin Black Daniel Goldstein")</span>
<span class="c1">;; describe-lab : FundiesLab -&gt; String</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">describe-lab</span> <span class="nv">fl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">lab?</span> <span class="nv">fl</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Lab "</span> <span class="p">(</span><span class="nb">number-&gt;string</span> <span class="p">(</span><span class="nf">lab-section</span> <span class="nv">fl</span><span class="p">)))]</span>
    <span class="p">[(</span><span class="nf">add-ta?</span> <span class="nv">fl</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span>
                   <span class="p">(</span><span class="nf">describe-lab</span> <span class="p">(</span><span class="nf">add-ta-rest-lab</span> <span class="nv">fl</span><span class="p">))</span>
                   <span class="s">" "</span>
                   <span class="p">(</span><span class="nf">add-ta-name</span> <span class="nv">fl</span><span class="p">)</span>
                   <span class="p">)]))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code

</summary>
<pre>
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Suppose we want to keep track of all the TAs in a lab

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; LabWith1TA

    (define-struct lab-with-1ta [ta lab])
    ;; A LabWith1TA is a (make-lab-with-1ta String Natural)
    ;;
    ;; Interpretation: A LabWith1TA represents a Fundies 1 lab section with one TA.

    (define example-lab-with-1ta (make-lab-with-1ta "Aislin Black" 18))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; LabWith2TAs

    (define-struct lab-with-2tas [ta1 ta2 lab])
    ;; A LabWith2TAs is a (make-lab-with-2tas String String Natural)
    ;;
    ;; Interpretation: A LabWith2TAs represents a Fundies 1 lab section with two
    ;; TAs.

    (define example-lab-with-2tas
      (make-lab-with-2tas "Nate Yazdani" "Daniel Goldstein" 13))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; LabWith3TAs

    (define-struct lab-with-3tas [ta1 ta2 lab])
    ;; A LabWith3TAs is a (make-lab-with-3tas String String String Natural)
    ;;
    ;; Interpretation: A LabWith3TAs represents a Fundies 1 lab section with three
    ;; TAs.

    ;; etc.

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define-struct lab [section])
    (define-struct add-ta [name rest-lab])
    ;; A FundiesLab is one of:
    ;; - (make-lab Natural)
    ;; - (make-add-ta String FundiesLab)
    ;;
    ;; Interpretation: A FundiesLab is either a (make-lab n), where n is the section
    ;; number of the lab (and it has no TAs assigned); or a (make-add-ta name l),
    ;; name is the name of a TA to add to the lab l.

    (define lab-ex-1 (make-lab 1))

    (define lab-ex-2 (make-add-ta "Aislin Black" (make-lab 20)))

    (define lab-ex-3 (make-add-ta "Daniel Goldstein" lab-ex-2))

    ;; fundies-lab-template : FundiesLab -&gt; ?
    (define (fundies-lab-template fl)
      (cond
        [(lab? fl) (... (lab-section fl) ...)]
        [(add-ta? fl) (... (add-ta-name fl) ...
                           (fundies-lab-template (add-ta-rest-lab fl)) ...)]))

    ;; Problem: Design a function to count the number of TAs in a lab.
    ;(check-expect (count-tas lab-ex-1)  0)
    ;(check-expect (count-tas lab-ex-2)  1)
    ;(check-expect (count-tas lab-ex-3)  2)
    ;; count-tas : FundiesLab -&gt;  Natural
    (define (count-tas fl)
      (cond
        [(lab? fl) 0]
        [(add-ta? fl) (+ 1 (count-tas (add-ta-rest-lab fl)))]))

    (count-tas lab-ex-3)

    ;; Design a function to check if "Daniel Goldstein" is a member of
    ;; a lab.
    ;; has-daniel? :: FundiesLab -&gt; Boolean
    (check-expect (has-daniel? lab-ex-2) #false)
    (check-expect (has-daniel? lab-ex-3) #true)

    (define (has-daniel?-bad-style fl)
      (cond
        [(lab? fl) #false]
        [(add-ta? fl) (if (string=? "Daniel Goldstein" (add-ta-name fl))
                          #true
                          (if (has-daniel?-bad-style (add-ta-rest-lab fl))
                              #true
                              #false))]))

    (define lab-ex-4 (make-add-ta "Aislin Black"
                                  (make-add-ta "Daniel Goldstein" (make-lab 30))))

    (check-expect (has-daniel? lab-ex-4) #true)

    (define (has-daniel? fl)
      (cond
        [(lab? fl) #false]
        [(add-ta? fl) (or (string=? "Daniel Goldstein" (add-ta-name fl))
                          (has-daniel? (add-ta-rest-lab fl)))]))

    ;; Design a function that consumes a FundiesLab and produces a string
    ;; describing it.
    ;(check-expect (describe-lab lab-ex-3) "Lab 20: Aislin Black Daniel Goldstein")
    ;; describe-lab : FundiesLab -&gt; String

    (define (describe-lab fl)
      (cond
        [(lab? fl) (string-append "Lab " (number-&gt;string (lab-section fl)))]
        [(add-ta? fl) (string-append
                       (describe-lab (add-ta-rest-lab fl))
                       " "
                       (add-ta-name fl)
                       )]))
</pre>
</details>
<h1 id="lecture-13---continued-refferential-data-definitions">Lecture 13 - Continued Refferential Data Definitions</h1>

<h3 id="bullseye-example">Bullseye Example</h3>

<ul>
  <li>Self refferential union</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">ring</span> <span class="p">[</span><span class="nf">color</span> <span class="nv">radius</span> <span class="nv">more</span><span class="p">])</span>
<span class="c1">;; A Bullseye is a</span>
<span class="c1">;; - "center"</span>
<span class="c1">;; - (make-ring String NNN Bullseye)</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: Represents concentric rings of a bullseye target, with</span>
<span class="c1">;; _"center"_ representing the center (with no rings), and _(make-ring c r b)_</span>
<span class="c1">;; representing the target whose outermost ring has color _c_ and radius _r_,</span>
<span class="c1">;; and the remaining rings within are _b_.</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-be-1</span> <span class="s">"center"</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-be-2</span> <span class="p">(</span><span class="nf">make-ring</span> <span class="s">"red"</span> <span class="mi">10</span> <span class="nv">ex-be-1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-be-3</span> <span class="p">(</span><span class="nf">make-ring</span> <span class="s">"white"</span> <span class="mi">20</span> <span class="nv">ex-be-2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-be-4</span> <span class="p">(</span><span class="nf">make-ring</span> <span class="s">"red"</span> <span class="mi">30</span> <span class="nv">ex-be-3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-be-5</span> <span class="p">(</span><span class="nf">make-ring</span> <span class="s">"green"</span> <span class="mi">35</span> <span class="nv">ex-be-2</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="template-3">Template</h3>

<p>CamelCase for Data Definitions and hypenations for structures</p>

<p>Whenever you have a union, you use a conditional in the template</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; bullseye-template : Bullseye -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">bullseye-template</span> <span class="nv">be</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string?</span> <span class="nv">be</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">ring?</span> <span class="nv">be</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">ring-color</span> <span class="nv">be</span><span class="p">)</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">ring-radius</span> <span class="nv">be</span><span class="p">)</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">bullseye-template</span> <span class="p">(</span><span class="nf">ring-more</span> <span class="nv">be</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<p>Remeber: whenever you have a box inside another box, you should write a helper function</p>

<h3 id="example-function-1---count-rings">Example Function 1 - Count Rings</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; count-rings : Bullseye -&gt; Number</span>
<span class="c1">;; Counts the number of rings in a Bullseye; the "center" is not</span>
<span class="c1">;; a ring.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">count-rings</span> <span class="nv">be</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string?</span> <span class="nv">be</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">ring?</span> <span class="nv">be</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">count-rings</span> <span class="p">(</span><span class="nf">ring-more</span> <span class="nv">be</span><span class="p">)))]))</span>
</code></pre></div></div>

<h3 id="example-function-2---produce-black-and-white-rings">Example Function 2 - Produce Black and White Rings</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; make-bw : Bullseye -&gt; Bullseye</span>
<span class="c1">;; Produces a B&amp;W version of the given Bullseye</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-bw</span> <span class="nv">be</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string?</span> <span class="nv">be</span><span class="p">)</span> <span class="s">"center"</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">ring?</span> <span class="nv">be</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-ring</span>
                 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=?</span> <span class="s">"white"</span> <span class="p">(</span><span class="nf">ring-color</span> <span class="nv">be</span><span class="p">))</span>
                     <span class="s">"white"</span>
                     <span class="s">"black"</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">ring-radius</span> <span class="nv">be</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">make-bw</span> <span class="p">(</span><span class="nf">ring-more</span> <span class="nv">be</span><span class="p">)))]))</span>
</code></pre></div></div>

<p>For check-expects, you should always check the base case</p>

<p>When writing functions, ask 3 questions:</p>

<ul>
  <li>What should I do with the base case?</li>
  <li>How am I processing each recursive case?</li>
  <li>How do I put things together?</li>
</ul>

<h3 id="doll-example">Doll Example</h3>

<p>Nesting dolls</p>

<ul>
  <li>2 Types of recursive data</li>
  <li>Make sure, if yo use <code class="language-plaintext highlighter-rouge">string?</code>, that you onlu have on string in the data definition</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">blue-shell</span> <span class="p">(</span><span class="nf">doll</span><span class="p">))</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">red-shell</span> <span class="p">(</span><span class="nf">doll</span><span class="p">))</span>
<span class="c1">;; A RussianDoll is one of:</span>
<span class="c1">;; - "solid"</span>
<span class="c1">;; - (make-blue-shell RussianDoll)</span>
<span class="c1">;; - (make-red-shell RussianDoll)</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: Represents a collection of russian nesting dolls. _"center"_</span>
<span class="c1">;; represents a solid doll. _(make-blue-shell d)_ represents a blue doll that</span>
<span class="c1">;; contains _d_ immediately within it. _(make-red-shell d)_ represents a red</span>
<span class="c1">;; doll that contains_d_ immediately within it.</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; count-blue : RussianDoll -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">count-blue</span> <span class="nv">doll</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string?</span> <span class="nv">doll</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">blue-shell?</span> <span class="nv">doll</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">count-blue</span> <span class="p">(</span><span class="nf">blue-shell-doll</span> <span class="nv">doll</span><span class="p">)))]</span>
    <span class="c1">;[(red-shell? doll) 0]</span>
    <span class="c1">;[(red-shell? doll)</span>
    <span class="c1">;  0 (count-blue (red-shell-doll doll))]</span>
    <span class="p">[(</span><span class="nf">red-shell?</span> <span class="nv">doll</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">count-blue</span> <span class="p">(</span><span class="nf">red-shell-doll</span> <span class="nv">doll</span><span class="p">))]))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-dolls-1</span> <span class="s">"solid"</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-dolls-2</span> <span class="p">(</span><span class="nf">make-red-shell</span> <span class="nv">ex-dolls-1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-dolls-3</span> <span class="p">(</span><span class="nf">make-blue-shell</span> <span class="nv">ex-dolls-2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-dolls-4</span> <span class="p">(</span><span class="nf">make-red-shell</span> <span class="nv">ex-dolls-2</span><span class="p">))</span>

<span class="c1">;; russian-doll-template : RussianDoll -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">russian-doll-template</span> <span class="nv">doll</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string?</span> <span class="nv">doll</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">blue-shell?</span> <span class="nv">doll</span><span class="p">)</span>
     <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">russian-doll-template</span> <span class="p">(</span><span class="nf">blue-shell-doll</span> <span class="nv">doll</span><span class="p">))</span> <span class="o">...</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">red-shell?</span> <span class="nv">doll</span><span class="p">)</span>
     <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">russian-doll-template</span> <span class="p">(</span><span class="nf">red-shell-doll</span> <span class="nv">doll</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>

<span class="c1">;; Write a function to count the number of blue-painted dolls in a</span>
<span class="c1">;; set of russian dolls.</span>
</code></pre></div></div>

<h2 id="lists">Lists</h2>

<p>Think of it as a structure with 2 fields</p>

<p>Empty List  - <code class="language-plaintext highlighter-rouge">'()</code></p>

<p>ex. <code class="language-plaintext highlighter-rouge">(cons 1 (cons 2 (cons 3 '())))</code></p>

<p>Examples:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">empty?</span> <span class="o">'</span><span class="p">())</span> <span class="c1">; true</span>
<span class="p">(</span><span class="nf">cons?</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="o">'</span><span class="p">()))</span> <span class="c1">; true</span>
<span class="p">(</span><span class="nf">first</span> <span class="nv">ex-list</span><span class="p">)</span> <span class="c1">; first element</span>
<span class="p">(</span><span class="nf">rest</span> <span class="nv">ex-list</span><span class="p">)</span> <span class="c1">; the rest of the list (2nd element)</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code

</summary>
<pre>
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define-struct ring [color radius more])
    ;; A Bullseye is a
    ;; - "center"
    ;; - (make-ring String NNN Bullseye)
    ;;
    ;; Interpretation: Represents concentric rings of a bullseye target, with
    ;; _"center"_ representing the center (with no rings), and _(make-ring c r b)_
    ;; representing the target whose outermost ring has color _c_ and radius _r_,
    ;; and the remaining rings within are _b_.

    (define ex-be-1 "center")
    (define ex-be-2 (make-ring "red" 10 ex-be-1))
    (define ex-be-3 (make-ring "white" 20 ex-be-2))
    (define ex-be-4 (make-ring "red" 30 ex-be-3))
    (define ex-be-5 (make-ring "green" 35 ex-be-2))

    ;; bullseye-template : Bullseye -&gt; ?
    (define (bullseye-template be)
      (cond
        [(string? be) ...]
        [(ring? be) (... (ring-color be) ...
                         (ring-radius be) ...
                         (bullseye-template (ring-more be)) ...)]))

    ;; count-rings : Bullseye -&gt; Number
    ;; Counts the number of rings in a Bullseye; the "center" is not
    ;; a ring.
    (define (count-rings be)
      (cond
        [(string? be) 0]
        [(ring? be) (+ 1 (count-rings (ring-more be)))]))

    ;(check-expect (count-rings ex-be-5) 2)
    (check-expect (count-rings ex-be-4) 3)

    ;; make-bw : Bullseye -&gt; Bullseye
    ;; Produces a B&amp;W version of the given Bullseye
    (define (make-bw be)
      (cond
        [(string? be) "center"]
        [(ring? be) (make-ring
                     (if (string=? "white" (ring-color be))
                         "white"
                         "black")
                     (ring-radius be)
                     (make-bw (ring-more be)))]))

    (check-expect (make-bw ex-be-3)
                  (make-ring "white" 20 (make-ring "black" 10 "center")))

    ;;; draw-bullseye : Bullseye -&gt; Bullseye

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define-struct blue-shell (doll))
    (define-struct red-shell (doll))
    ;; A RussianDoll is one of:
    ;; - "solid"
    ;; - (make-blue-shell RussianDoll)
    ;; - (make-red-shell RussianDoll)
    ;;
    ;; Interpretation: Represents a collection of russian nesting dolls. _"center"_
    ;; represents a solid doll. _(make-blue-shell d)_ represents a blue doll that
    ;; contains _d_ immediately within it. _(make-red-shell d)_ represents a red
    ;; doll that contains_d_ immediately within it.

    ;; count-blue : RussianDoll -&gt; Number
    (define (count-blue doll)
      (cond
        [(string? doll) 0]
        [(blue-shell? doll)
         (+ 1 (count-blue (blue-shell-doll doll)))]
        ;[(red-shell? doll) 0]
        ;[(red-shell? doll)
        ;  0 (count-blue (red-shell-doll doll))]
        [(red-shell? doll)
          (count-blue (red-shell-doll doll))]))

    (define ex-dolls-1 "solid")
    (define ex-dolls-2 (make-red-shell ex-dolls-1))
    (define ex-dolls-3 (make-blue-shell ex-dolls-2))
    (define ex-dolls-4 (make-red-shell ex-dolls-2))

    ;; russian-doll-template : RussianDoll -&gt; ?
    (define (russian-doll-template doll)
      (cond
        [(string? doll) ...]
        [(blue-shell? doll)
         (... (russian-doll-template (blue-shell-doll doll)) ...)]
        [(red-shell? doll)
         (... (russian-doll-template (red-shell-doll doll)) ...)]))

    ;; Write a function to count the number of blue-painted dolls in a
    ;; set of russian dolls.
    
</pre>
</details>
<h1 id="lecture-14---lists-and-midterm-prep">Lecture 14 - Lists and Midterm Prep</h1>

<h2 id="midterm">Midterm</h2>

<ul>
  <li>Next Wednesday at 6-9pm</li>
  <li>Everything but lists</li>
  <li>No electronics besides one computer</li>
  <li>Open-ended questions</li>
  <li>Review session this Saturday</li>
  <li>Open note/book</li>
  <li>Practice exam on Hourglass</li>
  <li>Similar to homework
    <ul>
      <li>Remeber the design recipe</li>
    </ul>
  </li>
</ul>

<h2 id="lists-1">Lists</h2>

<ul>
  <li>Empty: <code class="language-plaintext highlighter-rouge">'()</code></li>
  <li>Create List: <code class="language-plaintext highlighter-rouge">(cons 10 '())</code></li>
  <li><strong>Selectors</strong>
    <ul>
      <li>First (ex. <code class="language-plaintext highlighter-rouge">(first ex-list-1)</code>): returns the first element of the list</li>
      <li>Rest (ex. <code class="language-plaintext highlighter-rouge">(rest ex-list-1)</code>): Returns the second element of the list (aka the rest of the list)</li>
    </ul>
  </li>
</ul>

<h3 id="data-definition-and-template">Data Definition and Template</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A LON (list of numbers) is one of:</span>
<span class="c1">;; - '()</span>
<span class="c1">;; - (cons Number LON)</span>
<span class="c1">;; Interpretation: a list of numbers</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-lon-0</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">3</span> <span class="o">'</span><span class="p">()))))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-lon-1</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="nv">ex-lon-0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">lon-template</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">...</span>
                      <span class="p">(</span><span class="nf">lon-template</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<p>If you return atomic data, you don‚Äôt send it through a helper function</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LON</code> has to be sent through the helper function (the template)</li>
</ul>

<h3 id="example-function-1-sum-of-numberes">Example Function 1: Sum of Numberes</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Write a function sum a list of numbers.</span>
<span class="c1">;; sum : LON -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">)</span>
                      <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">))</span> <span class="p">)]))</span>
</code></pre></div></div>

<h3 id="example-function-2-product-of-numbers">Example Function 2: Product of Numbers</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; prod : LON -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prod</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">)</span>
                      <span class="p">(</span><span class="nf">prod</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">)))]))</span>
</code></pre></div></div>

<p>You can‚Äôt have the product of the empty list when it equals 0. Because the base case is always run, if you multiply it by 0, the entire thing turns to 0. Therefore, the product of empty list is usually 1.</p>

<p>If you want to have the base case 0, you need to do this:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prod/v2</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">)</span>
                    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">))</span>
                        <span class="mi">1</span>
                        <span class="p">(</span><span class="nf">prod/v2</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">))))]))</span>
</code></pre></div></div>

<h3 id="string-example">String Example</h3>

<p>Template is exactly the same as <code class="language-plaintext highlighter-rouge">lon</code>‚Äôs template.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A LOS (list of strings) is one of:</span>
<span class="c1">;; - '()</span>
<span class="c1">;; - (cons String LOS)</span>
<span class="c1">;; Interpretation: A list of strings.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">los-template</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">)</span> <span class="o">...</span>
                      <span class="p">(</span><span class="nf">los-template</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<ul>
  <li>Not good to repeat code (we will learn a single template for lists later)</li>
</ul>

<h3 id="posnlist-example">PosnList Example</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A PosnList is one of:</span>
<span class="c1">;; - '()</span>
<span class="c1">;; - (cons (make-posn Number Number) PosnList)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-posn-list-1</span>
  <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="mi">137</span> <span class="mi">137</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">)</span>
                    <span class="o">'</span><span class="p">()))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">posn-list-template</span> <span class="nv">pl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">pl</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">pl</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">posn-x</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">pl</span><span class="p">))</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">posn-y</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">pl</span><span class="p">))</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">posn-list-template</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">pl</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<p>When writing data definitions, make sure that the base case is first (a matter of style)</p>

<p>Remeber: Don‚Äôt ‚Äòunpack‚Äô more than one box with the same template! Send it to another template!</p>

<ul>
  <li>It won‚Äôt be scalable</li>
</ul>

<p><strong>Posn-Structure: <code class="language-plaintext highlighter-rouge">(make-posn x y)</code></strong></p>

<h3 id="example-function-with-posn-list">Example Function with POSN-LIST</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; invert-posnlist :: PosnList -&gt; PosnList</span>
<span class="c1">;; Invert all coordinates in the given PosnList</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">invert-posnlist</span> <span class="nv">pl</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">pl</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">pl</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">-1</span> <span class="p">(</span><span class="nf">posn-x</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">pl</span><span class="p">)))</span>
                                 <span class="p">(</span><span class="nb">*</span> <span class="mi">-1</span> <span class="p">(</span><span class="nf">posn-y</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">pl</span><span class="p">))))</span>
                      <span class="p">(</span><span class="nf">invert-posnlist</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">pl</span><span class="p">)))]))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;; A LON (list of numbers) is one of:
    ;; - '()
    ;; - (cons Number LON)
    ;; Interpretation: a list of numbers
    (define ex-lon-0 (cons 1 (cons 2 (cons 3 '()))))
    (define ex-lon-1 (cons 2 ex-lon-0))

    (define (lon-template lon)
      (cond
        [(empty? lon) ...]
        [(cons? lon) (... (first lon) ...
                          (lon-template (rest lon)) ...)]))

    ;; Write a function sum a list of numbers.
    ;; sum : LON -&gt; Number
    (define (sum lon)
      (cond
        [(empty? lon) 0]
        [(cons? lon) (+ (first lon)
                          (sum (rest lon)) )]))

    ;(check-expect (sum ex-lon-0) 6)
    ;(check-expect (sum ex-lon-1) 8)

    ;; prod : LON -&gt; Number
    (define (prod lon)
      (cond
        [(empty? lon) 0]
        [(cons? lon) (* (first lon)
                          (prod (rest lon)))]))

    ;(check-expect (prod (cons 10 (cons 3 (cons 5 '())))) (* 10 3 5))

    (prod (cons 10 (cons 3 '())))

    #;(define (prod/v2 lon)
      (cond
        [(empty? lon) 0]
        [(cons? lon) (* (first lon)
                        (if (empty? (rest lon))
                            1
                            (prod/v2 (rest lon))))]))

    ;; A LOS (list of strings) is one of:
    ;; - '()
    ;; - (cons String LOS)
    ;; Interpretation: A list of strings.
    (define (los-template los)
      (cond
        [(empty? los) ...]
        [(cons? los) (... (first los) ...
                          (los-template (rest los)) ...)]))

    (define profs
      (cons "Amal" (cons "Arjun" (cons "Ben" (cons "John" (cons "Ferd" '()))))))

    ;; Write a function to calculate the total length of a LOS.
    ;; count-length : LOS -&gt; Integer
    (check-expect (count-length profs)
                  (+ (string-length "Amal") (string-length "Arjun")
                     (string-length "Ben") (string-length "John")
                     (string-length "Ferd")))

    (define (count-length los)
      (cond
        [(empty? los) 0]
        [(cons? los) (+ (string-length (first los))
                        (count-length (rest los)))]))

    ;; A Coord is a (make-posn Number Number)
    (define (coord-template c)
      (... (posn-x c) ...
           (posn-y c) ...))

    #|
    ;; A PosnList is one of:
    ;; - '()
    ;; - (cons Coord PosnList)
    (define (posn-list-template/v2 pl)
      (cond
        [(empty? pl) ...]
        [(cons? pl) (... (coord-template (first pl)) ...
                         (posn-list-template/v2 (rest pl)) ...)]))

    |#

    ;; A PosnList is one of:
    ;; - '()
    ;; - (cons (make-posn Number Number) PosnList)

    (define ex-posn-list-1
      (cons (make-posn 137 137)
            (cons (make-posn 10 20)
                  (cons (make-posn 30 40)
                        '()))))

    (define (posn-list-template pl)
      (cond
        [(empty? pl) ...]
        [(cons? pl) (... (posn-x (first pl)) ...
                         (posn-y (first pl)) ...
                         (posn-list-template (rest pl)) ...)]))

    ;; invert-posnlist :: PosnList -&gt; PosnList
    ;; Invert all coordinates in the given PosnList
    (define (invert-posnlist pl)
      (cond
        [(empty? pl) '()]
        [(cons? pl) (cons (make-posn (* -1 (posn-x (first pl)))
                                     (* -1 (posn-y (first pl))))
                          (invert-posnlist (rest pl)))]))

    (define ex-posn-list-1-negated
      (cons (make-posn -137 -137)
            (cons (make-posn -10 -20)
                  (cons (make-posn -30 -40)
                        '()))))

    (check-expect (invert-posnlist ex-posn-list-1) ex-posn-list-1-negated)
</pre>
</details>
<h1 id="lecture-16---intro-to-snake-game">Lecture 16 - Intro to Snake Game</h1>

<h3 id="exam-yesterday">Exam Yesterday</h3>

<ul>
  <li>Tech issues! Didn‚Äôt go well</li>
  <li>Thinking abpout options for the 2nd midterm
    <ul>
      <li>maybe just take home exam</li>
    </ul>
  </li>
</ul>

<p>Wants feedback for the class</p>

<ul>
  <li>Have any problems?</li>
</ul>

<p>Homework due date pushed back until Saturday</p>

<p>Mid-semester surveys</p>

<ul>
  <li>They are important</li>
  <li>Long queue for Office Hours
    <ul>
      <li>Tweaks being implemented</li>
    </ul>
  </li>
</ul>

<h2 id="building-the-snake-game">Building the Snake Game</h2>

<p>‚ÄúDon‚Äôt use Reddit; it‚Äôs not good for you‚Äù - Arjun</p>

<p>Projects will drag on for 3-4 homework assignments</p>

<p>Goal: Build a Big-Bang program</p>

<ul>
  <li>on-tick = move the snake</li>
  <li>on-key = change direction of snake</li>
  <li>on-draw = draw</li>
  <li>stop-when = game over</li>
</ul>

<h3 id="what-is-the-scene">What is the Scene?</h3>

<ul>
  <li>Everything of interest
    <ul>
      <li>Position of snake‚Äôs segments</li>
      <li>Direction of snake</li>
    </ul>
  </li>
</ul>

<h3 id="what-goes-into-the-world-state">What Goes into the World State?</h3>

<ul>
  <li>Things that change/are updated</li>
  <li>Everything else should just be a constant</li>
</ul>

<p>The brainstorm from class:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; X &amp; Y coord of snake's head</span>
<span class="c1">; length of snake</span>
<span class="c1">; position of snake</span>
<span class="c1">; direction in which the snake is moving</span>
<span class="c1">; game clock</span>
<span class="c1">; food position</span>
</code></pre></div></div>

<h3 id="segments-of-the-snake">Segments of the Snake</h3>

<ul>
  <li>Self-referential data-definition</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A Segments is a NEListofPosn</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: The grid coordinates where the snake lies, the</span>
<span class="c1">;; position of the head is the first element of the NEList.</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-segs-1</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="o">'</span><span class="p">())))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-segs-2</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="mi">4</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">ex-segs-1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-segs-3</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">make-posn</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">ex-segs-2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">segs-template</span> <span class="nv">ss</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">ss</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">ss</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">ss</span><span class="p">)</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">segs-template</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">ss</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">NEListofPosn</code> = ‚Äúnon-empty list of Posns‚Äù</p>

<ul>
  <li>The first one is the head and the last one is the tail</li>
  <li>Remeber: the difference between sugments have to be 1 in the x or 1 in the y needs to be continuous
    <ul>
      <li>Make sure your examples are correct</li>
    </ul>
  </li>
</ul>

<p>While doing a project, you should switch perspectives (high level vs. low level) frequently</p>

<h3 id="snake-data-definition">Snake Data Definition</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A Snake is a (make-snake Direction Segments)</span>
<span class="c1">;; Interpretation: A snake _(make-snape d ss)_ is a snake in</span>
<span class="c1">;; moving in _d_, and laying at _ss_ on the grid.</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">snake-1</span> <span class="p">(</span><span class="nf">make-snake</span> <span class="s">"left"</span> <span class="nv">ex-segs-1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">snake-2</span> <span class="p">(</span><span class="nf">make-snake</span> <span class="s">"up"</span> <span class="nv">ex-segs-2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">snake-3</span> <span class="p">(</span><span class="nf">make-snake</span> <span class="s">"up"</span> <span class="nv">ex-segs-3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">snake-4</span> <span class="p">(</span><span class="nf">make-snake</span> <span class="s">"left"</span> <span class="nv">ex-segs-3</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">snake-template</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">direction-template</span> <span class="p">(</span><span class="nf">snake-dir</span> <span class="nv">s</span><span class="p">))</span> <span class="o">...</span>
       <span class="p">(</span><span class="nf">segments-template</span> <span class="p">(</span><span class="nf">snake-segs</span> <span class="nv">s</span><span class="p">))</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="draw-snake-function">Draw-snake Function</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; draw-segments : Segments -&gt; Image</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-segments</span> <span class="nv">ss</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">ss</span><span class="p">)</span> <span class="nv">BACKGROUND</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">ss</span><span class="p">)</span> <span class="p">(</span><span class="nf">place-image</span> <span class="nv">SEGMENT-IMAGE</span>
                             <span class="p">(</span><span class="nb">*</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">posn-x</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">ss</span><span class="p">)))</span>
                             <span class="p">(</span><span class="nb">*</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">posn-y</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">ss</span><span class="p">)))</span>
                             <span class="p">(</span><span class="nf">draw-segments</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">ss</span><span class="p">)))]))</span>
<span class="c1">;; draw-snake :: Snake -&gt; Image</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-snake</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">draw-segments</span> <span class="p">(</span><span class="nf">snake-segs</span> <span class="nv">s</span><span class="p">)))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    (require 2htdp/image)
    (require 2htdp/universe)

    ;; Some nice constants

    (define BOARD-HEIGHT 20) ; the hieght of the game board in grid squares
    (define BOARD-WIDTH 30) ; the width of the gram eboard in grid squares

    (define GRID-SQSIZE 10) ; the width and height of the grid squares

    (define BOARD-HEIGHT/PIX (* BOARD-HEIGHT GRID-SQSIZE)) ; board height in pixels
    (define BOARD-WIDTH/PIX (* BOARD-WIDTH GRID-SQSIZE)) ; board width in pixels

    (define BACKGROUND (empty-scene BOARD-WIDTH/PIX BOARD-HEIGHT/PIX))

    (define SEGMENT-RADIUS (/ GRID-SQSIZE 2))
    (define SEGMENT-IMAGE (circle SEGMENT-RADIUS "solid" "red"))

    (define FOOD-RADIUS (floor (* 0.9 SEGMENT-RADIUS)))
    (define FOOD-IMAGE (circle FOOD-RADIUS "solid" "green"))

    (define TICK-RATE 0.3)

    ;;;;

    ;; A Direction is one of:
    ;; - "left"
    ;; - "right"
    ;; - "up"
    ;; - "down"
    (define (direction-template dir)
      (cond [(string=? dir "up") ...]
            [(string=? dir "down") ...]
            [(string=? dir "left") ...]
            [(string=? dir "right") ...]))

    ;; A Segments is one of:
    ;; - '()
    ;; - (cons (make-posn PosInt PosInt) Segments)
    ;;
    ;; Alternative to above:
    ;;
    ;; A Segments is a ListofPosn
    ;;
    ;; Correct data definition:
    ;;
    ;; A Segments is a NEListofPosn
    ;;
    ;; Interpretation: The grid coordinates where the snake lies, the
    ;; position of the head is the first element of the NEList.
    (define ex-segs-1 (cons (make-posn 4 4) (cons (make-posn 4 5) '())))
    (define ex-segs-2 (cons (make-posn 4 3) ex-segs-1))
    (define ex-segs-3 (cons (make-posn 3 3) ex-segs-2))

    (define (segs-template ss)
      (cond
        [(empty? ss) ...]
        [(cons? ss) (... (first ss) ...
                         (segs-template (rest ss)) ...)]))


    (define-struct snake [dir segs])
    ;; A Snake is a (make-snake Direction Segments)
    ;; Interpretation: A snake _(make-snape d ss)_ is a snake in
    ;; moving in _d_, and laying at _ss_ on the grid.
    (define snake-1 (make-snake "left" ex-segs-1))
    (define snake-2 (make-snake "up" ex-segs-2))
    (define snake-3 (make-snake "up" ex-segs-3))
    (define snake-4 (make-snake "left" ex-segs-3))

    (define (snake-template s)
      (... (direction-template (snake-dir s)) ...
           (segments-template (snake-segs s)) ...))

    ;; draw-segments : Segments -&gt; Image
    (define (draw-segments ss)
      (cond
        [(empty? ss) BACKGROUND]
        [(cons? ss) (place-image SEGMENT-IMAGE
                                 (* 10 (posn-x (first ss)))
                                 (* 10 (posn-y (first ss)))
                                 (draw-segments (rest ss)))]))

    ;; draw-snake :: Snake -&gt; Image
    (define (draw-snake s)
      (draw-segments (snake-segs s)))

    ; X &amp; Y coord of snake's head
    ; length of snake
    ; position of snake
    ; direction in which the snake is moving
    ; game clock
    ; food position

    ; if a key is pressed
    ; if-snake is self-intersecting

    ; X &amp; Y coord of snake's head (in world state)
    ; length of snake
    ; position of snake
    ; dimensions of the board (constant?)
    ; game clock
    ; food position
    ; direction in which the snake is moving
    ; if a key is pressed
    ; if-snake is self-intersecting
</pre>
</details>
<h1 id="lecture-17---into-to-abstraction">Lecture 17 - Into to Abstraction</h1>

<p>Midterm grades will be released at the end of the day today</p>

<p><strong>Partner Switch</strong></p>

<ul>
  <li>Only switch of the semester happens this week</li>
</ul>

<h2 id="part-ii-of-the-class-abstractions">Part II of the Class: Abstractions</h2>

<p>Beginner Student Language ‚Üí Intermediate Student Language</p>

<ul>
  <li>Lists can now be represented as <code class="language-plaintext highlighter-rouge">(list 1 2 3 4 5)</code>
    <ul>
      <li>Function <code class="language-plaintext highlighter-rouge">(list?</code> returns whether or not something is a <code class="language-plaintext highlighter-rouge">cons</code> or <code class="language-plaintext highlighter-rouge">'()</code></li>
    </ul>
  </li>
  <li>This is useful for nested lists</li>
</ul>

<p>‚Äô() can also be written as (list)</p>

<h2 id="abstraction">Abstraction</h2>

<p>Design a function that prefixes every String in a list of Strings with ‚ÄúHi ‚Äú</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Design a function that consumes a ListOfStrings and produces</span>
<span class="c1">;; a new list that prefixes all strings with "Hi ".</span>
<span class="c1">;; prefix-hi : ListOfStrings -&gt; ListOfStrings</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prefix-hi/v1</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Hi "</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">prefix-hi/v1</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">)))]))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">prefix-hi/v1</span> <span class="p">(</span><span class="nb">list</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">prefix-hi/v1</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Arjun"</span> <span class="s">"Amal"</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">list</span> <span class="s">"Hi Arjun"</span> <span class="s">"Hi Amal"</span><span class="p">))</span>
</code></pre></div></div>

<p>Design a funciton that prefixes every String in a list of String with ‚ÄúHi ‚Äú</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; prefix-bye : ListOfStrings -&gt; ListOfStrings</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prefix-bye/v1</span> <span class="nv">los</span><span class="p">)</span>

  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Bye "</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">prefix-bye/v1</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">)))]))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">prefix-bye/v1</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Arjun"</span> <span class="s">"Amal"</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">list</span> <span class="s">"Bye Arjun"</span> <span class="s">"Bye Amal"</span><span class="p">))</span>
</code></pre></div></div>

<p>Don‚Äôt copy and paste code!! Programmers make 1 error for every 10 linues so you would copy and paste the errors as well</p>

<p>The other reason is you‚Äôre left with <strong>repetitive code</strong></p>

<ul>
  <li>Bad practice</li>
</ul>

<h3 id="example-1-prefixes">Example 1: Prefixes</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; prefix-with : String ListOfStrings -&gt; ListOfStrings</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prefix-with</span> <span class="nv">to-prefix</span> <span class="nv">los</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">string-append</span> <span class="nv">to-prefix</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">prefix-with</span> <span class="nv">to-prefix</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">)))]))</span>

<span class="c1">;; prefix-hi/v2 : ListOfStrings -&gt; ListOfStrings</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prefix-hi/v2</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">prefix-with</span> <span class="s">"Hi "</span> <span class="nv">los</span><span class="p">))</span>

<span class="c1">;; prefix-bye/v2 : ListOfStrings -&gt; ListOfStrings</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prefix-bye/v2</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">prefix-with</span> <span class="s">"Bye "</span> <span class="nv">los</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">prefix-bye/v2</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Arjun"</span> <span class="s">"Amal"</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">list</span> <span class="s">"Bye Arjun"</span> <span class="s">"Bye Amal"</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">prefix-hi/v2</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Arjun"</span> <span class="s">"Amal"</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">list</span> <span class="s">"Hi Arjun"</span> <span class="s">"Hi Amal"</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>Reduces the repetition by taking out the similarity</li>
</ul>

<h3 id="example-2-addition-and-multiplication">Example 2: Addition and Multiplication</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add-ten-all : LON -&gt; LON</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add-ten-all</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
              <span class="o">'</span><span class="p">(</span><span class="nf">11</span> <span class="mi">12</span> <span class="mi">13</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-ten-all</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">add-ten-all</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">)))]))</span>

<span class="c1">;; mul-five-all : LON -&gt; LON</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">mul-five-all</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
              <span class="o">'</span><span class="p">(</span><span class="nf">5</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">mul-five-all</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">mul-five-all</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">)))]))</span>
</code></pre></div></div>

<p>There are two fundamental differences between these functions</p>

<ul>
  <li>Operation and number</li>
</ul>

<p><strong>How can we have only 1 difference?</strong></p>

<p>Create helper function that does the operation on a single number</p>

<ul>
  <li>The only difference is the helper funciton they call</li>
</ul>

<h3 id="you-can-have-funcitons-as-function-parameters">You can have funcitons as function parameters!!!</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add10 : Number -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add10</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="mi">10</span> <span class="nv">n</span><span class="p">))</span>

<span class="c1">;; mul5 : Number -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">mul5</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="nv">n</span><span class="p">))</span>

<span class="c1">;; add-ten-all/v2 : LON -&gt; LON</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-ten-all/v2</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">add10</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">add-ten-all/v2</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">)))]))</span>

<span class="c1">;; mul-five-all/v2 : LON -&gt; LON</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">mul-five-all/v2</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">mul5</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">mul-five-all/v2</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">)))]))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add-ten-all/v2</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
              <span class="o">'</span><span class="p">(</span><span class="nf">11</span> <span class="mi">12</span> <span class="mi">13</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">mul-five-all/v2</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
              <span class="o">'</span><span class="p">(</span><span class="nf">5</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">))</span>

<span class="c1">;; apply-to-all : (Number -&gt; Number)  LON -&gt; LON</span>
<span class="c1">;; apply-to-all : (String -&gt; String)  LOS -&gt; LOS</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">apply-to-all</span> <span class="nv">f</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">apply-to-all</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">)))]))</span>
</code></pre></div></div>

<p>Notice the signature! (The parenthesis note the funciton)</p>

<p><code class="language-plaintext highlighter-rouge">apply-to-all</code> is already built into ISL under the name <code class="language-plaintext highlighter-rouge">map</code></p>

<h3 id="signature">Signature</h3>

<p>What is the signature of <code class="language-plaintext highlighter-rouge">apply-to-all</code>?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; apply-to-all : (Number -&gt; Number)  LON -&gt; LON</span>
<span class="c1">;; apply-to-all : (String -&gt; String)  LOS -&gt; LOS</span>
</code></pre></div></div>

<p>More on this later!</p>

<ul>
  <li>Lambda expression</li>
</ul>

<h1 id="lecture-18---expanded-abstraction">Lecture 18 - Expanded Abstraction</h1>

<h3 id="recap-on-abstraction">Recap on Abstraction</h3>

<ul>
  <li>You can send functions as function inputs</li>
  <li>Helper functions are used to create a similar general funciton</li>
</ul>

<p><strong>Apply-to-all</strong></p>

<ul>
  <li>Performs a funciton on every element in a list</li>
</ul>

<h3 id="signature-for-apply-to-all">Signature for <code class="language-plaintext highlighter-rouge">apply-to-all</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; apply-to-all : (Number -&gt; Number)  LON -&gt; LON</span>
<span class="c1">; apply-to-all : (String -&gt; String) LOS -&gt; LOS</span>
</code></pre></div></div>

<p>But this works with any datatype (not just Number or String). These types of functions are known as ‚Äúgeneral functions‚Äù or ‚Äúpolymorphic functions‚Äù</p>

<h3 id="general-signature">General Signature</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; apply-to-all : {X Y} (X -&gt; Y) [List-of X] -&gt; [List-of Y]</span>
</code></pre></div></div>

<p>NOTE: The <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> are in curly brackets to denote that they are arbitrary variables and not previously defined.</p>

<h3 id="example-1-many-circles">Example 1: <code class="language-plaintext highlighter-rouge">many-circles</code></h3>

<p>Almost always start with the map function</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; many-circles : [List-of Integer] -&gt; [List-of Image]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">many-circles</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map</span> <span class="nv">do-circle</span> <span class="nv">l</span><span class="p">))</span>
</code></pre></div></div>

<p>‚ÄúComputers, they‚Äôre out to get me. Gotta study my enemies‚Äù - Arjun</p>

<h3 id="example-2-give-evens">Example 2: <code class="language-plaintext highlighter-rouge">give-evens</code></h3>

<ul>
  <li>Cannot write this function using <code class="language-plaintext highlighter-rouge">apply-to-all</code> (<code class="language-plaintext highlighter-rouge">map</code>) because the helper function needs to return something (you can‚Äôt ‚Äòskip‚Äô a number)</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; a.k.a. filter</span>
<span class="c1">;; give-kind-of : {X} (X -&gt; Boolean) [List-of X] -&gt; [List-of X]</span>

<span class="c1">;; (give-kind-of f (list x1 x2 ... x_n))</span>
<span class="c1">;; produces</span>
<span class="c1">;; (list ... x_i ... x_j ...) only if (f x_i), (f x_j) is #true</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">give-kind-of</span> <span class="nv">f</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">l</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">l</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">l</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">give-kind-of</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">give-kind-of</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">)))]))</span>

<span class="c1">; give-evens : [List-of Number] -&gt; [List-of Number]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">give-evens</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">give-kind-of</span> <span class="nv">even?</span> <span class="nv">l</span><span class="p">))</span>
</code></pre></div></div>

<p>NOTE: <code class="language-plaintext highlighter-rouge">give-kind-of</code> is the same as <code class="language-plaintext highlighter-rouge">filter</code></p>

<ul>
  <li>It will never call two recursive functions in the same layer.</li>
  <li>Two options for recursion</li>
</ul>

<h3 id="example-3-give-capitalized">Example 3: <code class="language-plaintext highlighter-rouge">give-capitalized</code></h3>

<p>Similar to Example 2. You can‚Äôt use <code class="language-plaintext highlighter-rouge">apply-to-all</code> (<code class="language-plaintext highlighter-rouge">map</code>) to it either.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; capitalized? : String -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">capitalized?</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="p">(</span><span class="nf">string-upcase</span> <span class="nv">s</span><span class="p">)))</span>

<span class="c1">; give-capitalized : [List-of String] -&gt; [List-of String]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">give-capitalized</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">give-kind-of</span> <span class="nv">capitalized?</span> <span class="nv">l</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="abstracting-functions">Abstracting Functions</h2>

<ul>
  <li>Play spot the difference with the two functions</li>
  <li>Make only one difference (use helper functions)</li>
</ul>

<hr />

<h2 id="map-and-filter">Map and Filter</h2>

<p>Map: always produce a list of the same length</p>

<p>Filter: input [List-of X], always returns [List-of X]</p>
<h1 id="lecture-19---scope-and-local">Lecture 19 - Scope and Local</h1>

<h3 id="things-they-want-to-teach">Things they want to teach</h3>

<ul>
  <li>Theorietical foundations of computing
    <ul>
      <li>Design recipe</li>
    </ul>
  </li>
  <li>Mechanics of programming
    <ul>
      <li>Time spend on a keyboard</li>
    </ul>
  </li>
</ul>

<h3 id="abstraction-1">Abstraction</h3>

<p>Recall: We derived the built-in functions <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; apply-to-all : {X Y} (X -&gt; Y) [List-of X] -&gt; [List-of Y]</span>
<span class="c1">;;</span>
<span class="c1">;; Purpose:</span>
<span class="c1">;;</span>
<span class="c1">;; _(apply-to-all f (list x y z ...))_ produces the list</span>
<span class="c1">;; _(list (f x) (f y) (f z) ...)_.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">apply-to-all</span> <span class="nv">f</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">l</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">l</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">apply-to-all</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">)))]</span>
</code></pre></div></div>

<h3 id="check-syntax">Check Syntax</h3>

<ul>
  <li>Gives a graphical representation of where variables and functions come from</li>
  <li>USE IT!</li>
</ul>

<h3 id="local-definitions">Local Definitions:</h3>

<p>Recall that <code class="language-plaintext highlighter-rouge">mul5</code> was the helper function to <code class="language-plaintext highlighter-rouge">mul-five-all</code></p>

<p>This makes it seem like <code class="language-plaintext highlighter-rouge">mul5</code> is an important function outside of <code class="language-plaintext highlighter-rouge">mul-five-all</code> (which it‚Äôs not)</p>

<p><strong>Local :</strong> Can declare a helper function only within another function</p>

<ul>
  <li>Still need a signature</li>
  <li>Don‚Äôt use this for every helper function, only the ones that require it</li>
  <li>The variables (including function inputs) pass from the main function to the helper function (see this in <code class="language-plaintext highlighter-rouge">many-circles</code> example below)</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; mul-five-all : LON -&gt; LON</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">mul-five-all/v2</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">(</span><span class="c1">;; mul5 : Number -&gt; Number</span>
          <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">mul5/v2</span> <span class="nv">n</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="nv">n</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">apply-to-all</span> <span class="nv">mul5/v2</span> <span class="nv">lon</span><span class="p">)</span>
</code></pre></div></div>

<p>These are only necessary when you need to pass more variables into the helper function</p>

<h2 id="examples-of-abstraction">Examples of Abstraction</h2>

<h3 id="many-circles-example"><code class="language-plaintext highlighter-rouge">many-circles</code> example</h3>

<p><strong>How can we pass a color into the helper function as well?</strong></p>

<p>Use a <code class="language-plaintext highlighter-rouge">local</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; many-circles/v2 : Color [List-of Integer] -&gt; [List-of Image]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">many-circles/v2</span> <span class="nv">c</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">((</span><span class="k">define</span> <span class="p">(</span><span class="nf">do-circle/v2</span> <span class="nv">r</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">circle</span> <span class="nv">r</span> <span class="s">"solid"</span> <span class="nv">c</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">apply-to-all</span> <span class="nv">do-circle/v2</span> <span class="nv">l</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="mul-all-by-example"><code class="language-plaintext highlighter-rouge">mul-all-by</code> example</h3>

<p>Multiply every element in a list by a given number</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; mul-all-by : Number LON -&gt; LON</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">mul-all-by</span> <span class="nv">n</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">((</span><span class="k">define</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">m</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">*</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">apply-to-all</span> <span class="nv">multiplier</span> <span class="nv">lon</span><span class="p">)))</span>
</code></pre></div></div>

<h2 id="abstraction-with-2-differences-challenge-problem">Abstraction with 2 Differences (Challenge problem)</h2>

<p>Create an abstraction for <code class="language-plaintext highlighter-rouge">sum-all</code> and <code class="language-plaintext highlighter-rouge">mul-all</code> (that can be used for things that aren‚Äôt just numbers)</p>

<p>There are two differences</p>

<ul>
  <li>Base case</li>
  <li>Function called</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-foldr :: { X Y } (X Y -&gt; Y) Y [List-of X] -&gt; Y</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">f</span> <span class="nv">base</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="nv">base</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">f</span> <span class="nv">base</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">)))]))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">do-all</code> is already built into Racket as <code class="language-plaintext highlighter-rouge">foldr</code></p>

<h3 id="signature-1">Signature</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-foldr :: {X} (X X -&gt; X) X [List-of X] -&gt; X</span>
<span class="c1">; THE MOST GENERAL!</span>
<span class="c1">;; my-foldr :: {X Y} (X Y -&gt; Y) Y [List-of X] -&gt; Y ; don't have to be the same</span>
</code></pre></div></div>

<h3 id="example-total-len">Example: <code class="language-plaintext highlighter-rouge">total-len</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Problem: Write a function to calculuate the total length of a list of strings</span>

<span class="c1">;; total-len-helper : String Number -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">total-len-helper</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">string-length</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span> <span class="p">))</span>

<span class="c1">;; my-foldr :: { X Y } (X Y -&gt; Y) Y [List-of X] -&gt; Y</span>
<span class="c1">;; x = String</span>
<span class="c1">;; y = Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">total-len</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">???</span> <span class="mi">0</span> <span class="nv">los</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">cons</span> <span class="o">'</span><span class="p">()</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">))</span>
<span class="c1">; Returns: (list 10 20 30 40)</span>
</code></pre></div></div>

<p>Callenge problem:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">apply-to-all/v2</span> <span class="nv">f</span> <span class="nv">l</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">my-foldr</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    (require 2htdp/image)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Code adapted from previous lecture

    ;; mul5 : Number -&gt; Number
    (define (mul5 n)
      (* 5 n))

    (check-expect (mul5 10) 50)

    ;; apply-to-all : {X Y} (X -&gt; Y) [List-of X] -&gt; [List-of Y]
    ;;
    ;; Purpose:
    ;;
    ;; _(apply-to-all f (list x y z ...))_ produces the list
    ;; _(list (f x) (f y) (f z) ...)_.
    (define (apply-to-all f l)
      (cond
        [(empty? l) '()]
        [(cons? l) (cons (f (first l))
                           (apply-to-all f (rest l)))]))

    ;; mul-five-all : LON -&gt; LON
    (define (mul-five-all lon)
      (apply-to-all mul5 lon))

    (check-expect (mul-five-all (list 1 2 3))
                  (list 5 10 15))

    ;; do-circle : Integer -&gt; Image
    (define (do-circle r)
      (circle r "solid" "red"))

    (check-expect (do-circle 5) (circle 5 "solid" "red"))

    ;; many-circles : [List-of Integer] -&gt; [List-of Image]
    (define (many-circles l)
      (map do-circle l))

    (check-expect (many-circles (list 10 20))
                  (list (circle 10 "solid" "red")
                        (circle 20 "solid" "red")))

    ;; my-filter : {X} (X -&gt; Boolean) [List-of X] -&gt; [List-of X]
    ;;
    ;; Purpose:
    ;;
    ;; (my-filter f (list x1 x2 ... x_n))
    ;; produces
    ;; (list ... x_i ... x_j ...) only if (f x_i), (f x_j) is #true
    (define (my-filter f l)
      (cond
        [(empty? l) '()]
        [(cons? l)
         (if (f (first l))
             (cons (first l) (my-filter f (rest l)))
             (my-filter f (rest l)))]))

    (define (give-evens l)
      (my-filter even? l))

    (check-expect (give-evens (list 1 2 3 4 5))
                  (list 2 4))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; mul-five-all : LON -&gt; LON
    (define (mul-five-all/v2 lon)
      (local (;; mul5 : Number -&gt; Number
              (define (mul5/v2 n)
                (* 5 n)))
        (apply-to-all mul5/v2 lon)))

    ; Does not work: (mul5/v2 10)

    ;; do-circle : Color Integer -&gt; Image

    #;(define (apply-to-all f l)
      (cond
        [(empty? l) '()]
        [(cons? l) (cons (f (first l))
                           (apply-to-all f (rest l)))]))

    ;; many-circles/v2 : Color [List-of Integer] -&gt; [List-of Image]
    (define (many-circles/v2 c l)
      (local ((define (do-circle/v2 r)
                (circle r "solid" c)))
        (apply-to-all do-circle/v2 l)))

    #|
    Ignore:
    (define (silly x)
      (local ((define (G)
                (+ x x)))
        (+ (G 5) x)))

    (silly 100)
    |#

    ;; mul-all-by : Number LON -&gt; LON
    (define (mul-all-by n lon)
      (local ((define (multiplier m)
                (* m n)))
        (apply-to-all multiplier lon)))

    (mul-all-by 100 (list 10 20 30))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; sum-all :: LON -&gt; Number
    (define (sum-all lon)
      (cond
        [(empty? lon) 0]
        [(cons? lon) (+ (first lon) (sum-all (rest lon)))]))

    ;; mul-all :: LON -&gt; Number
    (define (mul-all lon)
      (cond
        [(empty? lon) 1]
        [(cons? lon) (* (first lon) (mul-all (rest lon)))]))

    ;; my-foldr :: (Number Number -&gt; Number) Number LON -&gt; Number
    ;; my-foldr :: (String String -&gt; String) String LOS -&gt; String
    ;; my-foldr :: {X} (X X -&gt; X) X [List-of X] -&gt; X

    ;; my-foldr :: (X        Y       -&gt;       Y)          Y [List-of X    ] -&gt;           Y

    ;; my-foldr :: { X Y } (X Y -&gt; Y) Y [List-of X] -&gt; Y
    (define (my-foldr f base lon)
      (cond
        [(empty? lon) base]
        [(cons? lon) (f (first lon) (my-foldr f base (rest lon)))]))

    (define (sum-all/v2 lon)
      (my-foldr + 0 lon))

    (define (mul-all/v2 lon)
      (my-foldr * 1 lon))

    (sum-all/v2 (list 10 20 30))
    (mul-all/v2 (list 1 2 3 4 5))
    (my-foldr beside  (rectangle 10 20 "solid" "green")  (many-circles (list 10 20 30)))

    ;; Challenge: Make this work
    ; (my-foldr beside????  (rectangle 10 20 "solid" "green")  (list 10 20 30))

    ;; Problem: Write a function to calculuate the total length of a list of strings

    ;; total-len-helper : String Number -&gt; Number
    (define (total-len-helper x y)
      (+ (string-length x) y ))

    ;; my-foldr :: { X Y } (X Y -&gt; Y) Y [List-of X] -&gt; Y
    ;; x = String
    ;; y = Number
    (define (total-len los)
      (my-foldr ??? 0 los))

    (define (apply-to-all/v2 f l)
      (my-foldr ....))

    (define (filter/v2 f l)
      (my-foldr ....))
</pre>
</details>
<h1 id="lecture-20---built-in-abstraction-functions">Lecture 20 - Built-in Abstraction Functions</h1>

<p>‚ÄúI apologize for swearing. No, not really‚Äù - Arjun</p>

<h2 id="programming-with-list-abstractions">Programming with List Abstractions</h2>

<h3 id="map">Map</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; _(map f (list x y x ...))_ producees _(list (f x) (f y) (f z) ...)_.</span>
</code></pre></div></div>

<p>However, it‚Äôs more complicated. It really does this:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; What map really does</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add10</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="nf">my-map</span> <span class="nv">add10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="o">'</span><span class="p">())))</span>
<span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">my-map</span> <span class="nv">add10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="o">'</span><span class="p">())))</span>
<span class="p">(</span><span class="nb">cons</span> <span class="mi">11</span> <span class="p">(</span><span class="nf">my-map</span> <span class="nv">add10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="o">'</span><span class="p">())))</span>
<span class="p">(</span><span class="nb">cons</span> <span class="mi">11</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">my-map</span> <span class="nv">add10</span> <span class="o">'</span><span class="p">())))</span>
<span class="p">(</span><span class="nb">cons</span> <span class="mi">11</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">12</span> <span class="p">(</span><span class="nf">my-map</span> <span class="nv">add10</span> <span class="o">'</span><span class="p">())))</span>
<span class="p">(</span><span class="nb">cons</span> <span class="mi">11</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">12</span> <span class="o">'</span><span class="p">()))</span>

<span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">2</span><span class="p">)</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>It does not do this:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">add10</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>Although it is close enough for our purposes.</p>

<h3 id="filter">Filter</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; filter : {X} (X -&gt; Boolean) [List-of X] -&gt; [List-of X]</span>
</code></pre></div></div>

<p>See previous lectures for more information.</p>

<h3 id="foldr">Foldr</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; foldr : {X Y} (X Y -&gt; Y) Y [List-of X] -&gt; Y</span>
</code></pre></div></div>

<p><strong>Purpose statement:</strong></p>

<p>With 3 elements (x, y, and z):</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Purpose: _(folder f base (list x y z))_ produces _(f x (f y (f z base)))_</span>
</code></pre></div></div>

<p>With unknown elements:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Purpose: _(folder f base (list x y ... z))_ produces _(f x (f y (f ... (f z base))))_.</span>
</code></pre></div></div>

<p>Example</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">foldr</span> <span class="nv">+</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="o">'</span><span class="p">()))))</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">30</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div></div>

<h2 id="foldr-1">Foldr</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; A [List-of X] is one of:</span>
<span class="c1">; - '()</span>
<span class="c1">; - (cons X [List-of X])</span>
<span class="c1">;</span>
<span class="c1">; Interpretation: A list of items, where every item is an X.</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">f</span> <span class="nv">base</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="nv">base</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">l</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">f</span> <span class="nv">base</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">)))]))</span>
</code></pre></div></div>

<p>Notice how <code class="language-plaintext highlighter-rouge">foldr</code> (my-foldr) is the same as the <code class="language-plaintext highlighter-rouge">list-template</code>.</p>

<ul>
  <li>All functions that use the <code class="language-plaintext highlighter-rouge">list-template</code> can be used with <code class="language-plaintext highlighter-rouge">foldr</code> (although sometimes it makes it worse)</li>
</ul>

<p><strong>Example:</strong></p>

<p><code class="language-plaintext highlighter-rouge">length</code> - Calculates the length of a list</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; my-length : {X} [List-of X] -&gt; Integer</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-length : {X} [List-of X] -&gt; Integer</span>
<span class="c1">;; Calculuates the length of the given list.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-length</span> <span class="nv">l</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">l</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="c1">; this does not matter: (first l)</span>
                  <span class="p">(</span><span class="nf">my-length</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">)))]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-length-helper</span> <span class="nv">list-item</span> <span class="nv">length-of-the-rest</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">length-of-the-rest</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-length/v2</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">foldr</span> <span class="nv">my-length-helper</span> <span class="mi">0</span> <span class="nv">l</span><span class="p">))</span>
</code></pre></div></div>

<p>Creating <code class="language-plaintext highlighter-rouge">length</code> (<code class="language-plaintext highlighter-rouge">my-length</code>) using <code class="language-plaintext highlighter-rouge">foldr</code>.</p>

<ul>
  <li>Don‚Äôt have to use all arguments while making a function. <code class="language-plaintext highlighter-rouge">foldr</code> gives you all items, so if you don‚Äôt need it, don‚Äôt use it.</li>
</ul>

<p><strong>Example</strong></p>

<p>Creating <code class="language-plaintext highlighter-rouge">filter</code> (<code class="language-plaintext highlighter-rouge">my-filter</code>) using <code class="language-plaintext highlighter-rouge">foldr</code>.</p>

<ul>
  <li>There are two recursive calls. So how can we make it look like the template?</li>
</ul>

<p>&lt;SLC - my-filter/v2&gt;</p>

<ul>
  <li>Notice that we used local to define the similarity in the <code class="language-plaintext highlighter-rouge">my-filter</code> function</li>
</ul>

<p>While writting the ‚Äòsame‚Äô function in homeworks, you can check-expect against other versions. <code class="language-plaintext highlighter-rouge">(check-expect (function/v1 x) (function/v2 x))</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-filter : {X} (X -&gt; Boolean) [List-of X] -&gt; [List-of X]</span>
<span class="c1">;;</span>
<span class="c1">;; Purpose: _(my-filter f l)_ produces all elements _x_ of _l_ on which</span>
<span class="c1">;; _(f x)_ is _#true_.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-filter/v2</span> <span class="nv">f</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">l</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">l</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">local</span> <span class="p">([</span><span class="k">define</span> <span class="nv">the-first</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">l</span><span class="p">)]</span>
             <span class="p">[</span><span class="k">define</span> <span class="nv">rest-filtered</span> <span class="p">(</span><span class="nf">my-filter/v2</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">))])</span>
       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">the-first</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">cons</span> <span class="nv">the-first</span> <span class="nv">rest-filtered</span><span class="p">)</span>
           <span class="nv">rest-filtered</span><span class="p">))]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-filter/v3</span> <span class="nv">f</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">((</span><span class="k">define</span> <span class="p">(</span><span class="nf">filter-helper</span> <span class="nv">the-first</span> <span class="nv">rest-filtered</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">the-first</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">cons</span> <span class="nv">the-first</span> <span class="nv">rest-filtered</span><span class="p">)</span>
                <span class="nv">rest-filtered</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">filter-helper</span> <span class="o">'</span><span class="p">()</span> <span class="nv">l</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">my-filter/v2</span> <span class="nv">even?</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">my-filter/v3</span> <span class="nv">even?</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">my-filter/v2</span> <span class="nv">even?</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
</code></pre></div></div>

<p>To make the extra argument available to the helper function, you have to make the helper function local.</p>

<h3 id="build-list">Build-list</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Purpose:</span>
<span class="c1">; _(build-list f n)_ produces</span>
<span class="c1">; _(list (f 0) (f 1) ... (f (- n 1)))_</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">identity</code> - Produces it‚Äôs argument</p>

<p>Build-list produces a list that sends whose elements are the function prodived with the argument 0 through n.</p>

<h3 id="countdown">Countdown</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; countdown : Integer -&gt; String</span>

<span class="p">[</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-space</span> <span class="nv">s</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">string-append</span> <span class="nv">s</span> <span class="s">" "</span><span class="p">)]</span>
<span class="c1">;; countdown : Integer -&gt; [List-of Integer]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">countdown</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">([</span><span class="k">define</span> <span class="p">(</span><span class="nf">build-list-helper</span> <span class="nv">i</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">i</span><span class="p">)]</span>
          <span class="p">)</span>
    <span class="p">(</span><span class="nf">foldr</span> <span class="nv">string-append</span>
           <span class="s">"blastoff!"</span>
           <span class="p">(</span><span class="nb">map</span> <span class="nv">add-space</span>
                <span class="p">(</span><span class="nb">map</span> <span class="nv">number-&gt;string</span>
                     <span class="p">(</span><span class="nf">build-list</span> <span class="nv">n</span> <span class="nv">build-list-helper</span><span class="p">))))))</span>

<span class="c1">;(check-expect (countdown 5) "5 4 3 2 1 blastoff!")</span>

<span class="p">(</span><span class="nf">countdown</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>If a function doesn‚Äôt have to be local, it‚Äôs easier to read if it‚Äôs global</li>
</ul>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    (require 2htdp/image)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Code adapted from last week

    ;; my-map : {X Y} (X -&gt; Y) [List-of X] -&gt; [List-of Y]
    ;;
    ;; NOTE: Called this apply-to-all previously
    ;;
    ;; Purpose:
    ;;
    ;; _(my-map f (list x y z ...))_ produces _(list (f x) (f y) (f z) ...)_.
    (define (my-map f l)
      (cond
        [(empty? l) '()]
        [(cons? l) (cons (f (first l))
                           (my-map f (rest l)))]))

    ; What map really does
    (define (add10 x) (+ x 10))
    (my-map add10 (cons 1 (cons 2 '())))
    (cons (add10 1) (my-map add10 (cons 2 '())))
    (cons 11 (my-map add10 (cons 2 '())))
    (cons 11 (cons (add10 2) (my-map add10 '())))
    (cons 11 (cons 12 (my-map add10 '())))
    (cons 11 (cons 12 '()))

    (cons (add10 1) (cons (add10 2) '()))
    (list (add10 1) (add10 2))

    ;; my-filter : {X} (X -&gt; Boolean) [List-of X] -&gt; [List-of X]
    ;;
    ;; Purpose: _(my-filter f l)_ produces all elements _x_ of _l_ on which
    ;; _(f x)_ is _#true_.
    (define (my-filter f l)
      (cond
        [(empty? l) '()]
        [(cons? l)
         (if (f (first l))
             (cons (first l) (my-filter f (rest l)))
             (my-filter f (rest l)))]))

    ;; sum-all :: [List-of Number] -&gt; Number
    (define (sum-all lon)
      (cond
        [(empty? lon) 0]
        [(cons? lon) (+ (first lon) (sum-all (rest lon)))]))

    ;; mul-all :: [List-of Number] -&gt; Number
    (define (mul-all lon)
      (cond
        [(empty? lon) 1]
        [(cons? lon) (* (first lon) (mul-all (rest lon)))]))

    ;; my-foldr :: {X} (X X -&gt; X) X [List-of X] -&gt; X
    ;;
    ;; The most general signature:
    ;;
    ;; my-foldr :: { X Y } (X Y -&gt; Y) Y [List-of X] -&gt; Y
    ;;
    ;; Purpose: _(my-foldr f base (list x y z))_ a.k.a
    ;;          _(my-foldr f base (cons x (cons y (cons z '()))))_ produces:
    ;;          _(f x (f y (f z base)))_
    ;; Purpose: _(my-foldr f base (list x y z w))_ produces
    ;;          _(f x (f y (f z (f w base)))_

    ;; Purpose: _(my-foldr f base (list x y ... z))_ produces
    ;;          _(f x (f y (f z (f ... (f z base))))_

    (foldr cons '() (list 10 20 30))
    (foldr cons '() (cons 10 (cons 20 (cons 30 '()))))
    (cons 10 (cons 20 (cons 30 '())))

    (foldr + 0 (cons 10 (cons 20 (cons 30 '()))))
    (+ 10 (+ 20 (+ 30 0)))

    (foldr - 0 (cons 10 (cons 20 (cons 30 '()))))
    (- 10 (- 20 (- 30 0)))
    (- 30 20 10)

    (define (my-foldr f base lon)
      (cond
        [(empty? lon) base]
        [(cons? lon) (f (first lon) (my-foldr f base (rest lon)))]))

    (define (mul-all/v2 lon)
      (foldr * 1 lon))

    (define (sum-all/v2 lon)
      (foldr + 0 lon))

    ;; total-length-helper : String Number -&gt; Number
    (define (total-length-helper s n)
      (+ (string-length s) n))

    ;; total-length :: [List-of String] -&gt; Number
    (define (total-length los)
      (foldr total-length-helper 0 los))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Code from lecture

    ; A [List-of X] is one of:
    ; - '()
    ; - (cons X [List-of X])
    ;
    ; Interpretation: A list of items, where every item is an X.

    #;(define (my-foldr f base l)
      (cond
        [(empty? lon) base]
        [(cons? lon) (f (first l)
                        (my-foldr f base (rest l)))]))

    ;; my-length : {X} [List-of X] -&gt; Integer
    ;; Calculuates the length of the given list.
    (define (my-length l)
        (cond
        [(empty? l) 0]
        [(cons? l) (+ 1 ; this does not matter: (first l)
                      (my-length (rest l)))]))

    (define (my-length-helper list-item length-of-the-rest)
      (+ 1 length-of-the-rest))

    (define (my-length/v2 l)
      (foldr my-length-helper 0 l))

    ; list-template : [List-of X] -&gt; ?
    (define (list-template l)
      (cond
        [(empty? l) ...]
        [(cons? l) (... (first l)
                        (list-template (rest l)))]))

    ;; my-filter : {X} (X -&gt; Boolean) [List-of X] -&gt; [List-of X]
    ;;
    ;; Purpose: _(my-filter f l)_ produces all elements _x_ of _l_ on which
    ;; _(f x)_ is _#true_.
    (define (my-filter/v2 f l)
      (cond
        [(empty? l) '()]
        [(cons? l)
         (local ([define the-first (first l)]
                 [define rest-filtered (my-filter/v2 f (rest l))])
           (if (f the-first)
               (cons the-first rest-filtered)
               rest-filtered))]))

    (define (my-filter/v3 f l)
      (local ((define (filter-helper the-first rest-filtered)
                (if (f the-first)
                    (cons the-first rest-filtered)
                    rest-filtered)))
        (my-foldr filter-helper '() l)))

    (check-expect (my-filter/v2 even? (list 1 2 3 4)) (list 2 4))

    (check-expect (my-filter/v3 even? (list 1 2 3 4))
                  (my-filter/v2 even? (list 1 2 3 4)))


    ;; Purpose:
    ;; _(build-list n f)_ produces
    ;; _(list (f 0) (f 1) ... (f (- n 1)))_
    ;; build-list : {X} NonNegativeInteger (Integer -&gt; X)  -&gt; [List-of X]

    ;; countdown : Integer -&gt; String

    [define (add-space s)
                (string-append s " ")]
    ;; countdown : Integer -&gt; [List-of Integer]
    (define (countdown n)
      (local ([define (build-list-helper i)
                (- n i)]
              )
        (foldr string-append
               "blastoff!"
               (map add-space
                    (map number-&gt;string
                         (build-list n build-list-helper))))))

    ;(check-expect (countdown 5) "5 4 3 2 1 blastoff!")

    (countdown 5)
</pre>
</details>
<h1 id="lecture-21---introduction-to-lambda">Lecture 21 - Introduction to Lambda</h1>

<p>‚ÄúI‚Äôve only fallen asleep while talking once‚Äù - Arjun</p>

<p>Things you can do with functions</p>

<ol>
  <li>Calling the function directly</li>
  <li>Using it as an argument for another function</li>
  <li>Put functions inside other functions using <code class="language-plaintext highlighter-rouge">local</code></li>
  <li><strong>Write functions that return functions</strong>
    <ul>
      <li>Introduced this lecture</li>
    </ul>
  </li>
</ol>

<h3 id="function-as-argument">Function as argument</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add-ten : Number -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-ten</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="mi">10</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span> <span class="nv">add-ten</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">))</span>
</code></pre></div></div>

<p>Passing <code class="language-plaintext highlighter-rouge">add-ten</code> as a parameter</p>

<h3 id="local-function">Local Function</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add-all-by : Number [List-of Number] -&gt; [List-of Number]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-all-by</span> <span class="nv">n</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">(</span><span class="c1">; helper : Number -&gt; Number</span>
          <span class="p">[</span><span class="k">define</span> <span class="p">(</span><span class="nf">helper</span> <span class="nv">m</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="nv">m</span><span class="p">)])</span>
    <span class="p">(</span><span class="nb">map</span> <span class="nv">helper</span> <span class="nv">l</span><span class="p">)))</span>
</code></pre></div></div>

<ul>
  <li>Uses local function</li>
</ul>

<hr />

<h2 id="functions-that-produce-other-functions">Functions that Produce other Functions</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; silly : Any -&gt; (Number -&gt; Number)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">silly</span> <span class="nv">n</span><span class="p">)</span>
  <span class="nv">add-ten</span><span class="p">)</span>

<span class="c1">;; example-number : Number</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">example-number</span> <span class="mi">3487657845</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">silly</span> <span class="s">"dfkjgidsfug"</span><span class="p">))</span>
<span class="c1">;; why : VOID -&gt;  Function</span>
<span class="c1">;; why : (Number -&gt; Number)</span>
<span class="c1">;; why : Number -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">why</span> <span class="nv">add-ten</span><span class="p">)</span>
</code></pre></div></div>

<p>We can also functionally re-name functions</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; why : Number -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">why</span> <span class="nv">add-ten</span><span class="p">)</span>
</code></pre></div></div>

<p>‚ÄúNow that I‚Äôve told you how to do that, don‚Äôt do that‚Äù - Arjun</p>

<h3 id="example-make-adder">Example <code class="language-plaintext highlighter-rouge">make-adder</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; make-adder : Number -&gt; (Number -&gt; Number)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-adder</span> <span class="nv">m</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">local</span> <span class="p">[</span><span class="c1">; add : Number -&gt; Number</span>
					<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add</span> <span class="nv">n</span><span class="p">)</span>
						<span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="nv">m</span><span class="p">))]</span>
		<span class="nv">add</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add-hundred : Number -&gt; Number</span>
<span class="c1">;; add-hundred is add with (= m 100)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">add-hundred</span> <span class="p">(</span><span class="nf">make-adder</span> <span class="mi">100</span><span class="p">))</span>

<span class="c1">;; add-five is add with (= m 5)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">add-five</span> <span class="p">(</span><span class="nf">make-adder</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">make-adder</span> <span class="mi">7</span><span class="p">)</span> <span class="c1">; Produces a function: (lambda (al) ...)</span>
<span class="c1">; We can also do:</span>
<span class="p">((</span><span class="nf">make-adder</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; Produces: 15</span>
</code></pre></div></div>

<h3 id="example-guessing-game">Example <code class="language-plaintext highlighter-rouge">guessing-game</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; guessing-game : Number -&gt; (Number -&gt; String)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">guessing-game</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">(</span><span class="c1">; guess : Number -&gt; String</span>
          <span class="p">[</span><span class="k">define</span> <span class="p">(</span><span class="nf">guess</span> <span class="nv">m</span><span class="p">)</span>
            <span class="p">(</span><span class="k">cond</span>
              <span class="p">[(</span><span class="nb">=</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)</span> <span class="s">"Correct!"</span><span class="p">]</span>
              <span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)</span> <span class="s">"Go higher!"</span><span class="p">]</span>
              <span class="p">[(</span><span class="nb">&gt;</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)</span> <span class="s">"Go lower!"</span><span class="p">])])</span>
    <span class="nv">guess</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">game</span> <span class="p">(</span><span class="nf">guessing-game</span> <span class="p">(</span><span class="nf">random</span> <span class="mi">1000000</span><span class="p">)))</span>
</code></pre></div></div>

<p>The actual number is hidden from us; the only way to figure it out is to go through the entire guessing game</p>

<p>Recall:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add-ten : Number -&gt; Number</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-ten</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="mi">10</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="lambda">Lambda</h2>

<p>We don‚Äôt <em>have</em> to give names to functions:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">; A nameless function</span>
</code></pre></div></div>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="mi">10</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span> <span class="mi">60</span><span class="p">))</span>
<span class="c1">; Returns: (list 20 30 40 50 60 70)</span>
</code></pre></div></div>

<ul>
  <li>For internal help functions, this is very useful</li>
</ul>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">s</span> <span class="s">"hi"</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"hi"</span> <span class="s">"bye"</span> <span class="s">"hi"</span><span class="p">))</span>
<span class="c1">; Returns: (list "hi" "hi")</span>
</code></pre></div></div>

<ul>
  <li>No need for check-expects, purpose statement, and signature for the lambda function</li>
</ul>

<p>‚Äúshit‚Äù - Arjun</p>

<p><code class="language-plaintext highlighter-rouge">make-adder</code> using lambda:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; make-adder : Number -&gt; (Number -&gt; Number)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-adder</span> <span class="nv">m</span><span class="p">)</span>
	<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;; my-map : {X Y} (X -&gt; Y) [List-of X] -&gt; [List-of Y]
    (define (my-map f l)
      (cond
        [(empty? l) '()]
        [(cons? l) (cons (f (first l)) (my-map f (rest l)))]))

    ;; add-all-by : Number [List-of Number] -&gt; [List-of Number]
    (define (add-all-by n l)
      (local (; helper : Number -&gt; Number
              [define (helper m)
                (+ n m)])
        (map helper l)))

    ;; silly : Any -&gt; (Number -&gt; Number)
    #;(define (silly n)
      add-ten)

    ;; example-number : Number
    (define example-number 3487657845)

    #;(define f (silly "dfkjgidsfug"))
    ;; why : VOID -&gt;  Function
    ;; why : (Number -&gt; Number)
    ;; why : Number -&gt; Number
    ;(define why add-ten)

    ;; make-adder : Number -&gt; (Number -&gt; Number)
    (define (make-adder m)
      (local (;; add : Number -&gt; Number
              [define (add n)
                (+ m n)])
        add    ))

    ;; add-hundred : Number -&gt; Number
    ;; add-hundred is add with (= m 100)
    (define add-hundred (make-adder 100))

    ;; add-five is add with (= m 5)
    (define add-five (make-adder 5))

    ; guessing-game : Number -&gt; (Number -&gt; String)
    (define (guessing-game n)
      (local (; guess : Number -&gt; String
              [define (guess m)
                (cond
                  [(= m n) "Correct!"]
                  [(&lt; m n) "Go higher!"]
                  [(&gt; m n) "Go lower!"])])
        guess))

    ;; add-ten : Number -&gt; Number
    (define (add-ten n)
      (+ n 10))

    (define add-ten/v2 (lambda (n) (+ n 10)))

    ; (filter (lambda (s) (string=? s "hi")) (list "hi" "bye" "hi"))

    ;; make-adder : Number -&gt; (Number -&gt; Number)
    (define (make-adder m)
      (lambda (n) (+ m n)))

    ;; add-hundred : Number -&gt; Number
    ;; add-hundred is add with (= m 100)
    (define add-hundred (make-adder 100))

    ; (make-adder 100)
    ; ====&gt;
    ; (lambda (n) (+ 100 n))

    ; (define add-hundred (lambda (n) (+ 100 n)))
    (define (add-hundred n) (+ 100 n))
</pre>
</details>
<h1 id="lecture-22---local-and-lambda">Lecture 22 - Local and Lambda</h1>

<h2 id="non-empty-list">Non-Empty List</h2>

<p>It‚Äôs often helpful to require for lists to be non-empty</p>

<p>Examples for when the empty list is meaningless:</p>

<ul>
  <li>Minimum or Maximum of a list</li>
</ul>

<h3 id="data-definition"><strong>Data Definition:</strong></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; An [NE-List X] is one of:</span>
<span class="c1">;; - (cons X '())</span>
<span class="c1">;; - (cons X [NE-List X])</span>
<span class="c1">;; Interpretation: A non-empty list of X.</span>
</code></pre></div></div>

<h3 id="template-4"><strong>Template:</strong></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ne-list-template</span> <span class="nv">nel</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">))</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">not</span> <span class="p">(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">)))</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)</span> <span class="o">...</span>
                                    <span class="p">(</span><span class="nf">ne-list-template</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">))</span><span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<h3 id="example-largest">Example: <code class="language-plaintext highlighter-rouge">largest</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; largest : [NE-List Number] -&gt; Number</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">largest</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">5</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">largest</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">5</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">largest</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">7</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">5</span><span class="p">))</span> <span class="mi">7</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">largest</span> <span class="nv">nel</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">))</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">not</span> <span class="p">(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">)))</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)</span> <span class="p">(</span><span class="nf">largest</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">largest</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">)))]))</span>

<span class="c1">;; Challenge: rewrite the function above using folder and max</span>
</code></pre></div></div>

<p>How long does this function take to run?</p>

<h3 id="time-function">Time Function</h3>

<p><code class="language-plaintext highlighter-rouge">time</code> - Returns the amount of time it takes for Racket to compute code</p>

<p><strong>Example:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">time</span> <span class="p">(</span><span class="nf">largest</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">50000000</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span> <span class="c1">; return essentially 0 (it's so quick)</span>
</code></pre></div></div>

<p>For the scope of this course, every number takes the same amount of time to compare</p>

<p><strong>For every element, the time doubles for the <code class="language-plaintext highlighter-rouge">largest</code> function. So the time would be too much for lists of reasonable length</strong>.</p>

<p>We call <code class="language-plaintext highlighter-rouge">largest</code> twice (one for the if statement and one that‚Äôs returned from the function). To not call it twice, use a local definition.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">largest/v2</span> <span class="nv">nel</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">))</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">not</span> <span class="p">(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">local</span> <span class="p">([</span><span class="k">define</span> <span class="nv">largest-in-rest</span> <span class="p">(</span><span class="nf">largest/v2</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">nel</span><span class="p">))])</span>
       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)</span> <span class="nv">largest-in-rest</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">first</span> <span class="nv">nel</span><span class="p">)</span>
         <span class="nv">largest-in-rest</span><span class="p">))]))</span>
</code></pre></div></div>

<p>we usually don‚Äôt monitor the time it takes to compute something in terms of time (because every computer is different). We, instead, usually figure out how many comparisons it takes.</p>

<h3 id="usage-of-local">Usage of Local:</h3>

<ul>
  <li>Make functions easier to read</li>
  <li>Make programs run faster</li>
</ul>

<h2 id="lambda-1">Lambda</h2>

<p>Short-hand for <code class="language-plaintext highlighter-rouge">lambda</code> is just <code class="language-plaintext highlighter-rouge">Œª</code>.</p>

<ul>
  <li>This can be produced with CTRL+\ (CMD on macOS).</li>
</ul>

<p><strong>Recall:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">; Produces (list 11 12 13 14)</span>

<span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">name</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Hi "</span> <span class="nv">name</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Arjun"</span> <span class="s">"Amal"</span><span class="p">))</span>
<span class="c1">; Produces (list "Hi Arjun" "Hi Amal")</span>
<span class="c1">; NOTE: Because it's a trival example, we can replace _name_ with just _x_.</span>
</code></pre></div></div>

<p><strong>Example:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Problem: design a function that consumes a list of strings and produces</span>
<span class="c1">;; those strings of length two in the list</span>

<span class="c1">;; only-two-strings : [List-of String] -&gt; [List-of String]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">only-two-strings</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">string-length</span> <span class="nv">s</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span> <span class="nv">los</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>Example:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Problem: Design a funciton that consumes a list of strings and determines if</span>
<span class="c1">;; they are all strings of length two.</span>

<span class="c1">;; all-two-strings? : [List-of String] -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">all-two-strings?</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">andmap</span> <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">string-length</span> <span class="nv">s</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span> <span class="nv">los</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>Example:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Design a function that consumes a list of numbers and only produces those</span>
<span class="c1">;; numbers that are within a given range.</span>

<span class="c1">; nums-in-range : Number Number [List-of Number] -&gt; [List-of Number]</span>
<span class="c1">; Purpose: _(nums-in-range lo hi lon)_ produces those numbers in _lon_ that are</span>
<span class="c1">; greater than or equal to _lo_ and less than or equal to _hi_.</span>
<span class="c1">; [lo, hi].</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">nums-in-range</span> <span class="nv">lo</span> <span class="nv">hi</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">lo</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">n</span> <span class="nv">hi</span><span class="p">)))</span> <span class="nv">lon</span><span class="p">))</span>
</code></pre></div></div>

<p>NOTE: You cannot define a helper (non-local) function for this. The lambda calls <code class="language-plaintext highlighter-rouge">lo</code> and <code class="language-plaintext highlighter-rouge">hi</code> which wouldn‚Äôt be available outside the <code class="language-plaintext highlighter-rouge">nums-in-range</code> function.</p>

<p>You can also make the ‚Äòhelper‚Äô local instead of lambda (exactly the same as if it were lambda).</p>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;; For later
    ;; mystery : [NE-List Number] -&gt; Number
    (define (mystery lon)
      (/ (foldr + 0 lon) (foldr (lambda (x n) (+ 1 n)) 0 lon)))

    ;; A [List-of X] is one of:
    ;; - '()
    ;; - (cons X [List-of X])

    ;; An [NE-List X] is one of:
    ;; - (cons X '())
    ;; - (cons X [NE-List X])
    ;; Interpretation: A non-empty list of X.

    ;; ex-ne-list-1 : [NE-List Number]
    (define ex-ne-list-1 (list 900))
    ;; ex-ne-list-2 : [NE-List Number]
    (define ex-ne-list-2 (list 10 5 11 8))
    ;; ex-ne-list-3 : [NE-List String]
    (define ex-ne-list-3 (list "Fundies" "2500"))

    ;; TODO(arjun): The template below is not complete.
    (define (ne-list-template nel)
      (cond
        [(empty? (rest nel)) (... (first nel) ...)]
        [(not (empty? (rest nel))) (... (first nel) ...
                                        (ne-list-template (rest nel)) ...)]))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; largest : [NE-List Number] -&gt; Number
    (define (largest nel)
      (cond
        [(empty? (rest nel)) (first nel)]
        [(not (empty? (rest nel)))
         (if (&gt; (first nel) (largest (rest nel)))
             (first nel)
             (largest (rest nel)))]))

    ;; Challenge: rewrite the function above using foldr and max

    (check-expect (largest (list 5 0 0 0 0 4)) 5)
    (check-expect (largest (list 4 0 0 0 0 5)) 5)
    (check-expect (largest (list 4 3 0 5 0 2)) 5)

    (define (largest/v2 nel)
      (cond
        [(empty? (rest nel)) (first nel)]
        [(not (empty? (rest nel)))
         (local ([define largest-in-rest (largest/v2 (rest nel))])
         (if (&gt; (first nel) largest-in-rest)
             (first nel)
             largest-in-rest))]))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; Problem: design a function that consumes a list of strings and produces
    ;; those strings of length two in the list.

    ;; only-two-strings : [List-of String] -&gt; [List-of String]
    (define (only-two-strings los)
      (filter (Œª (s) (= (string-length s) 2)) los))

    (only-two-strings (list "ab" "abc" "d" "de" "def" ""))

    ;; Problem: Design a function that consumes a list of strings and determines if
    ;; they are all strings of length two.

    ;; all-two-strings? : [List-of String] -&gt; Boolean
    (define (all-two-strings? los)
      (andmap (Œª (s) (= (string-length s) 2)) los))

    (check-expect (all-two-strings? (list "ab" "cd")) #true)
    (check-expect (all-two-strings? (list "ab" "" "cd")) #false)

    ;; Design a function that consumes a list of numbers and only produces those
    ;; numbers that are within a given range.

    ;; nums-in-range : Number Number [List-of Number] -&gt; [List-of Number]
    ;; Purpose: _(nums-in-range lo hi lon)_ produces those numbers in _lon_ that are
    ;; greater than or equal to _lo_ and less than or equal to _hi_.
    ;; [lo, hi].
    (define (nums-in-range lo hi lon)
      (filter (Œª (n) (and (&lt;= lo n) (&lt;= n hi))) lon))

    (check-expect (nums-in-range 4 6 (list 4 3 5 10 4 5 6 1))
                  (list 4 5 4 5 6))

    ;(define lo 0)
    ;(define hi 10)

    (define (num-in-range lo hi n)
      (and (&lt;= lo n) (&lt;= n hi)))

    (define (nums-in-range/v2 lo hi lon)
      (filter (num-in-range lo hi) lon))


    ;(nums-in-range/v2 0 10 (list -10 0 5 10 20))

    (define (nums-in-range/v3 lo hi lon)
      (local ([define (helper n)
                (and (&lt;= lo n) (&lt;= n hi))])
        (filter helper lon)))

    (define (num-in-range/v4 lo hi)
      (lambda (n)
        (and (&lt;= lo n) (&lt;= n hi))))

    (define (nums-in-range/v4 lo hi lon)
      (filter (num-in-range/v4 lo hi) lon))

    (nums-in-range/v4 0 10 (list -10 0 5 10 20))
</pre>
</details>
<h1 id="lecture-23---continuation-on-lambda">Lecture 23 - Continuation on Lambda</h1>

<p>No lab quiz tomorrow!</p>

<h3 id="continuation-on-lambda">Continuation on Lambda</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">countdown</span> <span class="mi">5</span><span class="p">)</span> <span class="s">"5 4 3 2 1 Blastoff!"</span><span class="p">)</span>

<span class="c1">;; countdown : Number -&gt; String</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">countdown</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">foldr</span>
   <span class="nv">string-append</span>
   <span class="s">"Blastoff!"</span>
   <span class="p">(</span><span class="nf">build-list</span> <span class="nv">n</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span> <span class="p">(</span><span class="nb">number-&gt;string</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">i</span><span class="p">))</span> <span class="s">" "</span><span class="p">)))))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">build-list</code> : Takes a number and a function to create a list with the elements from 0 to n with the function applied to them:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">build-list</span> <span class="mi">5</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="nv">n</span><span class="p">))</span>
<span class="c1">; Produces (list 0 1 2 3 4 5)</span>
</code></pre></div></div>

<p><strong>What should you put in a lambda?</strong></p>

<ul>
  <li>One line functions should be</li>
  <li>4-5 lines should be the limit of the lambda</li>
</ul>

<h3 id="how-functions-work"><strong>How Functions Work:</strong></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1">; Does not throw an error (you need to call it to get the error)</span>
</code></pre></div></div>

<ul>
  <li>Does not run body until function is called</li>
  <li>The body of the function suspends computation</li>
</ul>

<p>‚ÄúLambdas fuck with your mental model of how things work‚Äù - Arjun</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">func-a</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">10</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">func-a</span> <span class="mi">2</span> <span class="mi">300</span><span class="p">)</span>
<span class="c1">; ===&gt;</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">10</span> <span class="mi">300</span><span class="p">))</span>
<span class="c1">; ===&gt;</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3000</span><span class="p">)</span>
<span class="c1">; ===&gt;</span>
<span class="mi">3002</span>
</code></pre></div></div>

<p>‚ÄúI would hit the step button but everytime I do that, I feel this rage inside me‚Äù - Arjun</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-map</span> <span class="nv">f</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">l</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">l</span><span class="p">))</span> <span class="p">(</span><span class="nf">my-map</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">)))]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add10</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="mi">10</span><span class="p">))</span>
<span class="c1">;(my-map add10 (list 1 2 3))</span>
<span class="c1">; ===&gt;</span>
<span class="c1">;(cons (add10 (first (list 1 2 3))) (my-map add10 (rest (list 1 2 3))))</span>
<span class="c1">; ===&gt;</span>
<span class="c1">;(cons (add10 1) (my-map add10 (list 2 3)))</span>
<span class="c1">; === ..... ===&gt;</span>
<span class="c1">;(cons (add10 1) (cons (add10 2) (cons (add10 3) (my-map add10 '()))))</span>
</code></pre></div></div>

<ul>
  <li>When you use <code class="language-plaintext highlighter-rouge">map</code>, abstractly it turns into the list template (behind the scenes)</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; make-add-all : Number -&gt; ([List-of Number] -&gt; [List-of Number])</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-add-all</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">l</span><span class="p">)</span>
		<span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="nv">n</span><span class="p">))</span> <span class="nv">l</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">add10-all/v2</span> <span class="p">(</span><span class="nf">make-add-all</span> <span class="mi">10</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="sets">Sets</h3>

<p>The set of even numbers between even numers between 1 and 10</p>

<p>{2, 4, 6, 8, 10}</p>

<p>{4, 2, 8, 10, 6} (these 2 sets are the same)</p>

<p>Union: {1, 3, 5} U {2, 4, 6} = {1, 2, 3, 4, 5, 6}</p>

<p>Intersection: {1, 3, 5} $\cap$ {3, 5, 7} = {3, 5}</p>

<p><strong>How can we build sets in Racket?</strong></p>

<ul>
  <li>We only know how to make lists
    <ul>
      <li>However, in lists, order does matter</li>
    </ul>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">ex-set-1</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-set-2</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">; Invalid example: (define ex-set-3 (list 1 1 3 3 5 5))</span>
</code></pre></div></div>

<p>These are all the same set, but they are different lists</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">ex-set-4</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Arjun"</span> <span class="s">"Amal"</span> <span class="s">"Ben"</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A [Set X] is a [List-of X]</span>
<span class="c1">;; order is irrelevant; no duplicates allowed</span>
<span class="c1">;; union : {X} [Set X] [Set X] -&gt; [Set X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">union</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">foldr</span> <span class="nv">add</span> <span class="nv">set2</span> <span class="nv">set1</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">union</span> <span class="nv">ex-set-1</span> <span class="nv">ex-set-3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1">;(check-expect (union</span>
<span class="c1">;; intersect : {X} [Set X] [Set X] -&gt; [Set X]</span>

<span class="c1">;; add : {X} X [Set X] -&gt; [Set X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">contains?</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)</span>
      <span class="nv">set</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add</span> <span class="mi">10</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add</span> <span class="mi">3</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="nv">ex-set-1</span><span class="p">)</span>

<span class="c1">;; contains? : {X} X [Set X] -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">contains?</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">ormap</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">elem-in-set</span><span class="p">)</span> <span class="p">(</span><span class="nb">equal?</span> <span class="nv">elem-in-set</span> <span class="nv">elem</span><span class="p">))</span> <span class="nv">set</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">contains?</span> <span class="mi">5</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">contains?</span> <span class="mi">5</span> <span class="nv">ex-set-2</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">contains?</span> <span class="mi">50</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span>

</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">equals?</code> is bad practice</p>

<ul>
  <li>If we union { {1, 3, 5}, {2, 4, 6} } and { {5, 3, 1} }, it repeats the element {1, 3, 5}</li>
  <li>This is because <code class="language-plaintext highlighter-rouge">equals?</code> says that {1, 3, 5} and {5, 3, 1} are not the same set (because we are representing the sets as lists where order does matter)</li>
</ul>

<p>Intersect not completed in this lecture.</p>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    #|
    (check-expect (countdown 5) "5 4 3 2 1 Blastoff!")

    ;; countdown : Number -&gt; String
    (define (countdown n)
      (foldr
       string-append
       "Blastoff!"
       (build-list n (lambda (i) (string-append (number-&gt;string (- n i)) " ")))))
    |#
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    #|
    (define (my-function x)
      (/ 1 0))
    |#

    ;(lambda (x) (/ x 0))

    ;((lambda (y) (/ 1 0)) 100)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define (func-a x y)
      (+ x (* 10 y)))

    ;(func-a 2 300)
    ; ===&gt;
    ;'(+ 2 (* 10 300))
    ; ===&gt;
    ;(+ 2 3000)
    ; ===&gt;
    ;3002

    (define (my-map f l)
      (cond
        [(empty? l) '()]
        [(cons? l) (cons (f (first l)) (my-map f (rest l)))]))

    (define (add10 n) (+ n 10))
    ;(my-map add10 (list 1 2 3))
    ; ===&gt;
    ;(cons (add10 (first (list 1 2 3))) (my-map add10 (rest (list 1 2 3))))
    ; ===&gt;
    ;(cons (add10 1) (my-map add10 (list 2 3)))
    ; === ..... ===&gt;
    ;(cons (add10 1) (cons (add10 2) (cons (add10 3) (my-map add10 '()))))

    ;;;;;;;;;;;;;;;;;;

    ;(my-map add10 l)
    ; ====&gt;
    #;(cond
        [(empty? l) '()]
        [(cons? l) (cons (add10 (first l)) (my-map add10 (rest l)))])

    ;; add10-all : [List-of Number] -&gt; [List-of Number]
    (define (add10-all l)
      (cond
        [(empty? l) '()]
        [(cons? l) (cons (add10 (first l)) (add10-all (rest l)))]))

    ;;;;;;;;

    ;; make-add-all : Number -&gt; ([List-of Number] -&gt; [List-of Number])
    (define (make-add-all n)
      (lambda (l)
        (map (lambda (i) (+ i n)) l)))

    (define add10-all/v2 (make-add-all 10))

    ; (define add10-all/v2 (make-add-all 10))
    ; ===&gt;
    ; (define add10-all/v2 (lambda (l)
    ;                        (map (lambda (i) (+ i 10)) l)))
    ; ===&gt;
    ; (define (add10-all/v2 l)
    ;  (map (lambda (i) (+ i 10)) l))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;

    ; { 2, 4, 6, 8, 10 }
    ; { 4, 2, 8, 10, 6 }
    ; { 4, 2, 2, 2, 2, 8, 10, 6 }

    ; { 1, 3, 5 } U { 2, 4, 6 } = { 1, 2, 3, 4, 5, 6}

    ; { 1, 3, 5 } INTERSECT { 3, 5, 7 } = { 3, 5 }

    ; {}

    (define ex-set-1 (list 1 3 5))
    (define ex-set-2 (list 5 3 1))
    (define ex-set-3 (list 2 4 6))
    ; Invalid example: (define ex-set-3 (list 1 1 3 3 3 5))
    (define ex-set-4 (list "Arjun" "Amal" "Ben"))

    ;; A [Set X] is a [List-of X]
    ;; order is irrelevant; no duplicates allowed

    ;; (list x y z)
    ;; (cons x (cons y (cons z '())))
    ;; (foldr f base (cons x (cons y (cons z '()))))
    ;; (f x (f y (f z base)))
    ;; (union (list x y z) set2)
    ;; (add x (add y (add z set2)))

    ;; (union '() set2)
    ;; set2

    ;; union : {X} [Set X] [Set X] -&gt; [Set X]
    (define (union set1 set2)
      (foldr add set2 set1))

    (check-expect (union ex-set-1 ex-set-3) (list 1 3 5 2 4 6))

    ;(check-expect (union
    ;; intersect : {X} [Set X] [Set X] -&gt; [Set X]

    ;; add : {X} X [Set X] -&gt; [Set X]
    (define (add elem set)
      (if (contains? elem set)
          set
          (cons elem set)))

    (check-expect (add 10 ex-set-1) (list 10 1 3 5))
    (check-expect (add 3 ex-set-1) ex-set-1)

    ;; contains? : {X} X [Set X] -&gt; Boolean
    (define (contains? elem set)
      (ormap (lambda (elem-in-set) (equal? elem-in-set elem)) set))

    (check-expect (contains? 5 ex-set-1) #true)
    (check-expect (contains? 5 ex-set-2) #true)
    (check-expect (contains? 50 ex-set-1) #false)

    (list ex-set-1)
</pre>
</details>
<h1 id="lecture-24---more-practice-with-lambda-and-locals">Lecture 24 - More Practice with Lambda and Locals</h1>

<h2 id="sets-1">Sets</h2>

<p>Recap on Lecture 23 - building sets with lists</p>

<ul>
  <li>Limitations
    <ul>
      <li>Can‚Äôt represent all possible sets (example all even numbers)</li>
    </ul>
  </li>
  <li>We can, however, represent all finite sets</li>
</ul>

<p>Recall:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A [Set X] is a [List-of X]</span>
<span class="c1">;; order is irrelevant; no duplicates allowed</span>
<span class="c1">;; union : {X} [Set X] [Set X] -&gt; [Set X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">union</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">foldr</span> <span class="nv">add</span> <span class="nv">set2</span> <span class="nv">set1</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">union</span> <span class="nv">ex-set-1</span> <span class="nv">ex-set-3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1">;(check-expect (union</span>
<span class="c1">;; intersect : {X} [Set X] [Set X] -&gt; [Set X]</span>

<span class="c1">;; add : {X} X [Set X] -&gt; [Set X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">contains?</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)</span>
      <span class="nv">set</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add</span> <span class="mi">10</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add</span> <span class="mi">3</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="nv">ex-set-1</span><span class="p">)</span>

<span class="c1">;; contains? : {X} X [Set X] -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">contains?</span> <span class="nv">elem</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">ormap</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">elem-in-set</span><span class="p">)</span> <span class="p">(</span><span class="nb">equal?</span> <span class="nv">elem-in-set</span> <span class="nv">elem</span><span class="p">))</span> <span class="nv">set</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">contains?</span> <span class="mi">5</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">contains?</span> <span class="mi">5</span> <span class="nv">ex-set-2</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">contains?</span> <span class="mi">50</span> <span class="nv">ex-set-1</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="cartesian-product">Cartesian Product</h3>

<p>Example:</p>

<p>setA = { 1, 3, 5 }</p>

<p>setB = { 20, 40, 60 }</p>

<p>setA * setB = { (1, 20), (1, 40), (1, 60), (3, 20) ‚Ä¶ }</p>

<p>‚ÄúThis makes me cringe just a little bit‚Äù - Arjun</p>

<p><strong>Function:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; prod :: [Set X] [Set X] -&gt; [Set (make-pair X Y)]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prod</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">foldr</span>
   <span class="nv">append</span>
   <span class="o">'</span><span class="p">()</span>
   <span class="p">(</span><span class="nb">map</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-pair</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span> <span class="nv">set-b</span><span class="p">))</span>
    <span class="nv">set-a</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-set-prod-1</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-set-prod-2</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">20</span> <span class="mi">40</span> <span class="mi">60</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nb">length</span> <span class="p">(</span><span class="nf">prod</span> <span class="nv">ex-set-prod-1</span> <span class="nv">ex-set-prod-2</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">ex-set-prod-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">ex-set-prod-2</span><span class="p">)))</span>
</code></pre></div></div>

<ul>
  <li>Nested <code class="language-plaintext highlighter-rouge">map</code>functions (for each in the first list, handle each in the second list)</li>
</ul>

<h3 id="characteristic-function">Characteristic Function</h3>

<p>Let‚Äôs not use lists to represent sets. Instead, let‚Äôs use functions</p>

<ul>
  <li>Can represent infinite sets this way</li>
  <li>Don‚Äôt actually use in practice
    <ul>
      <li>It‚Äôs a pain</li>
    </ul>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Alternate definition:</span>
<span class="c1">;; A [Set-of X] = X -&gt; Boolean</span>
<span class="c1">;; Interpretation: A set of elements X, represented by their characteristic</span>
<span class="c1">;; function.</span>
</code></pre></div></div>

<p>Example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ex-fset-1</span> <span class="nv">x</span><span class="p">)</span>
	<span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
		 <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
		 <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">7</span><span class="p">)))</span>
<span class="c1">; This is the same as {0, 7, 10}</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ex-fset-2</span> <span class="nv">x</span><span class="p">)</span>
	<span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">x</span><span class="p">)</span>
		  <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">5</span><span class="p">)))</span>
<span class="c1">; This is the set of all even numbers and 5</span>
</code></pre></div></div>

<p><strong>Union as a Set:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ex-fset-3</span> <span class="nv">x</span><span class="p">)</span>
	<span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">ex-fset-1</span> <span class="nv">x</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">ex-fset-2</span> <span class="nv">x</span><span class="p">)))</span>
<span class="c1">; The union of fset-1 and fset-2</span>
</code></pre></div></div>

<p><strong>Intersect as a Set:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ex-fset-3</span> <span class="nv">x</span><span class="p">)</span>
	<span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nf">ex-fset-1</span> <span class="nv">x</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">ex-fset-2</span> <span class="nv">x</span><span class="p">)))</span>
<span class="c1">; The union of fset-1 and fset-2</span>
</code></pre></div></div>

<p><strong>Contains and Add:</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; fcontains : X [Set X] -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fcontains?</span> <span class="nv">elt</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">set</span> <span class="nv">elt</span><span class="p">))</span>

<span class="c1">;; fadd : {X} X [Set X] -&gt; [Set X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fadd</span> <span class="nv">elem1</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">elem2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">equal?</span> <span class="nv">elem2</span> <span class="nv">elem1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">fcontains?</span> <span class="nv">elem2</span> <span class="nv">set</span><span class="p">))))</span>
</code></pre></div></div>

<ul>
  <li>The reason that we use <code class="language-plaintext highlighter-rouge">fcontains?</code> and not just the set funciton is because the user should not have to think of the set as a function</li>
</ul>

<p>‚ÄúThere‚Äôs hopefully a limit to stupid‚Äù - Arjun</p>

<h3 id="union">Union</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; union : {X} [Set X] [Set X] -&gt; [Set X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">funion</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">query-elem</span><span class="p">)</span>
    <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">fcontains?</span> <span class="nv">query-elem</span> <span class="nv">set1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">fcontains?</span> <span class="nv">query-elem</span> <span class="nv">set2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">fset-empty</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">query-elem</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="complement">Complement</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fcomplement</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">query-elem</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nf">fcontains</span> <span class="nv">query-elem</span> <span class="nv">set</span><span class="p">))))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Adapted from Lecture 23

    (define ex-set-1 (list 1 3 5))
    (define ex-set-2 (list 5 3 1))
    (define ex-set-3 (list 2 4 6))
    ; Invalid example: (define ex-set-3 (list 1 1 3 3 3 5))
    (define ex-set-4 (list "Arjun" "Amal" "Ben"))

    ;; union : {X} [Set X] [Set X] -&gt; [Set X]
    (define (union set1 set2)
      (foldr add set2 set1))

    (check-expect (union ex-set-1 ex-set-3) (list 1 3 5 2 4 6))

    ;; Exercise: write intersect

    ;; add : {X} X [Set X] -&gt; [Set X]
    (define (add elem set)
      (if (contains? elem set)
          set
          (cons elem set)))

    (check-expect (add 10 ex-set-1) (list 10 1 3 5))
    (check-expect (add 3 ex-set-1) ex-set-1)

    ;; contains? : {X} X [Set X] -&gt; Boolean
    (define (contains? elem set)
      (ormap (lambda (elem-in-set) (equal? elem-in-set elem)) set))

    (check-expect (contains? 5 ex-set-1) #true)
    (check-expect (contains? 5 ex-set-2) #true)
    (check-expect (contains? 50 ex-set-1) #false)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; setA = { 1, 3, 5 }
    ; setB = { 20, 40, 60 }
    ; setA * setB = { (1, 20), (1, 40), (1, 60), (3, 20), (3, 40), (3, 60), (5, 20), (5, 40), (5, 60) }

    (define-struct pair [left right])

      #;(list
       (map (lambda (b) (make-pair (first set-a) b)) set-b)
       (map (lambda (b) (make-pair (second set-a) b)) set-b)
       (map (lambda (b) (make-pair (third set-a) b)) set-b))

    ;; prod :: [Set X] [Set X] -&gt; [Set (make-pair X Y)]
    (define (prod set-a set-b)
      (foldr
       append
       '()
       (map
        (lambda (a) (map (lambda (b) (make-pair a b)) set-b))
        set-a)))

    (define ex-set-prod-1 (list 1 3 5 9 10 4))
    (define ex-set-prod-2 (list 20 40 60))
    (check-expect (length (prod ex-set-prod-1 ex-set-prod-2))
                  (* (length ex-set-prod-1) (length ex-set-prod-2)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; "Characteristic function"
    (define (ex-fset-1 x)
      (or (= x 0)
          (= x 10)
          (= x 7)))

    (define ex-fset-1/v2
      (lambda (x)
        (or (= x 0)
            (= x 10)
            (= x 7))))

    (define (ex-fset-2 x)
      (or (even? x)
          (= x 5)))

    (define (ex-fset-3 x)
      (or (ex-fset-1 x)
          (ex-fset-2 x)))

    (define (ex-fset-4 x)
      (and (ex-fset-1 x)
           (ex-fset-2 x)))

    ;; Alternate definition:
    ;; A [Set-of X] = X -&gt; Boolean
    ;; Interpretation: A set of elements X, represented by their characteristic
    ;; function.

    ;; fcontains : X [Set X] -&gt; Boolean
    (define (fcontains? elt set)
      (set elt))

    ;; fadd : {X} X [Set X] -&gt; [Set X]
    (define (fadd elem1 set)
      (lambda (elem2)
        (or (equal? elem2 elem1)
            (fcontains? elem2 set))))

    #;(define (ex-fset-1 x)
      (or (= x 0)
          (= x 10)
          (= x 7)))

    ;((fadd 500 ex-fset-1) 1000)

    (define ex-fset-5 (fadd 500 ex-fset-1))
    (check-expect (fcontains? 500 ex-fset-5) #true)
    (check-expect (fcontains? 0 ex-fset-5) #true)
    (check-expect (fcontains? 5000 ex-fset-5) #false)

    (define (fadd-nonsense elem1 set)
      (lambda (elem2)
        (or (equal? elem2 elem1)
            (fcontains? elem2 set)
            (equal? elem2 78645897243687592))))

    ;; union : {X} [Set X] [Set X] -&gt; [Set X]
    (define (funion set1 set2)
      (lambda (query-elem)
        (or (fcontains? query-elem set1)
            (fcontains? query-elem set2))))

    (define fset-empty (lambda (query-elem) #false))

    (define fset-avoid-this (lambda (query-elem) #true))

    (define (fcomplement set)
      (lambda (query-elem)
        (not (fcontains query-elem set))))

    ;; [Set Integer]

    ;; N is an integer in the range [0, 10]
    ;; [Set N]
</pre>
</details>
<h1 id="lecture-25---new-kinds-of-self-referential-data">Lecture 25 - New Kinds of Self Referential Data</h1>

<p>Unions of structs that are self-referential are more powerful than we initially thought.</p>

<h2 id="river-example"><strong>River Example</strong></h2>

<p>If we add up the rate of water flow of all the river branches, we get the amount of water flowing in the outlet of the river.</p>

<p>River ends, 10 + 3 + 5 + 11 + 15 = 44</p>

<h3 id="data-defintion"><strong>Data Defintion:</strong></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A River is one of</span>
<span class="c1">;; - (make-stream Number)</span>
<span class="c1">;; - (make-merge River River)</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">merge</span> <span class="p">[</span><span class="nf">left</span> <span class="nv">right</span><span class="p">])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">stream</span> <span class="p">[</span><span class="nf">flow</span><span class="p">])</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-stream-1</span> <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-stream-2</span> <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-stream-3</span> <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-river-1</span> <span class="p">(</span><span class="nf">make-merge</span> <span class="nv">ex-stream-1</span> <span class="p">(</span><span class="nf">make-merge</span> <span class="nv">ex-stream-2</span> <span class="nv">ex-stream-3</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-river-2</span> <span class="p">(</span><span class="nf">make-merge</span> <span class="p">(</span><span class="nf">make-merge</span> <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">20</span><span class="p">))</span>
                                <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">40</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-river-1-full</span> <span class="p">(</span><span class="nf">make-merge</span> <span class="nv">ex-river-1</span>
                                    <span class="p">(</span><span class="nf">make-merge</span> <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">11</span><span class="p">)</span>
                                                <span class="p">(</span><span class="nf">make-stream</span> <span class="mi">15</span><span class="p">))))</span>
</code></pre></div></div>

<h3 id="template-5">Template:</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; river-template : River -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">river-template</span> <span class="nv">r</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">stream?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">stream-flow</span> <span class="nv">r</span><span class="p">)</span> <span class="o">...</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">merge?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">river-template</span> <span class="p">(</span><span class="nf">merge-left</span> <span class="nv">r</span><span class="p">))</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">river-template</span> <span class="p">(</span><span class="nf">merge-right</span> <span class="nv">r</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<ul>
  <li>Notice the two recursive calls</li>
</ul>

<h3 id="function---flow-to-ocean">Function - <code class="language-plaintext highlighter-rouge">flow-to-ocean</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; flow-to-ocean : River -&gt; Number</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">flow-to-ocean</span> <span class="nv">ex-river-1-full</span><span class="p">)</span> <span class="mi">44</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">flow-to-ocean</span> <span class="nv">ex-stream-1</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">flow-to-ocean</span> <span class="nv">r</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">stream?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nf">stream-flow</span> <span class="nv">r</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">merge?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">flow-to-ocean</span> <span class="p">(</span><span class="nf">merge-left</span> <span class="nv">r</span><span class="p">))</span>
                   <span class="p">(</span><span class="nf">flow-to-ocean</span> <span class="p">(</span><span class="nf">merge-right</span> <span class="nv">r</span><span class="p">)))]))</span>
</code></pre></div></div>

<p>‚ÄúThere is a limit to the number of things one can keep on his ears at a time‚Äù - Arjun</p>

<h3 id="function---count-streams">Function - <code class="language-plaintext highlighter-rouge">count-streams</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; count-streams : River -&gt; Number</span>
<span class="c1">;; Purpose: count the total number of streams that feed this big river.</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">count-streams</span> <span class="nv">ex-stream-1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">count-streams</span> <span class="nv">ex-river-1-full</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">count-streams</span> <span class="nv">r</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">stream?</span> <span class="nv">r</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">merge?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">count-streams</span> <span class="p">(</span><span class="nf">merge-left</span> <span class="nv">r</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">count-streams</span> <span class="p">(</span><span class="nf">merge-right</span> <span class="nv">r</span><span class="p">)))]))</span>
</code></pre></div></div>

<ul>
  <li>only change the base case between <code class="language-plaintext highlighter-rouge">count-streams</code> and <code class="language-plaintext highlighter-rouge">flow-to-ocean</code></li>
</ul>

<p>‚ÄúLet‚Äôs make this a lamer tree‚Äù - Arjun</p>

<h3 id="function---widest-stream">Function - <code class="language-plaintext highlighter-rouge">widest-stream</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; widest-stream: River -&gt; Number</span>
<span class="c1">;; Purpose: Produces the flow of water through the widest stream that feeds</span>
<span class="c1">;; this river.</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">widest-stream</span> <span class="nv">ex-river-1-full</span><span class="p">)</span> <span class="mi">15</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">widest-stream</span> <span class="nv">r</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">stream?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nf">stream-flow</span> <span class="nv">r</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">merge?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nb">max</span> <span class="p">(</span><span class="nf">widest-stream</span> <span class="p">(</span><span class="nf">merge-left</span> <span class="nv">r</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">widest-stream</span> <span class="p">(</span><span class="nf">merge-right</span> <span class="nv">r</span><span class="p">)))]))</span>
</code></pre></div></div>

<h2 id="tree-example">Tree Example</h2>

<h3 id="data-defintion-1">Data Defintion</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A FruitTree is one of:</span>
<span class="c1">;; - (make-fruit Number Boolean)</span>
<span class="c1">;; - (make-leaf)</span>
<span class="c1">;; - (make-branch FruitTree FruitTree)</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">fruit</span> <span class="p">[</span><span class="nf">weight</span> <span class="nv">ripe?</span><span class="p">])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">leaf</span> <span class="p">[])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">branch</span> <span class="p">[</span><span class="nf">left</span> <span class="nv">right</span><span class="p">])</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-tree-1</span>
  <span class="p">(</span><span class="nf">make-branch</span>
   <span class="p">(</span><span class="nf">make-branch</span>
    <span class="p">(</span><span class="nf">make-branch</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">make-leaf</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">make-branch</span> <span class="p">(</span><span class="nf">make-fruit</span> <span class="mi">100</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">make-fruit</span> <span class="mi">10</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)))</span>
   <span class="p">(</span><span class="nf">make-branch</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">make-fruit</span> <span class="mi">50</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">))))</span>
</code></pre></div></div>

<ul>
  <li>Two base cases</li>
  <li>Note: the reason that <code class="language-plaintext highlighter-rouge">leaf</code> is a structure itself is for two reasons
    <ul>
      <li>So everything is the same type</li>
      <li>Future proof ‚Äî we can add to it later</li>
    </ul>
  </li>
</ul>

<h3 id="template-6">Template</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; fruit-tree-template : FruitTree -&gt; ?</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fruit-tree-template</span> <span class="nv">ft</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">fruit?</span> <span class="nv">ft</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">fruit-weight</span> <span class="nv">ft</span><span class="p">)</span> <span class="o">...</span> <span class="p">(</span><span class="nf">fruit-ripe?</span> <span class="nv">ft</span><span class="p">)</span> <span class="o">...</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">ft</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">branch?</span> <span class="nv">ft</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">fruit-tree-template</span> <span class="p">(</span><span class="nf">branch-left</span> <span class="nv">ft</span><span class="p">))</span> <span class="o">...</span>
                       <span class="p">(</span><span class="nf">fruit-tree-template</span> <span class="p">(</span><span class="nf">branch-right</span> <span class="nv">ft</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>
<h1 id="lecture-26---binary-trees">Lecture 26 - Binary Trees</h1>

<p>Exam on Nov. 23rd.</p>

<ul>
  <li>Harder than the first exam</li>
  <li>It should take 1.5 hours, given 3 hours</li>
  <li>Material: from Day 1 to Right now</li>
</ul>

<p><strong>Error:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(error [STRING])</code> :  Produces Error</li>
</ul>

<h3 id="association-list"><strong>Association List</strong></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">ex-alist-empty</span> <span class="o">'</span><span class="p">())</span>
<span class="c1">;; [AList String]</span>
<span class="c1">;; An association list from NUIDs to names.</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-alist-nuids</span>
  <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">make-pair</span> <span class="mi">748</span> <span class="s">"Arjun Guha"</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">make-pair</span> <span class="mi">881</span> <span class="s">"Amal Ahmed"</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">make-pair</span> <span class="mi">900</span> <span class="s">"Benjamin Lerner"</span><span class="p">)))</span>
</code></pre></div></div>

<p><strong>Lookup Function</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; alookup : Number [AList X] -&gt; X</span>
<span class="c1">;; Produces the value associated with _search-key_ in _alist_.</span>
<span class="c1">;; *Assumes* that the the key is in _alist_.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">alookup</span> <span class="nv">search-key</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"key not found"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">search-key</span> <span class="p">(</span><span class="nf">pair-key</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">pair-value</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">alookup</span> <span class="nv">search-key</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)))]))</span>

<span class="p">(</span><span class="nf">check-error</span> <span class="p">(</span><span class="nf">alookup</span> <span class="mi">0</span> <span class="nv">ex-alist-empty</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">alookup</span> <span class="mi">881</span> <span class="nv">ex-alist-nuids</span><span class="p">)</span> <span class="s">"Amal Ahmed"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">alookup</span> <span class="mi">748</span> <span class="nv">ex-alist-nuids</span><span class="p">)</span> <span class="err">"</span><span class="nv">Arjun</span> <span class="nv">Guha</span>
</code></pre></div></div>

<p>But what if the association list is very long?</p>

<ul>
  <li>It might take very long</li>
</ul>

<h2 id="binary-search">Binary Search</h2>

<ul>
  <li>Abstract data type</li>
</ul>

<p>Structure things as trees rather than a list.</p>

<p>All of the left nodes have a smaller value and the right nodes have a greater value (kind of sorted)</p>

<ul>
  <li>This allows us to limit which children we look at to save time</li>
</ul>

<p>‚ÄúOh, wow. There‚Äôs like a phone with a curly thing.‚Äù - Arjun</p>

<h3 id="example---leaf-and-nodes">Example - Leaf and Nodes</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">leaf</span> <span class="p">[])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">node</span> <span class="p">[</span><span class="nf">left</span> <span class="nv">key</span> <span class="nv">value</span> <span class="nv">right</span><span class="p">])</span>
<span class="c1">;; A [BST X] is one of:</span>
<span class="c1">;; - (make-leaf)</span>
<span class="c1">;; - (make-node [BST X] Number X [BST X])</span>
<span class="c1">;; Constraint: In _(make-node left key value right)_ all the keys in _left_ are</span>
<span class="c1">;; less than _key_ and all the keys in _right_ are greater than _key_.</span>
</code></pre></div></div>

<p>Every node has a left child and a right child</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">LEAF</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-bst-0</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-bst-1</span> <span class="p">(</span><span class="nf">make-node</span> <span class="nv">LEAF</span> <span class="mi">4</span> <span class="s">"Daniel"</span> <span class="nv">LEAF</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-bst-2</span> <span class="p">(</span><span class="nf">make-node</span> <span class="nv">LEAF</span> <span class="mi">3</span> <span class="s">"Amal"</span> <span class="nv">ex-bst-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-bst-3</span>
  <span class="p">(</span><span class="nf">make-node</span> <span class="p">(</span><span class="nf">make-node</span>
              <span class="p">(</span><span class="nf">make-leaf</span><span class="p">)</span>
              <span class="mi">7</span> <span class="s">"Aislin"</span>
              <span class="p">(</span><span class="nf">make-leaf</span><span class="p">))</span>
             <span class="mi">10</span> <span class="s">"Ben"</span>
             <span class="p">(</span><span class="nf">make-node</span>
              <span class="p">(</span><span class="nf">make-node</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">)</span>
                         <span class="mi">15</span> <span class="s">"Ferd"</span>
                         <span class="p">(</span><span class="nf">make-leaf</span><span class="p">))</span>
              <span class="mi">17</span> <span class="s">"John"</span>
              <span class="p">(</span><span class="nf">make-leaf</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-bst-4</span>
  <span class="p">(</span><span class="nf">make-node</span> <span class="nv">ex-bst-2</span>
             <span class="mi">5</span> <span class="s">"Arjun"</span>
             <span class="nv">ex-bst-3</span><span class="p">))</span>
</code></pre></div></div>

<p>How do we know that 5 is on the top?</p>

<ul>
  <li>The example was arbitrary</li>
  <li>For this class, don‚Äôt worry about it. Just make sure that it‚Äôs not left or right leaning.</li>
</ul>

<h3 id="template-7">Template</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">bst-template</span> <span class="nv">abst</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
      <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span>
                     <span class="p">(</span><span class="nf">bst-template</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">bst-template</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span><span class="p">))]))</span>
</code></pre></div></div>

<ul>
  <li>Note: we will learn a better way to do templates later</li>
</ul>

<h3 id="function---lookup">Function - <code class="language-plaintext highlighter-rouge">lookup</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; lookup : {X} Number [BST X] -&gt; X</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="nv">abst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"nobody"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abst</span><span class="p">)</span>
     <span class="o">#</span><span class="c1">;(if (= query-key (node-key abst))</span>
         <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">))))</span>
     <span class="p">(</span><span class="k">cond</span>
       <span class="p">[(</span><span class="nb">=</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)]</span>
       <span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">))]</span>
       <span class="c1">;; ; (&gt; query-key (node-key abst))</span>
       <span class="c1">;; [else (lookup query-key (node-right abst))]</span>
       <span class="p">[(</span><span class="nb">&gt;</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">))])]))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">lookup</span> <span class="mi">7</span> <span class="nv">ex-bst-4</span><span class="p">)</span> <span class="s">"Aislin"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-error</span> <span class="p">(</span><span class="nf">lookup</span> <span class="mi">8</span> <span class="nv">ex-bst-4</span><span class="p">))</span>
</code></pre></div></div>

<p>Try making an insert function</p>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    (define-struct pair [key value])
    ;; An [AList X] is a [List-of (make-pair Number X)]

    (define ex-alist-empty '())
    ;; [AList String]
    ;; An association list from NUIDs to names.
    (define ex-alist-nuids
      (list (make-pair 748 "Arjun Guha")
            (make-pair 881 "Amal Ahmed")
            (make-pair 900 "Benjamin Lerner")))

    ;; alookup : Number [AList X] -&gt; X
    ;; Produces the value associated with _search-key_ in _alist_.
    ;; *Assumes* that the the key is in _alist_.
    (define (alookup search-key alist)
      (cond
        [(empty? alist) (error "key not found")]
        [(cons? alist)
         (if (= search-key (pair-key (first alist)))
             (pair-value (first alist))
             (alookup search-key (rest alist)))]))

    (check-error (alookup 0 ex-alist-empty))
    (check-expect (alookup 881 ex-alist-nuids) "Amal Ahmed")
    (check-expect (alookup 748 ex-alist-nuids) "Arjun Guha")

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define-struct leaf [])
    (define-struct node [left key value right])
    ;; A [BST X] is one of:
    ;; - (make-leaf)
    ;; - (make-node [BST X] Number X [BST X])
    ;; Constraint: In _(make-node left key value right)_ all the keys in _left_ are
    ;; less than _key_ and all the keys in _right_ are greater than _key_.

    #;(define (bst-template abst)
        (cond
          [(leaf? abst) ...]
          [(node? abst) (...
                         (bst-template (node-left abst) ...)
                         (node-key abst) ...
                         (node-value abst) ...
                         (bst-template (node-right abst) ...))]))

    (define LEAF (make-leaf))
    (define ex-bst-0 (make-leaf))
    (define ex-bst-1 (make-node LEAF 4 "Daniel" LEAF))
    (define ex-bst-2 (make-node LEAF 3 "Amal" ex-bst-1))

    (define ex-bst-3
      (make-node (make-node
                  (make-leaf)
                  7 "Aislin"
                  (make-leaf))
                 10 "Ben"
                 (make-node
                  (make-node (make-leaf)
                             15 "Ferd"
                             (make-leaf))
                  17 "John"
                  (make-leaf))))
    (define ex-bst-4
      (make-node ex-bst-2
                 5 "Arjun"
                 ex-bst-3))

    ;; lookup : {X} Number [BST X] -&gt; X
    (define (lookup query-key abst)
      (cond
        [(leaf? abst) (error "nobody")]
        [(node? abst)
         #;(if (= query-key (node-key abst))
             (node-value abst)
             (if (&lt; query-key (node-key abst))
                 (lookup query-key (node-left abst))
                 (lookup query-key (node-right abst))))
         (cond
           [(= query-key (node-key abst)) (node-value abst)]
           [(&lt; query-key (node-key abst)) (lookup query-key (node-left abst))]
           ;; ; (&gt; query-key (node-key abst))
           ;; [else (lookup query-key (node-right abst))]
           [(&gt; query-key (node-key abst)) (lookup query-key (node-right abst))])]))

    (check-expect (lookup 7 ex-bst-4) "Aislin")
    (check-error (lookup 8 ex-bst-4))
</pre>
</details>
<h1 id="lecture-27---more-on-binary-search-trees">Lecture 27 - More on Binary Search Trees</h1>

<p>Exam Monday after next.</p>

<p>Recall Binary Search Trees:</p>

<ul>
  <li>Leafs</li>
  <li>Nodes</li>
</ul>

<p>All keys on the right of the nodes have a value higher and all of the keys on the left have a lower value.</p>

<p>You may write signatures for all definitions (not just functions)</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">leaf</span> <span class="p">[])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">node</span> <span class="p">[</span><span class="nf">left</span> <span class="nv">key</span> <span class="nv">value</span> <span class="nv">right</span><span class="p">])</span>
<span class="c1">;; A [BST X] is one of:</span>
<span class="c1">;; - (make-leaf)</span>
<span class="c1">;; - (make-node [BST X] Number X [BST X])</span>
<span class="c1">;; Constraint: In _(make-node left key value right)_ all the keys in _left_ are</span>
<span class="c1">;; less than _key_ and all the keys in _right_ are greater than _key_.</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">bst-template</span> <span class="nv">abst</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
      <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span>
                     <span class="p">(</span><span class="nf">bst-template</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span>
                     <span class="p">(</span><span class="nf">bst-template</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">)</span> <span class="o">...</span><span class="p">))]))</span>
</code></pre></div></div>

<h3 id="lookup-function">Lookup Function</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; lookup : {X} Number [BST X] -&gt; X</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="nv">abst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"key not found"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abst</span><span class="p">)</span>
     <span class="p">(</span><span class="k">cond</span>
       <span class="p">[(</span><span class="nb">=</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)]</span>
       <span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">))]</span>
       <span class="p">[</span><span class="k">else</span> <span class="c1">; (&gt; query-key (node-key abst))</span>
          <span class="p">(</span><span class="nf">lookup</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">))])]))</span>
</code></pre></div></div>

<h3 id="lookup-unordered">Lookup Unordered</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; lookup-unordered : {X} Number [BST X] -&gt; X</span>
<span class="c1">;; Looks up the key, but does not require the ordering constraint to hold.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">lookup-unordered</span> <span class="nv">query-key</span> <span class="nv">abst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"key not found"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abst</span><span class="p">)</span>
     <span class="p">(</span><span class="k">cond</span>
       <span class="p">[(</span><span class="nb">=</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)]</span>
       <span class="p">[</span><span class="k">else</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">bst-contains?</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">lookup-unordered</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">lookup-unordered</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">)))])]))</span>
</code></pre></div></div>

<p>Note: This is the homework problem 11 in homework 9</p>

<ul>
  <li>But this isn‚Äôt that good because it searches the tree n times (where n is the height of the tree)</li>
</ul>

<h3 id="function---insert">Function - <code class="language-plaintext highlighter-rouge">insert</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; insert : {X} Number X [BST X] -&gt; [BST X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">insert</span> <span class="nv">query-key</span> <span class="nv">new-value</span> <span class="nv">abst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-node</span> <span class="nv">LEAF</span> <span class="nv">query-key</span> <span class="nv">new-value</span> <span class="nv">LEAF</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abst</span><span class="p">)</span>
     <span class="p">(</span><span class="k">cond</span>
       <span class="p">[(</span><span class="nb">=</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span> <span class="p">(</span><span class="nf">make-node</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">)</span>
                                                 <span class="nv">query-key</span> <span class="nv">new-value</span>
                                                 <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">))]</span>
       <span class="p">[(</span><span class="nb">&lt;</span> <span class="nv">query-key</span> <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="p">(</span><span class="nf">insert</span> <span class="nv">query-key</span> <span class="nv">new-value</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">))</span>
                   <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">))]</span>
       <span class="p">[</span><span class="k">else</span> <span class="c1">; (&gt; query-key (node-key abst))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">insert</span> <span class="nv">query-key</span> <span class="nv">new-value</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">)))])]))</span>
</code></pre></div></div>

<ul>
  <li>Insert and lookup are the two functions that are actually used by the user</li>
  <li>We are assuming that keys are unique
    <ul>
      <li>If it has the same key, we are replacing the node</li>
    </ul>
  </li>
</ul>

<p>‚ÄúI don‚Äôt feel like scrolling. Scrolling is annoying.‚Äù - Arjun</p>

<p>‚ÄúThis is evidently my wife‚Äôs mask. I‚Äôm having trouble with it here.‚Äù - Arjun</p>

<h3 id="function---list-bst">Function - <code class="language-plaintext highlighter-rouge">list-&gt;bst</code></h3>

<p>‚ÄúThis smells like a foldr.‚Äù - Arjun</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">pair</span> <span class="p">(</span><span class="nf">key</span> <span class="nv">val</span><span class="p">))</span>
<span class="c1">;; list-&gt;bst : {X} [List-of (make-pair Number X)] -&gt; [BST X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">list-&gt;bst</span> <span class="nv">key-val-list</span><span class="p">)</span>
  <span class="c1">; (foldr + 0 lon)</span>
  <span class="p">(</span><span class="nf">foldr</span>
   <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">new-pair</span> <span class="nv">partial-bst</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">pair-key</span> <span class="nv">new-pair</span><span class="p">)</span> <span class="p">(</span><span class="nf">pair-val</span> <span class="nv">new-pair</span><span class="p">)</span> <span class="nv">partial-bst</span><span class="p">))</span>
   <span class="nv">LEAF</span>
   <span class="nv">key-val-list</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>Non-uniform fold</li>
  <li>Note: when you need two values, you can package them into a struct and ‚Äòunbox‚Äô them later on</li>
</ul>

<h3 id="function---bst-add10-and-bst-add100">Function - <code class="language-plaintext highlighter-rouge">bst-add10</code> and <code class="language-plaintext highlighter-rouge">bst-add100</code></h3>

<ul>
  <li>These look similar to map</li>
</ul>

<h3 id="function---bst-map">Function - <code class="language-plaintext highlighter-rouge">bst-map</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; bst-add10 : [BST Number] -&gt; [BST Number]</span>
<span class="c1">;; Adds 10 to all numbers in the BST.</span>

<span class="c1">;; bst-add100 : [BST Number] -&gt; [BST Number]</span>
<span class="c1">;; Adds 100 to all numbers in the BST.</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">bst-map</span> <span class="nv">f</span> <span class="nv">abst</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">)]</span>
      <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abst</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-node</span>
                     <span class="p">(</span><span class="nf">bst-map</span> <span class="nv">f</span>  <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abst</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">node-key</span> <span class="nv">abst</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abst</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">bst-map</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abst</span><span class="p">)))]))</span>
</code></pre></div></div>

<ul>
  <li>You can do (almost) all of the list abstractions in trees</li>
</ul>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Adapted from Monday's lecture

    (define-struct leaf [])
    (define-struct node [left key value right])
    ;; A [BST X] is one of:
    ;; - (make-leaf)
    ;; - (make-node [BST X] Number X [BST X])
    ;; Constraint: In _(make-node left key value right)_ all the keys in _left_ are
    ;; less than _key_ and all the keys in _right_ are greater than _key_.

    #;(define (bst-template abst)
        (cond
          [(leaf? abst) ...]
          [(node? abst) (...
                         (bst-template (node-left abst) ...)
                         (node-key abst) ...
                         (node-value abst) ...
                         (bst-template (node-right abst) ...))]))

    ;; LEAF : {X} [BST X]
    (define LEAF (make-leaf))

    ;; ex-bst-1 : [BST String]
    (define ex-bst-1 (make-node LEAF 4 "Daniel" LEAF))
    ;; ex-bst-2 : [BST String]
    (define ex-bst-2 (make-node LEAF 3 "Amal" ex-bst-1))
    ;; ex-bst-3 : [BST String]
    (define ex-bst-3
      (make-node (make-node LEAF 7 "Aislin" LEAF)
                 10 "Ben"
                 (make-node
                    (make-node LEAF 15 "Ferd" LEAF)
                    17 "John"
                    LEAF)))
    ;; ex-bst-4 : [BST String]
    (define ex-bst-4 (make-node ex-bst-2 5 "Arjun" ex-bst-3))

    ;; ex-bst-5 : [BST Boolean]
    (define ex-bst-5 (make-node LEAF 0 #true (make-node LEAF 10 #true LEAF)))

    ;; lookup : {X} Number [BST X] -&gt; X
    (define (lookup query-key abst)
      (cond
        [(leaf? abst) (error "key not found")]
        [(node? abst)
         (cond
           [(= query-key (node-key abst)) (node-value abst)]
           [(&lt; query-key (node-key abst)) (lookup query-key (node-left abst))]
           [else ; (&gt; query-key (node-key abst))
              (lookup query-key (node-right abst))])]))

    (check-expect (lookup 7 ex-bst-4) "Aislin")
    (check-error (lookup 8 ex-bst-4))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; bst-contains? : {X} Number [BST X] -&gt; Boolean
    (define (bst-contains? query-key abst)
        (cond
          [(leaf? abst) #false]
          [(node? abst) (or
                         (= query-key (node-key abst))
                         (bst-contains? query-key (node-left abst))
                         (bst-contains? query-key (node-right abst)))]))

    ;; lookup-unordered : {X} Number [BST X] -&gt; X
    ;; Looks up the key, but does not require the ordering constraint to hold.
    (define (lookup-unordered query-key abst)
      (cond
        [(leaf? abst) (error "key not found")]
        [(node? abst)
         (cond
           [(= query-key (node-key abst)) (node-value abst)]
           [else
            (if (bst-contains? query-key (node-left abst))
             (lookup-unordered query-key (node-left abst))
             (lookup-unordered query-key (node-right abst)))])]))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; lookup : {X} Number [BST X] -&gt; X

    ;; LEAF : {X} [BST X]
    ;; (define LEAF (make-leaf))

    ;; insert : {X} Number X [BST X] -&gt; [BST X]
    (define (insert query-key new-value abst)
      (cond
        [(leaf? abst) (make-node LEAF query-key new-value LEAF)]
        [(node? abst)
         (cond
           [(= query-key (node-key abst)) (make-node (node-left abst)
                                                     query-key new-value
                                                     (node-right abst))]
           [(&lt; query-key (node-key abst))
            (make-node (insert query-key new-value (node-left abst))
                       (node-key abst) (node-value abst)
                       (node-right abst))]
           [else ; (&gt; query-key (node-key abst))
            (make-node (node-left abst)
                       (node-key abst) (node-value abst)
                       (insert query-key new-value (node-right abst)))])]))

    (check-expect (lookup -100 (insert -100 "Carter" ex-bst-4)) "Carter")

    (check-expect (lookup 17 (insert -100 "Carter" ex-bst-4)) "John")

    (define-struct pair (key val))

    ;; list-&gt;bst : {X} [List-of (make-pair Number X)] -&gt; [BST X]
    (define (list-&gt;bst key-val-list)
      ; (foldr + 0 lon)
      (foldr
       (lambda (new-pair partial-bst)
         (insert (pair-key new-pair) (pair-val new-pair) partial-bst))
       LEAF
       key-val-list))

    (list-&gt;bst (list (make-pair 1 "Arjun") (make-pair 0 "Amal")))

    #;(define (bst-template abst)
        (cond
          [(leaf? abst) ...]
          [(node? abst) (...
                         (bst-template (node-left abst) ...)
                         (node-key abst) ...
                         (node-value abst) ...
                         (bst-template (node-right abst) ...))]))

    ;; bst-add10 : [BST Number] -&gt; [BST Number]
    ;; Adds 10 to all numbers in the BST.

    ;; bst-add100 : [BST Number] -&gt; [BST Number]
    ;; Adds 100 to all numbers in the BST.

    (define (bst-map f abst)
        (cond
          [(leaf? abst) (make-leaf)]
          [(node? abst) (make-node
                         (bst-map f  (node-left abst))
                         (node-key abst)
                         (f (node-value abst))
                         (bst-map f (node-right abst)))]))
</pre>
</details>
<h1 id="lecture-28---symbols-and-symbolic-expressions">Lecture 28 - Symbols and Symbolic Expressions</h1>

<p>Exam on Monday</p>

<ul>
  <li>Do quiz on Canvas to see what to do about Lecture that day</li>
</ul>

<p>Exam</p>

<ul>
  <li>Everything (including today‚Äôs lecture)</li>
  <li>Signature detection</li>
  <li>List abstraction
    <ul>
      <li>Foldr</li>
    </ul>
  </li>
  <li>Trees</li>
  <li>Mutual Recursion</li>
  <li>Most likely on Hourglass Server
    <ul>
      <li>Know by Thursday if it‚Äôs on handin or Hourglass</li>
    </ul>
  </li>
</ul>

<p>First Exam</p>

<ul>
  <li>Write a Data Definition ‚Üí Design a function</li>
</ul>

<h2 id="trees">Trees</h2>

<ul>
  <li>Multiple self-references</li>
  <li>Binary Search Trees
    <ul>
      <li>Multiple self-references by comparisons</li>
    </ul>
  </li>
</ul>

<h3 id="compilerinterpretor">Compiler/Interpretor</h3>

<ul>
  <li>A program that runs another program
    <ul>
      <li>Ex. DrRacket is an compiler/interpretor</li>
    </ul>
  </li>
  <li>What would the data definition for DrRacket be?
    <ul>
      <li>The programs that we feed into DrRacket (the code) is the data itself</li>
    </ul>
  </li>
</ul>

<h2 id="atomic-data">Atomic Data</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; An Atom is one of:</span>
<span class="c1">; - String</span>
<span class="c1">; - Number</span>
<span class="c1">; - Boolean</span>
<span class="c1">; - Symbol</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">atom-template</span> <span class="nv">a</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond</span>
		<span class="p">[(</span><span class="nb">string?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
		<span class="p">[(</span><span class="nb">number?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
		<span class="p">[(</span><span class="nb">boolean?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
		<span class="p">[(</span><span class="nb">symbol?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>

<span class="c1">; atom? : Any -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">atom?</span> <span class="nv">a</span><span class="p">)</span>
	<span class="p">(</span><span class="k">or</span>
		<span class="p">(</span><span class="nb">string?</span> <span class="nv">a</span><span class="p">)</span>
		<span class="p">(</span><span class="nb">number?</span> <span class="nv">a</span><span class="p">)</span>
		<span class="p">(</span><span class="nb">boolean?</span> <span class="nv">a</span><span class="p">)</span>
		<span class="p">(</span><span class="nb">symbol?</span> <span class="nv">a</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="symbols">Symbols</h3>

<ul>
  <li>Essentially a string that can‚Äôt have spaces
    <ul>
      <li>However, they have meaning to a computer</li>
    </ul>
  </li>
  <li>Denoted by a single <code class="language-plaintext highlighter-rouge">'</code> at the beginning
    <ul>
      <li>Shorthand for <code class="language-plaintext highlighter-rouge">(quote ...</code></li>
    </ul>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">symbol?</span> <span class="ss">'foo</span><span class="p">)</span> <span class="c1">; Returns #true</span>
<span class="p">(</span><span class="nf">symbol=?</span> <span class="ss">'foo</span> <span class="ss">'foo</span><span class="p">)</span> <span class="c1">; Returns #true</span>
</code></pre></div></div>

<ul>
  <li>Comparing two symbols is nearly instant (compared to strings were its dependent on its length)</li>
  <li>You can‚Äôt do normal string operations on symbols. You can only compare two symbols against each other</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">'45</span> <span class="c1">; Returns the number 45</span>
<span class="o">'</span><span class="s">"hello"</span> <span class="c1">; Returns the string "hello"</span>
<span class="o">'</span><span class="no">#t</span><span class="nv">rue</span> <span class="c1">; Returns the Boolean #true</span>
<span class="o">'</span><span class="s">"Hello"</span><span class="mi">5</span> <span class="c1">; Returns the String "Hello" and then the number 5</span>
<span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="s">"hi"</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span> <span class="c1">; Returns the list (list 1 2 "hi" #true).</span>
<span class="c1">; You can also nest lists by this (but don't nest the quote)</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="no">#t</span><span class="nv">rue</span> <span class="s">"hello"</span> <span class="s">"again"</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
<span class="c1">; Returns (list 1 2 3 4 #true "hello" "again" 'x 'y 'z)</span>
</code></pre></div></div>

<h3 id="program-representation">Program Representation</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">'</span><span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; Looks similar to a program that ISL can run.</span>
<span class="c1">; This list represents a program</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">'</span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span> <span class="nv">x</span><span class="p">))</span>
<span class="c1">; Returns (list 'define (list 'f 'x) (list '+ 2 3 'x))</span>
<span class="c1">; Represents the program : (define (f x) (+ 2 3 x))</span>
</code></pre></div></div>

<h3 id="data-definition-1">Data Definition</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; A *symbolic expression* (SExpr) is one of:</span>
<span class="c1">; - Atom</span>
<span class="c1">; - LOS</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sexpr-template</span> <span class="nv">sexp</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond</span>
		<span class="p">[(</span><span class="nf">atom?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">atom-template</span> <span class="p">(</span><span class="nf">sexp</span><span class="p">)]</span>
		<span class="p">[(</span><span class="nb">list?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">los-template</span> <span class="nv">sexp</span><span class="p">)]))</span>

<span class="c1">; A *list of SExprs* (LOS) is a [List-of SExpr]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">los-template</span> <span class="nv">los</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond</span>
		<span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
		<span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">sexpr-template</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">))</span> <span class="o">...</span>
											<span class="p">(</span><span class="nf">los-template</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>

<span class="c1">;; Alternate Defintion:</span>

<span class="c1">; A *symbolic expression* (SExpr) is one of:</span>
<span class="c1">; - Atom</span>
<span class="c1">; - [List-of SExpr]</span>
</code></pre></div></div>

<ul>
  <li>These three data definitions (including Atom) is a complete representation of programs</li>
  <li>NOTE: SExpr and LOS are mutually self referential</li>
  <li><code class="language-plaintext highlighter-rouge">SExpr</code> are just trees</li>
</ul>

<h3 id="examples">Examples</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-1</span> <span class="ss">'x</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-2</span> <span class="o">'</span><span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-2/v2</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-3</span> <span class="o">'</span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">F</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="example-problems">Example Problems</h3>

<p><strong>All-Atoms</strong></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Problem: Write a function to produce a list of all the atoms in an</span>
<span class="c1">;; S-expression.</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">all-atoms</span> <span class="nv">ex-sexpr-3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'define</span> <span class="ss">'F</span> <span class="ss">'x</span> <span class="ss">'+</span> <span class="ss">'x</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1">;; all-atoms : SExpr -&gt; [List-of Atom]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">all-atoms</span> <span class="nv">sexp</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">atom?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">sexp</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">list?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">los-all-atoms</span> <span class="nv">sexp</span><span class="p">)]))</span>

<span class="c1">;; los-all-atoms : LOS -&gt; [List-of Atom]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">los-all-atoms</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nf">all-atoms</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">los-all-atoms</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">)))]))</span>

<span class="c1">;; Problem (definitely do this): use list abstractions to solve the problem above</span>

<span class="c1">;; Problem: Write a function that concatenates all strings in an S-experssion</span>
<span class="c1">;; into a single string.</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">atom-join-strings</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string?</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">a</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">number?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">boolean?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">symbol?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">join-strings</span> <span class="nv">sexp</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">atom?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">atom-join-strings</span> <span class="nv">sexp</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">list?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">los-join-strings</span> <span class="nv">sexp</span><span class="p">)]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">los-join-strings</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">join-strings</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">))</span> <span class="o">...</span>
                      <span class="p">(</span><span class="nf">los-join-strings</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ; symbol?

    ;; An Atom is one of:
    ;; - String
    ;; - Number
    ;; - Boolean
    ;; - Symbol

    ;; atom? : Any -&gt; Boolean
    (define (atom? a)
      (or (string? a) (number? a) (boolean? a) (symbol? a)))

    ;; A *symbolic expression* (SExpr) is one of:
    ;; - Atom
    ;; - LOS

    ;; A *list of SExprs* (LOS) is a [List-of SExpr]

    (define (atom-template a)
      (cond
        [(string? a) ...]
        [(number? a) ...]
        [(boolean? a) ...]
        [(symbol? a) ...]))

    (define (sexpr-template sexp)
      (cond
        [(atom? sexp) (atom-template sexp)]
        [(list? sexp) (los-template sexp)]))

    (define (los-template los)
      (cond
        [(empty? los) ...]
        [(cons? los) (... (sexpr-template (first los)) ...
                          (los-template (rest los)) ...)]))

    ;; Alternative definition:
    ;; A *symbolic expression* (SExpr) is one of:
    ;; - Atom
    ;; - [List-of SExpr]

    ;; Examples of SExprs
    (define ex-sexpr-1 'x)
    (define ex-sexpr-2 '(+ 1 2 3))
    (define ex-sexpr-2/v2 (list '+ 1 2 3))
    (define ex-sexpr-3 '(define (F x) (+ x 10)))
    (define ex-sexpr-4 '("+" 1 2 3))

    ;; Problem: Write a function to produce a list of all the atoms in an
    ;; S-expression.

    (check-expect (all-atoms ex-sexpr-3) (list 'define 'F 'x '+ 'x 10))

    ;; all-atoms : SExpr -&gt; [List-of Atom]
    (define (all-atoms sexp)
      (cond
        [(atom? sexp) (list sexp)]
        [(list? sexp) (los-all-atoms sexp)]))

    ;; los-all-atoms : LOS -&gt; [List-of Atom]
    (define (los-all-atoms los)
      (cond
        [(empty? los) '()]
        [(cons? los) (append (all-atoms (first los))
                             (los-all-atoms (rest los)))]))

    ;; Problem (definitely do this): use list abstractions to solve the problem above

    ;; Problem: Write a function that concatenates all strings in an S-experssion
    ;; into a single string.

    (define (atom-join-strings a)
      (cond
        [(string? a) a]
        [(number? a) ...]
        [(boolean? a) ...]
        [(symbol? a) ...]))

    (define (join-strings sexp)
      (cond
        [(atom? sexp) (atom-join-strings sexp)]
        [(list? sexp) (los-join-strings sexp)]))

    (define (los-join-strings los)
      (cond
        [(empty? los) ...]
        [(cons? los) (... (join-strings (first los)) ...
                          (los-join-strings (rest los)) ...)]))
</pre>
</details>
<h1 id="lecture-29---more-on-symbolic-expression-and-templates">Lecture 29 - More on Symbolic Expression and Templates</h1>

<p>2 more homework assignments (after this one)</p>

<h2 id="symbolic-expression-sexpr">Symbolic Expression (SExpr)</h2>

<ul>
  <li>Atomic Data
    <ul>
      <li>String</li>
      <li>Number</li>
      <li>Boolean</li>
      <li>Symbol</li>
    </ul>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A *list of SExprs* (LOS) is a [List-of SExpr]</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">atom-template</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nb">string?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">number?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">boolean?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">symbol?</span> <span class="nv">a</span><span class="p">)</span> <span class="o">...</span><span class="p">]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sexpr-template</span> <span class="nv">sexp</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">atom?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">atom-template</span> <span class="nv">sexp</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">list?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">los-template</span> <span class="nv">sexp</span><span class="p">)]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">los-template</span> <span class="nv">los</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span> <span class="p">(</span><span class="nf">sexpr-template</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">))</span> <span class="o">...</span>
                      <span class="p">(</span><span class="nf">los-template</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">))</span> <span class="o">...</span><span class="p">)]))</span>

<span class="c1">;; Examples of SExprs</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-1</span> <span class="ss">'x</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-2</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-3</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'define</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'F</span> <span class="ss">'x</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'+</span> <span class="ss">'x</span> <span class="mi">10</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-4</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'x</span> <span class="mi">20</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'y</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">'z</span> <span class="mi">40</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="example---replace-instances-of-s-expr-and-replace-it">Example - Replace Instances of S-Expr and replace it</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">replace-symbol</span> <span class="o">'</span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span> <span class="ss">'x</span> <span class="mi">500</span><span class="p">)</span> <span class="o">'</span><span class="p">(</span><span class="nf">500</span> <span class="nv">y</span> <span class="nv">z</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">replace-symbol</span> <span class="o">'</span><span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">'x</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span> <span class="o">'</span><span class="p">(</span><span class="no">#t</span><span class="nv">rue</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">replace-symbol</span> <span class="o">'</span><span class="p">(</span><span class="nf">y</span> <span class="nv">z</span><span class="p">)</span> <span class="ss">'x</span> <span class="mi">50</span><span class="p">)</span> <span class="o">'</span><span class="p">(</span><span class="nf">y</span> <span class="nv">z</span><span class="p">))</span>

<span class="c1">;; replace-symbol : SExpr Symbol SExpr -&gt; SExpr</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">replace-symbol</span> <span class="nv">sexp</span> <span class="nv">symbol</span> <span class="nv">new-sexpr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">atom?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">replace-symbol-atom</span> <span class="nv">sexp</span> <span class="nv">symbol</span> <span class="nv">new-sexpr</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">list?</span> <span class="nv">sexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">replace-symbol-los</span> <span class="nv">sexp</span> <span class="nv">symbol</span> <span class="nv">new-sexpr</span><span class="p">)]))</span>

<span class="c1">;; replace-symbol-los : LOS Symbol SExpr -&gt; LOS</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">replace-symbol-los</span> <span class="nv">los</span>  <span class="nv">symbol</span> <span class="nv">new-sexpr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">los</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">los</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">replace-symbol</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">los</span><span class="p">)</span>  <span class="nv">symbol</span> <span class="nv">new-sexpr</span><span class="p">)</span>
                      <span class="p">(</span><span class="nf">replace-symbol-los</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">los</span><span class="p">)</span>  <span class="nv">symbol</span> <span class="nv">new-sexpr</span><span class="p">))]))</span>

<span class="c1">;; replace-symbol-atom : Atom Symbol SExpr -&gt; SExpr</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">replace-symbol-atom</span> <span class="nv">a</span> <span class="nv">symbol</span> <span class="nv">new-sexpr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">symbol?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">symbol=?</span> <span class="nv">a</span> <span class="nv">symbol</span><span class="p">))</span>
      <span class="nv">new-sexpr</span>
      <span class="nv">a</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-sexpr-5</span> <span class="o">'</span><span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">y</span> <span class="mi">20</span><span class="p">)))</span>
</code></pre></div></div>

<ul>
  <li>Challenge Round:
    <ul>
      <li>Create a calculator using S-Expr that compiles to ISL</li>
      <li>Assume only +, *, -, / and all of the atoms are numbers</li>
    </ul>
  </li>
</ul>

<h2 id="3-templates">3 Templates</h2>

<h3 id="parallel-traveral">Parallel Traveral</h3>

<p>Template:</p>

<h3 id="my-append">my-append</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-append : {X} . [List-of X] [List-of X] -&gt; [List-of X]</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">my-append</span> <span class="o">'</span><span class="p">()</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">my-append</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">)</span> <span class="o">'</span><span class="p">())</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">my-append</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">my-append</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="o">'</span><span class="p">())))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">my-append</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="o">'</span><span class="p">()))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">)))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nf">my-append</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="o">'</span><span class="p">())</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="p">(</span><span class="nf">my-append</span> <span class="o">'</span><span class="p">()</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">)))))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="add-pairs">add-pairs</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add-pairs : [List-of Number] [List-of Number] -&gt; [List-of Number]</span>
<span class="c1">;; Constraints: the two lists have the same length.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-pairs</span> <span class="nv">alist</span> <span class="nv">blist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">blist</span><span class="p">))</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">blist</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">blist</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">add-pairs</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">blist</span><span class="p">)))]))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add-pairs</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">11</span> <span class="mi">22</span> <span class="mi">33</span><span class="p">))</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">add-pairs</span> <span class="o">'</span><span class="p">()</span> <span class="o">'</span><span class="p">())</span> <span class="o">'</span><span class="p">())</span>
</code></pre></div></div>

<h3 id="list">list=?</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">list=?</span> <span class="nv">alist</span> <span class="nv">blist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">blist</span><span class="p">))</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">blist</span><span class="p">))</span>
     <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">blist</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">list=?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">blist</span><span class="p">)))]</span>
    <span class="o">#</span><span class="c1">;[(and (cons? alist) (cons? blist))</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">blist</span><span class="p">))</span>
         <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">blist</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">list=?</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">blist</span><span class="p">)))</span>
         <span class="no">#f</span><span class="nv">alse</span><span class="p">)]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">blist</span><span class="p">))</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">blist</span><span class="p">))</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; From last lecture

    ;; An Atom is one of:
    ;; - String
    ;; - Number
    ;; - Boolean
    ;; - Symbol

    ;; atom? : Any -&gt; Boolean
    (define (atom? a)
      (or (string? a) (number? a) (boolean? a) (symbol? a)))

    ;; A *symbolic expression* (SExpr) is one of:
    ;; - Atom
    ;; - LOS

    ;; A *list of SExprs* (LOS) is a [List-of SExpr]

    (define (atom-template a)
      (cond
        [(string? a) ...]
        [(number? a) ...]
        [(boolean? a) ...]
        [(symbol? a) ...]))

    (define (sexpr-template sexp)
      (cond
        [(atom? sexp) (atom-template sexp)]
        [(list? sexp) (los-template sexp)]))

    (define (los-template los)
      (cond
        [(empty? los) ...]
        [(cons? los) (... (sexpr-template (first los)) ...
                          (los-template (rest los)) ...)]))

    ;; Examples of SExprs
    (define ex-sexpr-1 'x)
    (define ex-sexpr-2 (list '+ 1 2 3))
    (define ex-sexpr-3 (list 'define (list 'F 'x) (list '+ 'x 10)))
    (define ex-sexpr-4 (list (list 'x 20) (list 'y 30) (list 'z 40)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; Problem: design a function that replaces all occurences of a symbol in an
    ;; S-expression with another given S-expression.

    (check-expect (replace-symbol '(x y z 10 20) 'x 500) '(500 y z 10 20))
    (check-expect (replace-symbol '(x x) 'x #true) '(#true #true))
    (check-expect (replace-symbol '(y z) 'x 50) '(y z))

    ;; replace-symbol : SExpr Symbol SExpr -&gt; SExpr
    (define (replace-symbol sexp symbol new-sexpr)
      (cond
        [(atom? sexp) (replace-symbol-atom sexp symbol new-sexpr)]
        [(list? sexp) (replace-symbol-los sexp symbol new-sexpr)]))

    ;; replace-symbol-los : LOS Symbol SExpr -&gt; LOS
    (define (replace-symbol-los los  symbol new-sexpr)
      (cond
        [(empty? los) '()]
        [(cons? los) (cons (replace-symbol (first los)  symbol new-sexpr)
                          (replace-symbol-los (rest los)  symbol new-sexpr))]))

    ;; replace-symbol-atom : Atom Symbol SExpr -&gt; SExpr
    (define (replace-symbol-atom a symbol new-sexpr)
      (if (and (symbol? a) (symbol=? a symbol))
          new-sexpr
          a))

    (define ex-sexpr-5 '(+ x 10 (* y 20)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; my-append : {X} . [List-of X] [List-of X] -&gt; [List-of X]

    (check-expect (my-append '() (list 40 50)) (list 40 50))
    (check-expect (my-append (list 40 50) '()) (list 40 50))
    (check-expect (my-append (list 10 20 30) (list 40 50)) (list 10 20 30 40 50))
    (check-expect (my-append (cons 10 (cons 20 (cons 30 '()))) (list 40 50)) (list 10 20 30 40 50))

    (check-expect (cons 10 (my-append (cons 20 (cons 30 '())) (list 40 50))) (list 10 20 30 40 50))

    (check-expect (cons 10 (cons 20 (my-append (cons 30 '()) (list 40 50)))) (list 10 20 30 40 50))

    (check-expect (cons 10 (cons 20 (cons 30 (my-append '() (list 40 50))))) (list 10 20 30 40 50))

    ;; add-pairs : [List-of Number] [List-of Number] -&gt; [List-of Number]
    ;; Constraints: the two lists have the same length.
    (define (add-pairs alist blist)
      (cond
        [(and (empty? alist) (empty? blist)) '()]
        [(and (cons? alist) (cons? blist))
         (cons (+ (first alist) (first blist))
               (add-pairs (rest alist) (rest blist)))]))

    (check-expect (add-pairs (list 10 20 30) (list 1 2 3)) (list 11 22 33))
    (check-expect (add-pairs '() '()) '())
    ; (check-expect (add-pairs (list 10 20 30) (list 5 1000)) (list 15 1020 1030))
    ; (check-expect (add-pairs (list 10 20 30) (list 5)) (list 15))
    (check-error (add-pairs (list 10 20 30) (list 5)))

    #;(define (parallel-template alist blist)
        (cond
          [(and (empty? alist) (empty? blist)) ...]
          [(and (cons? alist) (cons? blist))
           (... (first alist) ... (first blist) ...
               (parallel-template (rest alist) (rest blist)))]))

    ;; list=? : {X} . [List-of X] [List-of X] -&gt; Boolean

    (check-expect (list=? (list 10 20) (list 10 20)) #true)
    (check-expect (list=? (list 10 20) (list 10 20 30)) #false)
    (check-expect (list=? '() '()) #true)
    (check-expect (list=? (cons 10 '()) '()) #false)

    (define (list=? alist blist)
      (cond
        [(and (empty? alist) (empty? blist)) #true]
        [(and (cons? alist) (cons? blist))
         (and (= (first alist) (first blist))
              (list=? (rest alist) (rest blist)))]
        #;[(and (cons? alist) (cons? blist))
         (if (= (length alist) (length blist))
             (and (= (first alist) (first blist))
                  (list=? (rest alist) (rest blist)))
             #false)]
        [(and (cons? alist) (empty? blist)) #false]
        [(and (empty? alist) (cons? blist)) #false]))
</pre>
</details>
<h1 id="lecture-30---parallel-and-black-box-traversial">Lecture 30 - Parallel and Black-Box Traversial</h1>

<p>Recall the templates from Lecture 29.</p>

<h3 id="my-append-1"><code class="language-plaintext highlighter-rouge">my-append</code></h3>

<ul>
  <li>black-box traversial (don‚Äôt change <code class="language-plaintext highlighter-rouge">blist</code>. As opposed to parallel traversial)</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-append</span> <span class="nv">alist</span> <span class="nv">blist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">blist</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">my-append</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">blist</span><span class="p">))]))</span>
</code></pre></div></div>

<p>But if <code class="language-plaintext highlighter-rouge">blist</code> doesn‚Äôt change, how can we optimize this so it doesn‚Äôt take in <code class="language-plaintext highlighter-rouge">blist</code>?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-append : {X} . [List-of X] [List-of X] -&gt; [List-of X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-append/v3</span> <span class="nv">alist</span> <span class="nv">blist</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">(</span><span class="c1">;; helper : [List-of X] -&gt; [List-of X]</span>
          <span class="p">[</span><span class="k">define</span> <span class="p">(</span><span class="nf">helper</span> <span class="nv">l</span><span class="p">)</span>
            <span class="p">(</span><span class="k">cond</span>
              <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">l</span><span class="p">)</span> <span class="nv">blist</span><span class="p">]</span>
              <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">helper</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">l</span><span class="p">)))])])</span>
    <span class="p">(</span><span class="nf">helper</span> <span class="nv">alist</span><span class="p">)))</span>
</code></pre></div></div>

<ul>
  <li>Recursion can happen in a helper function as well</li>
</ul>

<p>Challenge: use a list abstraction for the definition of <code class="language-plaintext highlighter-rouge">my-append</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-append/v2</span> <span class="nv">l1</span> <span class="nv">l2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">foldr</span> <span class="nv">cons</span> <span class="nv">l2</span> <span class="nv">l1</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="list-ref">List-ref</h3>

<p><code class="language-plaintext highlighter-rouge">list-ref</code> - Returns the nth element of a list</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">list-ref</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; Returns 10</span>
</code></pre></div></div>

<ul>
  <li>Natrual means positive integer that include 0</li>
</ul>

<h3 id="my-list-ref"><code class="language-plaintext highlighter-rouge">my-list-ref</code></h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-list-ref : [List-of X] Nat -&gt; X</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-list-ref/v1</span> <span class="nv">alist</span> <span class="nv">index</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">index</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">my-list-ref/v1</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">index</span> <span class="mi">1</span><span class="p">))))</span>
</code></pre></div></div>

<p>What are different ways of writing this function? Can we write this with parallel traversial?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-list-ref/v2</span> <span class="nv">alist</span> <span class="nv">index</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"invalid index"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nb">zero?</span> <span class="nv">index</span><span class="p">))</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">my-list-ref/v2</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">index</span> <span class="mi">1</span><span class="p">))]))</span>
</code></pre></div></div>

<h3 id="list-1"><code class="language-plaintext highlighter-rouge">list=?</code></h3>

<p>Making a more general definition of <code class="language-plaintext highlighter-rouge">list=?</code> (because the previous definition only compared numbers)</p>

<ul>
  <li>Combines both parallel traversial and black-box traversial</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; list=? : {X} . (X X -&gt; Boolean) [List-of X] [List-of X] -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">list=?</span> <span class="nv">compare</span> <span class="nv">alist</span> <span class="nv">blist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">blist</span><span class="p">))</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">blist</span><span class="p">))</span>
     <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nf">compare</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">blist</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">list=?</span> <span class="nv">compare</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">blist</span><span class="p">)))]</span>
    <span class="p">[</span><span class="k">else</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]))</span>
</code></pre></div></div>

<ul>
  <li>You can also write this function using list abstractions
    <h1 id="lecture-31---optional-lecture-on-trees">Lecture 31 - Optional Lecture on Trees</h1>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">person</span> <span class="p">[</span><span class="nf">name</span> <span class="nv">father</span> <span class="nv">mother</span><span class="p">])</span>
<span class="c1">;; An FT (family tree) is one of:</span>
<span class="c1">;; - 'none</span>
<span class="c1">;; - (make-person String FT FT)</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: A family tree is either:</span>
<span class="c1">;; - _'none, which indicates that this ancestor is unknown</span>
<span class="c1">;; - _(make-person name father mother)_ which represents _name_ on the family</span>
<span class="c1">;;   tree, with _mother_ as the family tree of _name_'s mother, and _father_</span>
<span class="c1">;;   as the family tree of their father.</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-qe2-ancestors</span>
  <span class="p">(</span><span class="nf">make-person</span> <span class="s">"QE2"</span>
               <span class="p">(</span><span class="nf">make-person</span> <span class="s">"George VI"</span> <span class="ss">'none</span> <span class="ss">'none</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">make-person</span> <span class="s">"Elizabeth BL"</span> <span class="ss">'none</span> <span class="ss">'none</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ex-royalty</span>
  <span class="p">(</span><span class="nf">make-person</span> <span class="s">"William"</span>
               <span class="p">(</span><span class="nf">make-person</span> <span class="s">"Charles"</span>
                            <span class="p">(</span><span class="nf">make-person</span> <span class="s">"Philip"</span> <span class="ss">'none</span> <span class="ss">'none</span><span class="p">)</span>
                            <span class="nv">ex-qe2-ancestors</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">make-person</span> <span class="s">"Diana"</span> <span class="ss">'none</span> <span class="ss">'none</span><span class="p">)))</span>

<span class="c1">;; ft=? : FT FT -&gt; Boolean</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ft=?</span> <span class="nv">ft1</span> <span class="nv">ft2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">person?</span> <span class="nv">ft1</span><span class="p">)</span> <span class="p">(</span><span class="nf">person?</span> <span class="nv">ft2</span><span class="p">))</span>
     <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">string=?</span> <span class="p">(</span><span class="nf">person-name</span> <span class="nv">ft1</span><span class="p">)</span> <span class="p">(</span><span class="nf">person-name</span> <span class="nv">ft2</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">ft=?</span> <span class="p">(</span><span class="nf">person-father</span> <span class="nv">ft1</span><span class="p">)</span> <span class="p">(</span><span class="nf">person-father</span> <span class="nv">ft2</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">ft=?</span> <span class="p">(</span><span class="nf">person-mother</span> <span class="nv">ft1</span><span class="p">)</span> <span class="p">(</span><span class="nf">person-mother</span> <span class="nv">ft2</span><span class="p">)))]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">symbol?</span> <span class="nv">ft1</span><span class="p">)</span> <span class="p">(</span><span class="nf">symbol=?</span> <span class="nv">ft1</span> <span class="ss">'none</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">symbol?</span> <span class="nv">ft2</span><span class="p">)</span> <span class="p">(</span><span class="nf">symbol=?</span> <span class="nv">ft2</span> <span class="ss">'none</span><span class="p">))</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
    <span class="p">[</span><span class="k">else</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">]))</span>
    <span class="c1">;[(and (person? ft1) (symbol? ft2) (symbol=? ft2 'none)) #false]</span>
    <span class="c1">;[(and (symbol? ft1) (symbol=? ft1 'none) (person? ft2)) #false]))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">ft=?</span> <span class="nv">ex-royalty</span> <span class="nv">ex-royalty</span><span class="p">)</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">ft=?</span> <span class="nv">ex-royalty</span> <span class="nv">ex-qe2-ancestors</span><span class="p">)</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span>

<span class="c1">;; An Ancestor is either</span>
<span class="c1">;; - "mother"</span>
<span class="c1">;; - "father"</span>
<span class="c1">;; An AP (Ancestor Path) is a [List-of Ancestor]</span>

<span class="c1">;; find-ancestor : FT AP -&gt; String</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">find-ancestor</span> <span class="nv">ft</span> <span class="nv">ap</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">person?</span> <span class="nv">ft</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">ap</span><span class="p">))</span> <span class="p">(</span><span class="nf">person-name</span> <span class="nv">ft</span><span class="p">)]</span>
    <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nf">person?</span> <span class="nv">ft</span><span class="p">)</span> <span class="p">(</span><span class="nf">cons?</span> <span class="nv">ap</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=?</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">ap</span><span class="p">)</span> <span class="s">"father"</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">find-ancestor</span> <span class="p">(</span><span class="nf">person-father</span> <span class="nv">ft</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">ap</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">find-ancestor</span> <span class="p">(</span><span class="nf">person-mother</span> <span class="nv">ft</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">ap</span><span class="p">)))]</span>
    <span class="p">[</span><span class="k">else</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"dunno"</span><span class="p">)]))</span>
    <span class="c1">;[(and (symbol=? ft 'none) (empty? ap)) (error "dunno")]</span>
    <span class="c1">;[(and (symbol=? ft 'none) (cons? ap)) (error "dunno")]))</span>


<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">find-ancestor</span> <span class="nv">ex-royalty</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"father"</span> <span class="s">"mother"</span><span class="p">))</span>
              <span class="s">"QE2"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">find-ancestor</span> <span class="nv">ex-royalty</span>
                             <span class="p">(</span><span class="nb">list</span> <span class="s">"father"</span> <span class="s">"mother"</span> <span class="s">"mother"</span><span class="p">))</span>
              <span class="s">"Elizabeth BL"</span><span class="p">)</span>

<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">node</span> <span class="p">(</span><span class="nf">name</span> <span class="nv">following</span><span class="p">))</span>

<span class="c1">;; A Twitter graph is a:</span>
<span class="c1">;; [List-of (make-node String [List-of String])]</span>
<span class="c1">;; CONSTRAINT: Any follower is an actual node in the graph</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-twitter-1</span>
  <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">make-node</span> <span class="s">"A"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"D"</span> <span class="s">"E"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"B"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"D"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"C"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"A"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"D"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"B"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"E"</span> <span class="nv">empty</span><span class="p">)))</span>
</code></pre></div></div>
<h1 id="lecture-32---accumulators-and-graphs">Lecture 32 - Accumulators and Graphs</h1>

<p>Material that is talked about on Monday and Wednesday is not going to be graded so he can talk about anything we want.</p>

<p>Things we are going to talk about next week</p>

<ul>
  <li>Operating systems</li>
  <li>Machine learning</li>
</ul>

<p>Grades will be back by (at least) Friday</p>

<p>One more assignment left</p>

<ul>
  <li>Covers what are doing in class today</li>
</ul>

<h3 id="mondays-lecture">Monday‚Äôs Lecture</h3>

<ul>
  <li>Parallel traversial</li>
  <li>Graphs</li>
</ul>

<h2 id="accumulators">Accumulators</h2>

<p>Return the list of sums of numbers up to a certain point in a list</p>

<p>Make a helper function</p>

<ul>
  <li>lets forget about list abstractions</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; sum-to : [List-of Number] -&gt; [List-of Number]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sum-to</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">modified-sum-to</span> <span class="mi">0</span> <span class="nv">lon</span><span class="p">))</span>

<span class="c1">;; sum-so-far is the *accumulator*</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">modified-sum-to</span> <span class="nv">sum-so-far</span> <span class="nv">lon</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">lon</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">lon</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">local</span> <span class="p">([</span><span class="k">define</span> <span class="nv">new-sum-so-far</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">sum-so-far</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">lon</span><span class="p">))])</span>
       <span class="p">(</span><span class="nb">cons</span> <span class="nv">new-sum-so-far</span>
             <span class="p">(</span><span class="nf">modified-sum-to</span> <span class="nv">new-sum-so-far</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">lon</span><span class="p">))))]))</span>
</code></pre></div></div>

<p><strong>sum-so-far is the accumulator</strong></p>

<ul>
  <li>Notice that adding a new argument would make things easier
    <ul>
      <li>And then you just initialize the accumulator to 0 in the main function</li>
    </ul>
  </li>
</ul>

<p>Challenge: solve-to using list template and no helper function</p>

<ul>
  <li>This solution is more complicated and is less efficent</li>
</ul>

<h2 id="graphs-or-network">Graphs (or network)</h2>

<h3 id="trees-1">Trees</h3>

<ul>
  <li>Cannot jump to different levels. Hierarchy</li>
</ul>

<p>‚ÄúIf you can work with trees, your life is relatively easy‚Äù - Arjun</p>

<ul>
  <li>Unlike trees, graphs can cycle back to any point
    <ul>
      <li>Ex. roads, social media, etc.</li>
    </ul>
  </li>
  <li><strong>Directed Graphs</strong>
    <ul>
      <li>Only one direction is viable</li>
      <li>ex. Twitter - ‚ÄúI can choose to follow you, you don‚Äôt have to follow me back‚Äù</li>
    </ul>
  </li>
  <li><strong>Undirected Graphs</strong>
    <ul>
      <li>Needs to be able to go both ways</li>
      <li>ex. Facebook  - ‚ÄúNeeds to be friends with each other‚Äù</li>
    </ul>
  </li>
</ul>

<p><strong>Edges</strong> - Arrows between people</p>

<p><strong>Nodes</strong> - The people themselves (or vertices)</p>

<p><strong>Neighbors</strong> <em>-</em> Nodes that are immediately adjacent</p>

<h3 id="turning-this-idea-into-code">Turning this idea into code:</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">node</span> <span class="p">[</span><span class="nf">name</span> <span class="nv">neighbors</span><span class="p">])</span>

<span class="c1">;; A [Graph X] is a [List-of [Node X]]</span>
<span class="c1">;; A [Node X] is a (make-node X [List-of X])</span>
<span class="c1">;;</span>
<span class="c1">;; Interpretation: [Graph X] represents a graph, with nodes labelled X.</span>
<span class="c1">;;</span>
<span class="c1">;; For each node:</span>
<span class="c1">;;</span>
<span class="c1">;; 1. _(make-node x (list y-1 ... y-n))_, the graph has the edges from _x_ to</span>
<span class="c1">;;    _y-1_, ..., and from _x_ to _y-n_.</span>
<span class="c1">;;</span>
<span class="c1">;; 2. There must be nodes labelled _y-1_, ..., _y-n_ in the graph.</span>
<span class="c1">;;</span>
<span class="c1">;; Finally, all node labels must be unique.</span>

<span class="c1">;; [Graph String]</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-social</span>
  <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">make-node</span> <span class="s">"Alice"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Bob"</span> <span class="s">"Carol"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"Bob"</span> <span class="p">(</span><span class="nb">list</span>  <span class="s">"Carol"</span> <span class="s">"David"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"Carol"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Emma"</span> <span class="s">"David"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"David"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Frank"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"Emma"</span> <span class="p">(</span><span class="nb">list</span> <span class="s">"Alice"</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">make-node</span> <span class="s">"Frank"</span> <span class="o">'</span><span class="p">())))</span>
</code></pre></div></div>

<ul>
  <li>
    <p>This isn‚Äôt as easy as trees because a subsection of a graph is not just a part of the bigger tree (think recursion)</p>
  </li>
  <li>
    <p>This question about getting paths from graphs is very common in computer science</p>
  </li>
  <li>
    <p>Keep an accumulator of the neighbors that we have already been to</p>
  </li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">person</span> <span class="p">[</span><span class="nf">name</span> <span class="nv">mother</span> <span class="nv">father</span><span class="p">])</span>
<span class="c1">;; A FamilyTree is a:</span>
<span class="c1">;; - (make-person String Person Person)</span>
<span class="c1">;; - #false</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-ft</span> <span class="p">(</span><span class="nf">make-person</span> <span class="s">"Alice"</span>
                           <span class="p">(</span><span class="nf">make-person</span> <span class="s">"Bob"</span> <span class="no">#f</span><span class="nv">alse</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span>
                           <span class="p">(</span><span class="nf">make-person</span> <span class="s">"Carol"</span>
                                        <span class="p">(</span><span class="nf">make-person</span> <span class="s">"David"</span> <span class="no">#f</span><span class="nv">alse</span> <span class="no">#f</span><span class="nv">alse</span><span class="p">)</span>
                                        <span class="no">#f</span><span class="nv">alse</span><span class="p">)))</span>

<span class="c1">;; neighbors-of : [Graph String] String -&gt; [List-of String]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">neighbors-of</span> <span class="nv">g</span> <span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">g</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"not a node"</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">g</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=?</span> <span class="nv">name</span> <span class="p">(</span><span class="nf">node-name</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">g</span><span class="p">)))</span>
                   <span class="p">(</span><span class="nf">node-neighbors</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">g</span><span class="p">))</span>
                   <span class="p">(</span><span class="nf">neighbors-of</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">g</span><span class="p">)</span> <span class="nv">name</span><span class="p">))]))</span>


<span class="c1">;; path? : [List-of X] [Graph X] X X -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">path-helper</span> <span class="nv">visited</span> <span class="nv">g</span> <span class="nv">src</span> <span class="nv">dst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="c1">;[(member? src visited) #false]</span>
    <span class="p">[(</span><span class="nf">member?</span> <span class="nv">dst</span> <span class="p">(</span><span class="nf">neighbors-of</span> <span class="nv">g</span> <span class="nv">src</span><span class="p">))</span> <span class="no">#t</span><span class="nv">rue</span><span class="p">]</span>
    <span class="p">[</span><span class="k">else</span>
     <span class="p">(</span><span class="nf">ormap</span>
      <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">src-neighbor</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">path-helper</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">src</span> <span class="nv">visited</span><span class="p">)</span> <span class="nv">g</span> <span class="nv">src-neighbor</span> <span class="nv">dst</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">neighbors-of</span> <span class="nv">g</span> <span class="nv">src</span><span class="p">))]))</span>

<span class="c1">;; path? : [Graph X] X X -&gt; Boolean</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">path?</span> <span class="nv">g</span> <span class="nv">src</span> <span class="nv">dst</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">path-helper</span> <span class="o">'</span><span class="p">()</span> <span class="nv">g</span> <span class="nv">src</span> <span class="nv">dst</span><span class="p">))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    ;; Problem: Design a function that consumes a list of numbers
    ;; and produces a list of numbers, where each number in the output
    ;; is the corresponding number in the input, added to all the preceding
    ;; numbers in the input.

    ;; sum-to : [List-of Number] -&gt; [List-of Number]
    (define (sum-to lon)
      (modified-sum-to 0 lon))

    ;; sum-so-far is the *accumulator*
    (define (modified-sum-to sum-so-far lon)
      (cond
        [(empty? lon) '()]
        [(cons? lon)
         (local ([define new-sum-so-far (+ sum-so-far (first lon))])
           (cons new-sum-so-far
                 (modified-sum-to new-sum-so-far (rest lon))))]))

    ;; Challenge: Solve sum-to using list template and *no helper
    ;; function*.

    (check-expect (sum-to '(5 1 6 9)) '(5 6 12 21))

    (define-struct node [name neighbors])

    ;; A [Graph X] is a [List-of [Node X]]
    ;; A [Node X] is a (make-node X [List-of X])
    ;;
    ;; Interpretation: [Graph X] represents a graph, with nodes labelled X.
    ;;
    ;; For each node:
    ;;
    ;; 1. _(make-node x (list y-1 ... y-n))_, the graph has the edges from _x_ to
    ;;    _y-1_, ..., and from _x_ to _y-n_.
    ;;
    ;; 2. There must be nodes labelled _y-1_, ..., _y-n_ in the graph.
    ;;
    ;; Finally, all node labels must be unique.

    ;; [Graph String]

    (define ex-social
      (list (make-node "Alice" (list "Bob" "Carol"))
            (make-node "Bob" (list  "Carol" "David"))
            (make-node "Carol" (list "Emma" "David"))
            (make-node "David" (list "Frank"))
            (make-node "Emma" (list "Alice"))
            (make-node "Frank" '())))

    (define-struct person [name mother father])
    ;; A FamilyTree is a:
    ;; - (make-person String Person Person)
    ;; - #false

    (define ex-ft (make-person "Alice"
                               (make-person "Bob" #false #false)
                               (make-person "Carol"
                                            (make-person "David" #false #false)
                                            #false)))

    ;; neighbors-of : [Graph String] String -&gt; [List-of String]
    (define (neighbors-of g name)
      (cond
        [(empty? g) (error "not a node")]
        [(cons? g) (if (string=? name (node-name (first g)))
                       (node-neighbors (first g))
                       (neighbors-of (rest g) name))]))


    ;; path? : [List-of X] [Graph X] X X -&gt; Boolean
    (define (path-helper visited g src dst)
      (cond
        ;[(member? src visited) #false]
        [(member? dst (neighbors-of g src)) #true]
        [else
         (ormap
          (lambda (src-neighbor)
            (path-helper (cons src visited) g src-neighbor dst))
          (neighbors-of g src))]))

    ;; path? : [Graph X] X X -&gt; Boolean
    (define (path? g src dst)
      (path-helper '() g src dst))
</pre>
</details>
<h1 id="lecture-33---accumulators">Lecture 33 - Accumulators</h1>

<p>Exam will be returned tomorrow morning</p>

<p>NOTE: Graphs are prime Software Engineer interview questions</p>

<ul>
  <li>Accumulators won‚Äôt run out of memory like recursion will because it sends the completed (up to said point) value through again. In recursion it opens all of the stacks and then runs the functions.</li>
</ul>

<h2 id="reverse">Reverse</h2>

<p>Problem: design a funciton to reverse a list.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Problem: design a function reverse a list.</span>
<span class="c1">;; reverse : {X} [List-of X] -&gt; [List-of X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-reverse</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">append</span>
      <span class="p">(</span><span class="nf">my-reverse</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)))]))</span>

<span class="c1">;(check-expect (my-reverse (list 10 20 30 40)) (list 40 30 20 10))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-reverse/v2</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">reverse-helper</span> <span class="nv">alist</span> <span class="o">'</span><span class="p">()))</span>

<span class="c1">;(check-expect (my-reverse/v2 (list 10 20 30 40)) (list 40 30 20 10))</span>

<span class="c1">;(my-reverse/v2 (list 10 20 30 40))</span>
<span class="o">#</span><span class="nv">|</span>
<span class="p">(</span><span class="nf">reverse-helper</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">)</span> <span class="nv">???</span><span class="p">)</span>
<span class="o">..</span>
<span class="o">..</span>
<span class="o">..</span>
<span class="p">(</span><span class="nf">reverse-helper</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">40</span> <span class="o">'</span><span class="p">())</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">30</span> <span class="mi">20</span> <span class="mi">10</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">40</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">30</span> <span class="mi">20</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="nf">reverse-helper</span> <span class="o">'</span><span class="p">()</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">40</span> <span class="mi">30</span> <span class="mi">20</span> <span class="mi">10</span><span class="p">))</span>
<span class="nv">|</span><span class="o">#</span>

<span class="c1">;; reverse-helper : {X} [List X] [List X] -&gt; [List X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">reverse-helper</span> <span class="nv">alist</span> <span class="nv">reversed-so-far</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">reversed-so-far</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">reverse-helper</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span>
                     <span class="c1">; Use (first alist)</span>
                     <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">reversed-so-far</span><span class="p">))]))</span>
<span class="o">#</span><span class="nv">|</span>
<span class="p">(</span><span class="nf">my-reverse/v2</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">))</span>
<span class="p">(</span><span class="nf">rh</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">40</span> <span class="o">'</span><span class="p">()))))</span> <span class="o">'</span><span class="p">())</span>
<span class="p">(</span><span class="nf">rh</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">40</span> <span class="o">'</span><span class="p">())))</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="nf">rh</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">30</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">40</span> <span class="o">'</span><span class="p">()))</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">10</span> <span class="o">'</span><span class="p">())))</span>
<span class="nv">|</span><span class="o">#</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-reverse/v3</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">([</span><span class="k">define</span> <span class="p">(</span><span class="nf">reverse-helper</span> <span class="nv">alist</span> <span class="nv">reversed-so-far</span><span class="p">)</span>
            <span class="p">(</span><span class="k">cond</span>
              <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">reversed-so-far</span><span class="p">]</span>
              <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">reverse-helper</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span>
                               <span class="c1">; Use (first alist)</span>
                               <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">reversed-so-far</span><span class="p">))])])</span>
    <span class="p">(</span><span class="nf">reverse-helper</span> <span class="nv">alist</span> <span class="o">'</span><span class="p">())))</span>
</code></pre></div></div>

<ul>
  <li>Remeber, we can make these helper functions local (this is an acceptable use of local)</li>
</ul>

<h2 id="foldl">Foldl</h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; my-foldr : {X Y} (X Y -&gt; Y) Y [List-of X] -&gt; Y</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">f</span> <span class="nv">base</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">base</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="p">(</span><span class="nf">my-foldr</span> <span class="nv">f</span> <span class="nv">base</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)))]))</span>

<span class="c1">;; my-foldl : {X Y} (X Y -&gt; Y) Y [List-of X] -&gt; Y</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-foldl</span> <span class="nv">f</span> <span class="nv">accum</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">accum</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">cons?</span> <span class="nv">alist</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">my-foldl</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">))]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-reverse/v4</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">my-foldl</span> <span class="nv">cons</span> <span class="o">'</span><span class="p">()</span> <span class="nv">alist</span><span class="p">))</span>

<span class="c1">;; (my-foldr f base (cons a (cons b (cons c '()))))</span>
<span class="c1">;; =&gt; (f a (f b (f c base)))</span>

<span class="c1">;; (my-foldl f accum (cons a (cons b (cons c '()))))</span>
<span class="c1">;; =&gt; (f c (f b (f a accum)))</span>

<span class="c1">;; Example:</span>
<span class="c1">;; (f c (f b (f a accum))) replace f with cons and accum with '()</span>
<span class="c1">;; (cons c (cons b (cons a '())))</span>
</code></pre></div></div>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    (define (my-append alist blist)
      (cond
        [(empty? alist) blist]
        [(cons? alist)
         (cons (first alist) (my-append (rest alist) blist))]))

    ;; Problem: design a function reverse a list.
    ;; reverse : {X} [List-of X] -&gt; [List-of X]
    (define (my-reverse alist)
      (cond
        [(empty? alist) '()]
        [(cons? alist)
         (append
          (my-reverse (rest alist))
          (list (first alist)))]))

    ;(check-expect (my-reverse (list 10 20 30 40)) (list 40 30 20 10))

    (define (my-reverse/v2 alist)
      (reverse-helper alist '()))

    ;(check-expect (my-reverse/v2 (list 10 20 30 40)) (list 40 30 20 10))

    ;(my-reverse/v2 (list 10 20 30 40))
    #|
    (reverse-helper (list 10 20 30 40) ???)
    ..
    ..
    ..
    (reverse-helper (cons 40 '()) (list 30 20 10))
    =&gt; (cons 40 (list 30 20 10))
    (reverse-helper '() (list 40 30 20 10))
    |#

    ;; reverse-helper : {X} [List X] [List X] -&gt; [List X]
    (define (reverse-helper alist reversed-so-far)
      (cond
        [(empty? alist) reversed-so-far]
        [(cons? alist)
         (reverse-helper (rest alist)
                         ; Use (first alist)
                         (cons (first alist) reversed-so-far))]))
    #|
    (my-reverse/v2 (list 10 20 30 40))
    (rh (cons 10 (cons 20 (cons 30 (cons 40 '())))) '())
    (rh (cons 20 (cons 30 (cons 40 '()))) (cons 10 '()))
    (rh (cons 30 (cons 40 '())) (cons 20 (cons 10 '())))
    |#

    (define (my-reverse/v3 alist)
      (local ([define (reverse-helper alist reversed-so-far)
                (cond
                  [(empty? alist) reversed-so-far]
                  [(cons? alist)
                   (reverse-helper (rest alist)
                                   ; Use (first alist)
                                   (cons (first alist) reversed-so-far))])])
        (reverse-helper alist '())))

    ;; my-foldr : {X Y} (X Y -&gt; Y) Y [List-of X] -&gt; Y
    (define (my-foldr f base alist)
      (cond
        [(empty? alist) base]
        [(cons? alist) (f (first alist) (my-foldr f base (rest alist)))]))

    ;; my-foldl : {X Y} (X Y -&gt; Y) Y [List-of X] -&gt; Y
    (define (my-foldl f accum alist)
      (cond
        [(empty? alist) accum]
        [(cons? alist)
         (my-foldl f (f (first alist) accum) (rest alist))]))

    (define (my-reverse/v4 alist)
      (my-foldl cons '() alist))

    ;; (my-foldr f base (cons a (cons b (cons c '()))))
    ;; =&gt; (f a (f b (f c base)))

    ;; (my-foldl f accum (cons a (cons b (cons c '()))))
    ;; =&gt; (f c (f b (f a accum)))

    ;; Example:
    ;; (f c (f b (f a accum))) replace f with cons and accum with '()
    ;; (cons c (cons b (cons a '())))

    (define (f n)
      (if (zero? n)
          1
          (+ 1 (f (- n 1)))))

    (define (g n acc)
      (if (zero? n)
          acc
          (g (- n 1) (+ acc 1))))
</pre>
</details>
<h1 id="lecture-34---accumulators-generative-recursion">Lecture 34 - Accumulators Generative Recursion</h1>

<p>Exam grades will be released this evening.</p>

<ul>
  <li>Average score was about 70 points (which is about 5 points lower than usual) ‚Äî this hasn‚Äôt been a normal semester</li>
</ul>

<p>Get involved with research and stuff!</p>

<h2 id="accumulators-1">Accumulators</h2>

<h3 id="tree-example-1">Tree Example</h3>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-struct</span> <span class="nv">leaf</span> <span class="p">[])</span>
<span class="p">(</span><span class="nf">define-struct</span> <span class="nv">node</span> <span class="p">[</span><span class="nf">left</span> <span class="nv">value</span> <span class="nv">right</span><span class="p">])</span>
<span class="c1">;; A [BT X] is one of:</span>
<span class="c1">;; - (make-leaf)</span>
<span class="c1">;; - (make-node BT X BT)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-bt-1</span>
  <span class="p">(</span><span class="nf">make-node</span> <span class="p">(</span><span class="nf">make-node</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">)</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">))</span> <span class="mi">20</span> <span class="p">(</span><span class="nf">make-leaf</span><span class="p">)))</span>
<span class="c1">;; flatten-bt : {X} [BT X] -&gt; [List-of X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">flatten-bt</span> <span class="nv">abt</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abt</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
    <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abt</span><span class="p">)</span> <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nf">flatten-bt</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abt</span><span class="p">))</span>
                         <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abt</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">flatten-bt</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abt</span><span class="p">)))]))</span>

<span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">flatten-bt</span> <span class="nv">ex-bt-1</span><span class="p">)</span> <span class="o">'</span><span class="p">(</span><span class="nf">10</span> <span class="mi">20</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>But this is slow</li>
  <li>We can use an accumulator for this:</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; flatten-bt-helper : {X} [BT X] [List-of X] -&gt; [List-of X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">flatten-bt-helper</span> <span class="nv">abt</span> <span class="nv">acc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">[(</span><span class="nf">leaf?</span> <span class="nv">abt</span><span class="p">)</span> <span class="nv">acc</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">node?</span> <span class="nv">abt</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">local</span> <span class="p">([</span><span class="k">define</span> <span class="nv">new-acc</span> <span class="p">(</span><span class="nf">flatten-bt-helper</span> <span class="p">(</span><span class="nf">node-right</span> <span class="nv">abt</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)])</span>
       <span class="p">(</span><span class="nf">flatten-bt-helper</span> <span class="p">(</span><span class="nf">node-left</span> <span class="nv">abt</span><span class="p">)</span>
                          <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">node-value</span> <span class="nv">abt</span><span class="p">)</span> <span class="nv">new-acc</span><span class="p">)))]))</span>

<span class="c1">;; flatten-bt/v2 : {X} [BT X] -&gt; [List-of X]</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">flatten-bt/v2</span> <span class="nv">abt</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">flatten-bt-helper</span> <span class="nv">abt</span> <span class="o">'</span><span class="p">()))</span>
</code></pre></div></div>

<h2 id="generative-recursion">Generative Recursion</h2>

<ul>
  <li>we‚Äôve usually been using structrual recursion</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">apply</code> - Function that takes in a list and uses every element in a list as arguments to the function input</p>
<h1 id="lecture-35---generative-recursion-and-machine-learning">Lecture 35 - Generative Recursion and Machine Learning</h1>

<p>What we should read over break in preperation of Fundies 2</p>

<ul>
  <li>Google northeastern Fundies 2 (go over the lecture notes)</li>
  <li>Head First Java (book) is pretty good</li>
  <li>Online course?
    <ul>
      <li>UCST Coursera course</li>
    </ul>
  </li>
</ul>

<p>Concluding regular programming today</p>

<p>Then random stuff</p>

<ul>
  <li>Gradient decent</li>
</ul>

<p>&lt; No code posted :( &gt;</p>

<h2 id="generative-recursion-1">Generative Recursion</h2>

<p>Recall new line function (see Lecture 34 for more)</p>

<ul>
  <li>Notice: it didn‚Äôt follow the design recipe</li>
</ul>

<h3 id="insertion-sort">Insertion Sort</h3>

<p>&lt;slc - <code class="language-plaintext highlighter-rouge">sort&lt;</code> &gt;</p>

<h3 id="quick-sort-or-at-least-the-essense-of-quick-sort">Quick Sort (or at least the essense of Quick Sort)</h3>

<p>&lt;slc - qsort&gt;</p>

<h2 id="intro-to-machine-learning">Intro To Machine Learning</h2>

<p>‚ÄúBascially all machine learning is recursion problems‚Äù - Arjun</p>

<h3 id="rate-of-change">Rate of Change</h3>

<p>&lt;slc - rate of change&gt;</p>

<p>Note: change2 is the limit definition of the derivative</p>

<p><strong>Higher Order Function</strong>: Any function that receives another function as an argument</p>

<p>‚ÄúYou are the derivative function‚Äù - Arjun</p>

<h3 id="linear-regression">Linear Regression</h3>

<p>Essentially, can we make a linear function that acts as a line of best fit for a list of points?</p>

<h3 id="gradient-descent">Gradient Descent</h3>

<p>‚ÄúThe linear formula is y=mx+b. I‚Äôm going to massage this a little bit‚Äù - Arjun</p>

<p>Gradient is just a fancy term for slope.</p>

<p>Guess the slope and then guess the y-intercept</p>

<p>(F 5) ‚áí 53</p>

<p>(F 3) ‚áí 33</p>

<p>What is the function?</p>

<p>We need to guess the slope first. If you get lucky and guess 10 and 3 for the slope and y-intercept respectively you get the following:</p>

<p>((linear 5) 10 3) ‚áí 53</p>

<p>((linear 3) 10 3) ‚áí 33</p>

<p><strong>How can we do better than just blind guessing?</strong></p>

<p>How much should you vary between guesses?</p>

<p>(deriv (lambda (slope) (- (F 5) ((linear 5) slope 3))) 7 0.0001) ‚áí ~5.0000</p>

<ul>
  <li>This shows how much you jump
    <h1 id="lecture-36---continued-machine-learning">Lecture 36 - Continued Machine Learning</h1>
  </li>
</ul>

<p>‚ÄúI‚Äôm closing my door because my cat is dying‚Äù - Arjun</p>

<p>Recall code from yesterday</p>

<p>Intro to 3D graphing</p>

<p>By using a 3D graph, we can better represent changing both <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">b</code> in the function <code class="language-plaintext highlighter-rouge">y=m*x+b</code> (recall that we already know <code class="language-plaintext highlighter-rouge">x</code>)</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span> <span class="nv">plot</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">ex-linear</span> <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">-2</span><span class="p">)))</span>

<span class="c1">;; linear-at : Num -&gt; (Num Num -&gt; Num)</span>
<span class="c1">;; Represents _y = mx + b_. But with two tricks:</span>
<span class="c1">;; - _x_, _m_ and _b_ are all parameters</span>
<span class="c1">;; - The function first receives _x_ and produces a function that receives _m_ and _b_</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">linear-at</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">b</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">m</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>

<span class="c1">;; A plot of the two-argument function:</span>
<span class="c1">;;</span>
<span class="c1">;; f(x,y) = 2xy + x^2 + 3y</span>
<span class="c1">;;</span>
<span class="c1">;; Evaluate (plot3d ex-3d-plot)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">show-3d-plot-1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">plot3d</span> <span class="p">(</span><span class="nf">surface3d</span> <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="nv">y</span><span class="p">)))</span> <span class="mi">-1</span> <span class="mi">1</span> <span class="mi">-1</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre></div></div>

<p>NOTE: You can‚Äôt get the derivative of absolute value which is why we square to get the ‚Äòerror‚Äô</p>

<ul>
  <li>Term for the ‚Äòerror‚Äô is L2-norm</li>
</ul>

<p>The particular algorithm is called Gradient Descent</p>

<ul>
  <li>Socastic Gradient Descent is what‚Äôs used in practice (we are ignoring the extra features)</li>
</ul>

<h3 id="how-to-solve-it">How to solve it:</h3>

<ol>
  <li>We need to detremine what our model is going to be
    <ol>
      <li>The example that we‚Äôve used has just been linear models</li>
    </ol>
  </li>
  <li>Need data (called training data)</li>
  <li>Calculate the error (called the loss)
    <ol>
      <li>Often times an error of 0 is not possible</li>
    </ol>
  </li>
  <li>If the loss is acceptable, return current parameters</li>
  <li>If the loss is not acceptable, pick new values for the parameters. Goal is to go ‚Äúdown the slope‚Äù</li>
</ol>

<p>NOTE: When actually doing this, we don‚Äôt actually build the curve. We use the derivative to move down the slope</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Cannot get to zero error on this example:</span>
<span class="c1">; (plot-linear-error '(1 2 3) '(-2 5 -10))</span>

<span class="c1">;; High-level idea:</span>
<span class="c1">;;</span>
<span class="c1">;; 1. Assume we have x-values and y-values (the *training data*)</span>
<span class="c1">;; 2. Guess values for m and b (the *parameters* of the model)</span>
<span class="c1">;; 3. Calculate the error (the *loss*)</span>
<span class="c1">;; 4. Is the loss acceptable? Return the current parameters</span>
<span class="c1">;; 5. Pick new values the parameters. Goal is to go "down the slope", i.e., negative of the derivate</span>
<span class="c1">;; 6.</span>
</code></pre></div></div>

<p>We need to derive the function with respect to multiple variables (the example that we‚Äôve used is <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">b</code>)</p>

<h3 id="partial-derivative">Partial Derivative</h3>

<p>Consider one of the variables to be a constant.</p>

<p>For this example, we are just going to use a numeric derivative (with a small episilon). Essentially, we move slightly in different directions and see how quickly the output changes</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Partial Derivatives</span>

<span class="c1">;; How precise do we want our numeric derivates to me?</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">EPSILON</span> <span class="mf">0.00001</span><span class="p">)</span>

<span class="c1">;; map-index: {X Y} (Nat X -&gt; Y) [List-of X] -&gt; [List-of Y]</span>
<span class="c1">;; Similar to map, but also gives the position of the element to _f_.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">map/index</span> <span class="nv">f</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">local</span> <span class="p">(</span><span class="c1">;; map-index/helper : Nat [List-of X] -&gt; [List-of Y]</span>
          <span class="p">[</span><span class="k">define</span> <span class="p">(</span><span class="nf">map/index-helper</span> <span class="nv">index</span> <span class="nv">alist</span><span class="p">)</span>
            <span class="p">(</span><span class="k">cond</span>
              <span class="p">[(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
              <span class="p">[</span><span class="k">else</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">index</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">))</span> <span class="p">(</span><span class="nf">map/index-helper</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">index</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)))])])</span>
    <span class="p">(</span><span class="nf">map/index-helper</span> <span class="mi">0</span> <span class="nv">alist</span><span class="p">)))</span>

<span class="c1">;; partial-deriv : (Num ... -&gt; Num) [List-of Num] -&gt; [List-of Num]</span>
<span class="c1">;; Given an _n_ argument function, and an argument list, calculates its _n_ partial derivates.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">partial-derivs</span> <span class="nv">F</span> <span class="nv">params</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">build-list</span>
   <span class="p">(</span><span class="nb">length</span> <span class="nv">params</span><span class="p">)</span> <span class="c1">;; For every parameter to F</span>
   <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">local</span> <span class="p">(</span><span class="c1">;; Add epsilon to the nth parameter, and leave the others unchanged.</span>
             <span class="p">[</span><span class="k">define</span> <span class="nv">params+epsilon</span>
               <span class="p">(</span><span class="nf">map/index</span>
                <span class="p">(</span><span class="err">Œª</span> <span class="p">(</span><span class="nf">i</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">i</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">EPSILON</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">p</span><span class="p">))</span>
                <span class="nv">params</span><span class="p">)])</span>
       <span class="c1">;; We receive a list of parameters for F.</span>
       <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">F</span> <span class="nv">params+epsilon</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">F</span> <span class="nv">params</span><span class="p">))</span> <span class="nv">EPSILON</span><span class="p">)))))</span>
</code></pre></div></div>

<p>‚ÄúNo one know what the fuck the learning rate is‚Äù - Arjun</p>

<p>y‚Äôall ever just write machine learning in Racket?</p>

<details>
<summary>
Full Lecture Code
</summary>
<pre>
    #lang racket
    (require plot)

    (define ex-linear (Œª (x) (+ (* 2 x) -2)))

    ;; linear-at : Num -&gt; (Num Num -&gt; Num)
    ;; Represents _y = mx + b_. But with two tricks:
    ;; - _x_, _m_ and _b_ are all parameters
    ;; - The function first receives _x_ and produces a function that receives _m_ and _b_
    (define linear-at
      (lambda (x)
        (lambda (m b)
          (+ (* m x) b))))

    ;; A plot of the two-argument function:
    ;;
    ;; f(x,y) = 2xy + x^2 + 3y
    ;;
    ;; Evaluate (plot3d ex-3d-plot)
    (define (show-3d-plot-1)
      (plot3d (surface3d (Œª (x y) (+ (* 2 x y) (* x x) (+ 3 y))) -1 1 -1 1)))

    ;; A plot of the two-argument function:
    ;;
    ;; f(m, b) = m * 2 + b
    ;;
    (define ex-3d-plot-2 (surface3d (Œª (m b) (+ (* m 2) b)) -5 5 -5 5))

    (define (show-3d-plot-2)
      (plot3d ex-3d-plot-2
              #:x-label "m axis"
              #:y-label "b axis"
              #:z-label "y axis"
              #:title "Fixed x = 2"))
    (define ex-3d-plot-2/v2 (surface3d (linear-at 2) -5 5 -5 5))

    ;; Notice that the point is on the surface.
    (define (show-3d-plot-3)
      (plot3d (list ex-3d-plot-2
                    (points3d (list (list 2 -2 (ex-linear 2))) #:color "red"))
              #:x-label "m axis"
              #:y-label "b axis"
              #:z-label "y axis"
              #:title "Fixed x = 2"))

    ;; What is this function?
    (define ex-function-4 (Œª (m b) (sqr (- (ex-linear 2) ((linear-at 2) m b)))))

    (define ex-3d-plot-4
      (surface3d ex-function-4 -5 5 -5 5))

    (define (show-3d-plot-4)
      (plot3d ex-3d-plot-4
              #:x-label "m axis"
              #:y-label "b axis"
              #:z-label "y axis"
              #:title "Fixed x = 2"))

    ;; Quadratic formula is f(x) = ax^2 + bx + c. Assume c = 0.
    (define ex-quadratic (Œª (x) (+ (* 2 x x) (* -2 x))))
    (define (show-quadratic)
      (plot (function ex-quadratic -3 3)))

    ;; quadratic-at : Num -&gt; (Num Num -&gt; Num)
    ;; Represents _y = ax^2 + bx_.
    (define quadratic-at
      (lambda (x)
        (lambda (a b)
          (+ (* a x x) (* b x)))))

    (define (show-quadratic-at-2)
      (plot3d
       (list
        (surface3d (quadratic-at 2) -3 3 -3 3)
        (points3d (list (list 2 -2 (ex-quadratic 2)))))
       #:x-label "a axis"
       #:y-label "b axis"
       #:z-label "y axis"
       #:title "Fixed x = 2"))

    (define ex-quadratic-error (Œª (a b) (sqr (- (ex-quadratic 2) ((quadratic-at 2) a b)))))

    (define (show-quadratic-error)
      (plot3d
       (surface3d ex-quadratic-error -3 3 -3 3)
         #:x-label "a axis"
         #:y-label "b axis"
         #:z-label "y axis"
         #:title "Fixed x = 2"))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; Sum of errors of multiple points
    (define (linear-error x-values y-values)
      (Œª (m b)
        (foldr + 0 (map (Œª (x y) (sqr (- y ((linear-at x) m b)))) x-values y-values))))

    (define (plot-linear-error x-values y-values)
      (plot3d
       (surface3d (linear-error x-values y-values) -5 5 -5 5)
       #:x-label "m axis"
       #:y-label "b axis"
       #:z-label "y axis"))

    (define ex-data-1 '((-0.3993 0.787) (0.425 4.924) (-0.0895 2.6) (0.153 3.545) (-0.4466 0.387) (0.369 4.929) (0.3955 5.35) (-0.338 0.33) (0.1048 3.33) (-0.1397 1.63) (-0.4474 1.002) (-0.2395 2.338) (0.3424 5.48) (-0.1258 2.485) (0.4866 6.24) (-0.1342 2.593) (0.449 4.994) (0.088 2.462) (0.4666 5.70) (0.04956 3.06) (0.4816 5.19) (0.1378 3.393) (-0.2014 2.224) (-0.4887 0.3273) (-0.2225 1.88) (-0.1998 2.72) (-0.0908 1.796) (-0.3513 1.535) (-0.496 0.722) (-0.02463 1.415)))

    (define (plot-ex-data-error)
      (plot-linear-error (map first ex-data-1) (map second ex-data-1)))

    ;(plot-linear-error '(1 2 3) '(2 4 6))

    ; Cannot get to zero error on this example:
    ; (plot-linear-error '(1 2 3) '(-2 5 -10))

    ;; High-level idea:
    ;;
    ;; 1. Assume we have x-values and y-values (the *training data*)
    ;; 2. Guess values for m and b (the *parameters* of the model)
    ;; 3. Calculate the error (the *loss*)
    ;; 4. Is the loss acceptable? Return the current parameters
    ;; 5. Pick new values the parameters. Goal is to go "down the slope", i.e., negative of the derivate
    ;; 6.

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Partial Derivatives

    ;; How precise do we want our numeric derivates to me?
    (define EPSILON 0.00001)

    ;; map-index: {X Y} (Nat X -&gt; Y) [List-of X] -&gt; [List-of Y]
    ;; Similar to map, but also gives the position of the element to _f_.
    (define (map/index f alist)
      (local (;; map-index/helper : Nat [List-of X] -&gt; [List-of Y]
              [define (map/index-helper index alist)
                (cond
                  [(empty? alist) '()]
                  [else (cons (f index (first alist)) (map/index-helper (+ 1 index) (rest alist)))])])
        (map/index-helper 0 alist)))

    ;; partial-deriv : (Num ... -&gt; Num) [List-of Num] -&gt; [List-of Num]
    ;; Given an _n_ argument function, and an argument list, calculates its _n_ partial derivates.
    (define (partial-derivs F params)
      (build-list
       (length params) ;; For every parameter to F
       (Œª (n)
         (local (;; Add epsilon to the nth parameter, and leave the others unchanged.
                 [define params+epsilon
                   (map/index
                    (Œª (i p) (if (= i n) (+ EPSILON p) p))
                    params)])
           ;; We receive a list of parameters for F.
           (/ (- (apply F params+epsilon) (apply F params)) EPSILON)))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define-struct gradient (grad error) #:transparent)
    ;; gradient-of-loss : (Num ... -&gt; Num) [List-of Num] [List-of Num] -&gt; (make-gradient [List-of Num] Num]
    ;; Given a function of _n_ parameters, a list of _params_, and an _expected-result_, calculates the
    ;; gradient and the squared error.
    (define (derivs-of-loss F/args params expected-result)
      (local ([define (F-loss . params)
                (sqr (- expected-result (apply F/args params)))])
        (make-gradient (partial-derivs F-loss params)
                       (sqr (- expected-result (apply F/args params))))))

    ;; update-params : Num [List-of Num] [List-of Num] -&gt; [List-of Num]
    ;; Adds the gradients (multiplied by the learning rate) to the parameters.
    (define (update-params lr params gradients)
      (map (Œª (p d) (- p (* lr d))) params gradients))

    (define-struct solution (params error) #:transparent)

    ;; optimize : Num (Num ... -&gt; Num) [List-of Num] [List-of [List-of Num]] [List-of Num]
    ;;         -&gt; (make-solution [List-of Num] Num)
    ;; Calculates new parameter values by adding the given parameters to the derivate of the loss
    ;; (at the given data points), scaled by the learning rate.
    (define (optimize lr F params args-list expected-result-list)
      (foldr
       (Œª (args expected sol)
         (local ([define F/args (apply F args)]
                 [define one-grad (derivs-of-loss F/args (solution-params sol) expected)])
           (make-solution
            (update-params lr (solution-params sol) (gradient-grad one-grad))
            (+ (gradient-error one-grad) (solution-error sol)))))
       (make-solution params 0)
       args-list
       expected-result-list))

    (define (opt-until max-rounds lr F initial-params data)
      (local ([define args-from-data (map (Œª (p) (list (first p))) data)]
              [define results-from-data (map (Œª (p) (second p)) data)]
              [define (helper round sol)
                #;(when (zero? (modulo round 100))
                  (printf "~a~n" (plot (list (points data) (function (Œª args (apply (apply F args) (solution-params sol))))))))
                (if (zero? round)
                    sol
                    (helper (sub1 round) (optimize lr F (solution-params sol) args-from-data results-from-data)))])
        (helper max-rounds (make-solution initial-params 0))))

    ;; Try 5,000. Wait for the loss to stop decreasing
    (define (optimize-ex-data-1 rounds)
      (opt-until rounds 0.0001 linear-at
                 '(0 0) ex-data-1))
    #|
    (plot
       (list (points ex-data-1)
             (function (Œª (x) (+ (* m x) b)))))
    |#
</pre>
</details>

:ET