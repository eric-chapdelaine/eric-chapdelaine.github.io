---
layout: note
type: note
title: CS3500 Object Oriented Design
date: 2021-05-09
status: In Progress
professor: Vidoje Mihajlovikj
labels:
  - Object Oriented Design
  - OOD
---

# The Class

Everything will be on Canvas

Self-evals are worth about 2-3 percent (each) of your grade

Exam is on June 1 (in 3 weeks). Exam 2 is two weeks after Exam 1.

First 4 assignments are completed by yourself. The next four are with partners.

2 late days for the first 4 assignments. Another 2 late days for the rest.

We will work with Java until Exam 2. Then C/C++.

If you are going to read a book, read *Head First Design Patterns: A Brain-Friendly Guide*.

We will be learning design patterns, not Java concepts:
* Interfaces
* Abstract classes
* Inheritance
* Function Objects
* Avoiding Mutation
* Exceptions
* Bugs with aliasing
* Custom equal and hash code 
* Testing
    * 40% of the assignments is just testing
    * Write tests before you write your code. Just write down tests on paper (just to get ideas).

How do we write code so that we can introduce change (without having to modify the code)?

What we won't learn:
* IList (Recursion)
* Iterators
* Visitor Patterns
* Big O
* Algorithms
* Priority Queues
* Graphs, BFS, DFS
* etc.

## Topics

* How to write reusable and decoupled (flexible) software

* SOLID Principles
    * Do *NOT* modify code on the exams
    * Interfaces should have the bare minimum

| S | Single Responsibility                     |
| O | Open to extension, closed to modification |
| L | Liskov substitution                       |
| I | Interface segregation                     |
| D | Dependency inversion                      |


* We will see what Java techniques we can use to code according to these principles.

**Why learn SOLID and design patterns?**

* Introducing changes in software development is much easier (and more requested) than in other fields.
* Code gets long
* We don't understand the entire code base, or a large part of it.

Unlike other fields, the design process for software engineering is more like:
1. Cursory analysis
2. Completely wrong implementation
3. More cursory analysis
4. Wrong-headed design
5. Some implementation and testing
6. More analysis and re-design
7. More implementation and testing
8. Iterate, iterate, iterate
9. Deployment
10. Bug reports
11. Head scratching
12. Coffee
13. Temptation to rewrite from scratch

How do we break up code into individual classes that can interact with each other such that it will enable us to introduce change without having to modify the design extensively?

Other topics we will cover:
* Composition  
* Access modifiers, private, protected and public, in other words, information hiding
* Testing
* Class diagrams
* Efficiency
* Client perspective versus implementer perspective
* We try to avoid mutability

What to remember while in this class:
* Don't modify existing code that we give you
* Always introduce new functionality with an interface or by extending a new interface
* Avoid mutability
* Be careful with references
* Start early on assignments
* Make sure you read the Design Principles Master List on Canvas
* Make sure you read "How to write tests" on Canvas

# Introduction to Object Oriented Design

Citation of publications (either Books or Articles)

Consider the implementation in Racket:

```scheme
;; A Publication is one of:
;; -- (make-book String String String String Number)
;; -- (make-article String String String Number Number Number)
(define-struct book [title author publisher location year])
(define-struct article [title author journal volume issue year])

;; Examples:
(define rushdie.v1
        (make-book "Midnight's Children" "Salman Rushdie"
                   "Jonathan Cape" "London" 1980))
(define turing.v1
        (make-article "Computing machinery and intelligence"
                      "A. M. Turing" "Mind" 59 236 1950))
```

Then we can make our citation functions:

```scheme
;; cite-apa: Publication -> String
;; To format a publication for citation in APA style.
(define (cite-apa pub)
  (cond
    [(book? pub)
     (format "~a (~a). ~a. ~a: ~a."
             (book-author pub) (book-year pub) (book-title pub)
             (book-location pub) (book-publisher pub))]
    [(article? pub)
     (format "~a (~a). ~a. ~a, ~a(~a)."
             (article-author pub) (article-year pub) (article-title pub)
             (article-journal pub) (article-volume pub) (article-issue pub))]))

;; cite-mla: Publication -> String
;; To format a publication for citation in MLA style.
(define (cite-mla pub)
  (cond
    [(book? pub)
     (format "~a. ~a. ~a: ~a, ~a."
             (book-author pub) (book-title pub) (book-location pub)
             (book-publisher pub) (book-year pub))]
    [(article? pub)
     (format "~a. \"~a.\" ~a ~a.~a (~a)."
             (article-author pub) (article-title pub) (article-journal pub)
             (article-volume pub) (article-issue pub) (article-year pub))]))

```

In an OO approach, the data would know how to cite itself. But in functional languages, we give the data to the function.

Now, what if we want to have a new publication: a webpage. How can we do this?

```scheme
;; In APA function
 [(webpage? pub)
     (format "~a. Retrieved ~a, from ~a."
             (webpage-title pub) (webpage-retrieved pub) (webpage-url pub))]
             
;; In MLA function
[(webpage? pub)
    (format "\"~a.\" Web. ~a <~a>."
            (webpage-title pub) (webpage-retrieved pub) (webpage-url pub))]

```

In this, we need to modify the code. This is fine for now, because the change is small, but we usually want to avoid changing code because it can break things. Or sometimes, you won't have permission to change the code.

Lets do an OO approach (ie the object knows how to cite itself) in Racket. We want to make the publications lambdas.

```scheme
;; new-book: String String String String Number -> Publication
;; To construct a new book.
(define (new-book title author publisher location year)
  (lambda (style)
    (cond
      [(string=? style "apa")
       (format "~a (~a). ~a. ~a: ~a."
               author year title location publisher)]
      [(string=? style "mla")
       (format "~a. ~a. ~a: ~a, ~a."
               author title location publisher year)])))

;; Example:
(define rushdie.v2
        (new-book "Midnight's Children" "Salman Rushdie"
                  "Jonathan Cape" "London" 1980))
```

This is now how we cite:
```scheme
(check-expect
 (rushdie.v2 "apa")
 "Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.")
```

Now adding the webpage, we don't need to change the code. But if we were to add a new citation style, we would (so advantages and disadvantages).

How do we do this in Java?
* Unless stated otherwise, make everything `private final`. Remember, fields of objects (and the classes inner-workings) should be unknown.

```java
/**
 * Specifies operations for formatting citations from bibliographic data.
 */
public interface Publication {
  /**
   * Formats a citation in APA style.
   *
   * @return the formatted citation
   */
  String citeApa();

  /**
   * Formats a citation in MLA style.
   *
   * @return the formatted citation
   */
  String citeMla();
}
```

Book's implementation:
```java
/**
 * The {@code Book} class represents bibliographic information for books.
 */
public class Book implements Publication {
  private final String title, author, publisher, location;
  private final int year;
  
    /** Constructs a {@code Book} object.
   *
   * @param title     the title of the book
   * @param author    the author of the book
   * @param publisher the publisher of the book
   * @param location  the location of the publisher
   * @param year      the year of publication
   */
  public Book(String title, String author, String publisher,
              String location, int year)
  {
    this.title = title;
    this.author = author;
    this.publisher = publisher;
    this.location = location;
    this.year = year;
  }
  
    public String citeApa() {
    return author + " (" + year + "). " + title + ". "
             + location + ": " + publisher + ".";
  }

  public String citeMla() {
    return author + ". " + title + ". " + location + ": "
             + publisher + ", " + year + ".";
  }
}


```

The Article's implementation is similar as well.


## Testing (JUnit):

Example with Book implementation above:
```java
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class BookTest {
  Publication rushdie = new Book("Midnight's Children", "Salman Rushdie",
                                 "Jonathan Cape", "London", 1980);
  @Test
  public void testCiteApa() {
    assertEquals(
      "Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.",
      rushdie.citeApa());
  }

  @Test
  public void testCiteMla() {
    assertEquals(
      "Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.",
      rushdie.citeMla());
  }

}
```

* Is not required to test `private` methods. Only test public facing behavior.

In HandIn, your tests will be tested against bad code to see if it catches the errors.

**Abstracting Tests**

We want to abstract this:
```java
private IDuration duration_impl_1_1_1;
private IDuration compact_duration_1_1_1;

@Test
public void inSecondsDurationImpl() {
    assertEquals(3661, duration_impl_1_1_1.inSeconds());
}

@Test
public void inSecondsCompactDuration() {
    assertEquals(3661, compact_duration_1_1_1.inSeconds());
}
```

Abstraction:
```java
public abstract class AbstractDurationTest {
    private IDuration duration_1_1_1;

    protected abstract IDuration makeDurationFromSeconds(long totalSeconds);

    @Test
    public void testInSeconds() {
        assertEquals(3661, duration_1_1_1.inSeconds());
    }
}
```

```java
public class DurationImplTest extends AbstractDurationTest {
    
    @Override
    protected Duration makeDurationFromSeconds(long totalSeconds) {
        return new CompactDurationImpl(totalSeconds);
    }
}

public class CompactDurationImplTest extends AbstractDurationTest {
    
    @Override
    protected Duration makeDurationFroMSeconds(long totalSeconds) {
        return new CompactDurationImpl(totalSeconds);
    }
}
```

## Submitting Homework

Zip the `src` and `test` and submit the `.zip` in Handin.

## JavaDoc

Compiles into HTML so you can put your own HTML in the JavaDoc.

```java
/**
* formatHelper helps the format method to do XYZ
* @param start the index of the start of the format template
* @param end the index of the end of the format template
* @return some string.
*/
public String formatHelper(int start, int end) {
    return "";
}
```

# Java Review

We need to determine:
* Its attributes (i.e. fields)
* Its operations (i.e. methods)

A duration can be something like
* 1 year
* 500 minutes
* 3 days, 6 hours, 17 minutes, and 25 seconds (a composite)


Don't focus just on the data. That can limit your implementation. Instead, think about the possible operations such as: (design your interface on this)
* Convert units
* Format
* Add
* Subtract
* Decompose
* Compare durations for equality and ordering

Make some assumptions:
* Minimum time resolution: seconds
* Lower bound: 0
* Upper bound: unspecified
* Unitless: 180 seconds is equal to 3 minutes

What methods we need
* long inSeconds() 
    * This is an *observer* as it gives information about the object without changing anything.  This relates to information hiding.
* String asHms()
* int compareTo(Duration other)
* boolean equals(Object other)
* int hashCode();
* void add (Duration other) or Duration plus(Duration other)
* void sub(Duration other) or Duration minus(Duration other)

The interface:

```java
/**
 * Durations, with a minimum resolution of seconds. All durations are non-negative.
 * Different implementations should all work together using equals, hashcode, and compareTo:
 * <ul>
 *  <li> Two durations must be equal i they have the same number of seconds, they should be compared
 * by calling inSeconds();
 *  </li>
 *  <li> the hashCode of a duration in the result of calling {@link Long#hashCode(long)} and passing
 * the length in seconds that is by calling inSeconds
 *  </li>
 *  <li> compareTo should be using {@link Long#compare(long, long)} and pass in the total number
 * of seconds from the two durations 
 *  </li>
 * </ul>
 */
public interface IDuration extends Comparable<IDuration  {
  /**
   * Gets the total duration in seconds.
   *
   * @return the number of seconds (non-negative)
   */
  long inSeconds();

  /**
   * Formats this duration in the form {@code H:MM:SS} where the hours and
   * minutes are both zero-padded to two digits, but the hours are not.
   *
   * @return this duration formatted in hours, minutes, and seconds
   */
  String asHms();

  /**
   * Returns the sum of two durations.
   *
   * @param other the duration to add to {@code this}
   * @return the sum of the durations
   */
  IDuration plus(IDuration other);
}
```

Now for an implementation of `IDuration`.

```java
public class DurationImpl implements IDuration {

int hours;
int minutes;
int seconds;

public DurationImpl(int hours, int minutes, int seconds) {
    if (hours < 0  || minutes < 0 || seconds < 0) {
        throw new IllegalArgumentException("Durations cannot be negative");
    }
    
    this.hours = hours;
    this.minutes = minutes;
    this.seconds = seconds;
}

public DurationImpl(long seconds) {
    if (totalSeconds < 0) {
    }
    
    int seconds = (int) (totalSecondsOther % 60);
    int minutes = (int) (totalSecondsOther/60) % 60;
    
    if ( totlaSeconds/3600 > Integer.MAX_VALUE) {
        throw new IllegalStateException("Overflow in plus.")
    }
    
    int hours = (int) (totalSecondsOther/36000);
    
    this.hours = hours;
    this.minutes = minutes;
    this.seconds = seconds;
}

@Override
public int compareTo(IDuration o) {
    return Long.compare(this.inSeconds(), o.inSeconds());
}

@Override
public boolean equals(Object obj) {
    if (this =  obj) {
        return true;
    }
    
    if (!(obj instanceof IDuration) ) {
        return false;
    }
    
    IDuration other = (IDuration) obj;
    
    return this.inSeconds() == other.inSeconds();
}

@Override
public String toString() {
    return this.toHms();
}

@Override
public String asHms() {
    // H:MM:SS
    return Strng.format("%02d:%02d:%02d", this.hours, this.minutes, this.seconds);
}

@Override
public IDuration plus(IDuration other) { //ex. 3661 = 1 hour, 1 minute, 1 second
    return new DurationImple(this.inSeconds() + other.inSeconds());
}

}

@Override
public long inSeconds() {
    // It would be best to make sure that this doesn't throw an error
    return this.hours * 3600 + this.minutes*60 + this.seconds;
}
```

Lets take a look at something that can break the code. Here are the fields:

```java
int hours;
int minutes;
int seconds;
```

Now for tests:

```java
public class DurationImplTest() {
    // Never do this!! This type should be IDuration
    DurationImpl duration1;
    
    // This will be run before any other tests are run. 
    // For initializing your data
    @Before
    public void setUp() throws Exception {
        duration1 = new DurationImpl(0, 0, 60);
    }
    
    @Test
    public void inSeconds() {
        duration1.seconds = -60;
        // This isn't right. We want to enforce this.
        // To do so, we have to use access modifiers.
    }
}
```

Use:
```java
private final int hours;
private final int minutes;
private final int seconds;
```

Prevents mutability without our permission. Only the class has access to their fields. Now, what about `final`? Once you initialize it, you cannot change it. It acts like a constant. Always start with `final` and `private`. Remove `final` if *necessary*.
* Avoid mutation if possible. Always make new objects

Correct constructor:

```java
private int addCheckExceptoin(int value1, int value2, String message) throws IllegalStateException {
    int result = value1 + value2;
    if (result < 0) throw new IllegalArgumentException(message);
    return result;
}

public DurationImpl(int hours, int minutes, int seconds) {
    if (hours < 0  || minutes < 0 || seconds < 0) {
        throw new IllegalArgumentException("Durations cannot be negative");
    }
    
    // Adding the seconds overflow to the minutes, making 
    // sure that seconds is between 0 and 59
    if (seconds > 59) {
        minutes = addCheckExecpetion(minutes + seconds/60, "Minutes overflow");
        seconds = seconds % 60;
    }
    
    // Adding the minutes overflow to the hours, making 
    // sure that minutes is between 0 and 59.
    if (minutes > 59) {
        hours = addCheckExpection(hours + minutes/60, "Hours overflow");
        minutes = minutes %60;
    }
    
    this.hours = hours;
    this.minutes = minutes;
    this.seconds = seconds;
}
```

Here is another implementation (finish for homework): 

```java
public CompactDurationImpl(long totalSeconds) {

    if (totalSeconds < 0) {
        throw new IllegalArgumentException("Seconds cannot be negative");
    }
    
    this.totalSeconds = totalSeconds;

}
```

Also make an `AbstractDuration` that implements `IDuration`.
* And have both implementations extend `AbstractDuration`
* Always check arguments for validity
* Also put `throws` in the signature (it adds clarity and goes into the documentation)

### Testing Exceptions

```java
@Test(Expected = IllegalArgumentException.class)
public void testNegativeDuration() {
    IDuration tempDuration = new DurationImp(-1);
}
```

**Tests with Messages**
```java
@Test
public void testNegativeDurationWithMessage() {
    try {
        IDuration tempDuration = new DurationImg(-1);
        
    } catch(IllegalArgumentException e) {
        assertEquals("Duration cannot be negative", e.getMessage());
    }
}
```

## Debugging

Put break point where you want the program to stop. It then opens a panel of information with a stacktrace which tells you the methods that have been called

**Step over**: executes and jumps the line

**Step into**: Steps into the line and breaks at the first line called.


## Extending The Design (`Duration` Example)

Say that you only want to use one field.

You don't want to go back and change your entire implementation (this will also ruin tests).

We will be learning how to test both of these implementations at the same time (abstract test class).

When you find yourself copying and pasting, you should be using an abstraction.

Abstract Classes:
* An abstract class does not have to implement the entire interface.
* You cannot instantiate an abstract class (it is not complete)
* Private methods are not inherited

Think about the helper method `addCheckException`. We want to put it in the abstract class.
* Can't be private
    * Otherwise, you can't use it 
* Can't be public
    * Because it's not in the interface
    * It's a helper method, it should not be public
* This is where `protected` comes in
    * It's 'between' private and public

Never add public methods to the classes that aren't in the interface! Also, be very careful adding new methods to the interface.

```java
/**
 * Abstract base class for implementations of {@link Duration}.
 */
abstract class AbstractDuration implements Duration {
  /**
   * Constructs a {@link Duration} in a manner selected by concrete
   * subclasses of this class.
   *
   * @param inSeconds the length in seconds
   * @return the new {@code Duration}
   */
  protected abstract Duration fromSeconds(long inSeconds);

  @Override
  public String toString() {
    return asHms();
  }

  @Override
  public boolean equals(Object that) {
    if (this == that) {
      return true;
    }

    if (! (that instanceof Duration)) {
      return false;
    }

    return ((Duration) that).inSeconds() == this.inSeconds();
  }

  @Override
  public int hashCode() {
    return Long.hashCode(inSeconds());
  }

  @Override
  public int compareTo(Duration that) {
    return Long.compare(this.inSeconds(), that.inSeconds());
  }

  @Override
  public Duration plus(Duration that) {
    return fromSeconds(this.inSeconds() + that.inSeconds());
  }

  /**
   * Converts an unpacked hours-minutes-seconds duration to its length
   * in seconds.
   *
   * @param hours the number of hours
   * @param minutes the number of minutes
   * @param seconds the number of seconds
   * @return the duration in seconds
   */
  protected static long inSeconds(int hours, int minutes, int seconds) {
    return 3600 * hours + 60 * minutes + seconds;
  }

  /**
   * Formats an unpacked hours-minutes-seconds duration in the same
   * {@code H:MM:SS} format that {@link Duration#asHms()} returns.
   * Assumes that
   *
   * @param hours the number of hours
   * @param minutes the number of minutes
   * @param seconds the number of seconds
   * @return formatted duration
   * @throws IllegalArgumentException if any argument is negative
   */
  protected static String asHms(int hours, int minutes, int seconds) {
    return String.format("%d:%02d:%02d", hours, minutes, seconds);
  }

  /**
   * Ensures that the hours, minutes, and seconds are all non-negative.
   * Is factoring this out overkill? Or should we also factor out the
   * {@code inSeconds < 0} check in the two unary constructors? Discuss.
   *
   * @param hours the number of hours
   * @param minutes the number of minutes
   * @param seconds the number of seconds
   * @throws IllegalArgumentException if any argument is negative
   */
  protected static void ensureHms(int hours, int minutes, int seconds) {
    if (hours < 0 || minutes < 0 || seconds < 0) {
      throw new IllegalArgumentException("must be non-negative");
    }
  }

  /**
   * Returns the number of whole hours in the given number of seconds.
   *
   * @param inSeconds the total number of seconds
   * @return the number of hours
   * @throws ArithmeticException if the correct result cannot fit in an
   *          {@code int}.
   */
  protected static int hoursOf(long inSeconds) {
    if (inSeconds / 3600 > Integer.MAX_VALUE) {
      throw new ArithmeticException("result cannot fit in type");
    }

    return (int) (inSeconds / 3600);
  }

  /**
   * Returns the number of whole minutes in the given number of seconds, less
   * the number of whole hours.
   *
   * @param inSeconds the total number of seconds
   * @return the number of remaining minutes
   */
  protected static int minutesOf(long inSeconds) {
    return (int) (inSeconds / 60 % 60);
  }

  /**
   * Returns the number of seconds remaining after all full minutes are
   * removed from the given number of seconds.
   *
   * @param inSeconds the total number of seconds
   * @return the number of remaining seconds
   */
  protected static int secondsOf(long inSeconds) {
    return (int) (inSeconds % 60);
  }
}
```

## Factory Method - Design Pattern

Essentially, you are abstracting over the constructor.

You know you need to construct an object, but you don't know which one in the abstract class.

```java
// In Abstract class
public IDuration plus(IDuration other) {
    return makeDurationFromSeconds(this.inSeconds() + other.inSeconds());

protected abstract IDuration makeDurationFromSeconds(long seconds);
```

```java
// in DurationImpl class
protected IDuration makeDurationFromSeconds(long seconds) {
    return new DurationImpl(seconds);
}
```


You can get the super class's implementation of a method by doing:
```java
this.hours = super.getHours(totalSeconds);
```

# Static Fields and Static Methods

`static` means that a certain thing (field, method, etc) is shared across instances.

```java
public interface IDatabase {
   // int counter = 0; // Already public static final
   void addUser(String username);
}

public class Database implements IDatabase {
    // Remember, depend on the interface
    private final List<String> users;
    private static int counterForConstructor = 0;
    
    public DataBase() {
        this.users
        // you can also do Database.counterForConstructor++;
        counterForConstructor++;
    }
    
    @Override
    public static int getTotalDatabases() {
        return counterForConstructor;
    }
    
    @Override
    public void addUser(String username) {
        // Depending on the requirements, you can also use
        // an IllegalArgumentException
        Objects.requireNonNull(username);
        
        this.users.add(username);
    }
}

// Test
public class DatabaseTest {
    IDatabase database1;
    IDatabase database2;
    IDatabase database3;
    
    @Before
    public void init() {
        // How can I count how many times have I called the constructor?
        database1 = new Database();
        database2 = new Database();
        database3 = new Database();
    }
    
    @Test
    public void testNumberOfDBCreated() {
        int totalDatabases = Database.getTotalDatabases();
        
        assertEquals(3, totalDatabases);
    
    }
    
    @Test
    public void addUser() {
    
    }
}
```

## Singleton Pattern

What if you only want one `Database`? How can we make the constructor return the same object every time it is called?
* This is good if you are working with limited resources

```java
// Uncomment if you only want one instance
// private static IDatabase database = new Database();
// You can also put a limit to how many databases:
private static int numDatabases = 0;
private static int maxDatabases = 2;

private Database() {
    this.users = new ArrayList<>();
    
}

public static IDatabase getDatabase() {
    if (numDatabases < maxDatabases) {
        numDatabases++;
        return new Database();
    }
    throw new IllegalStateException("You reached the maximum number of databases");
    // return database; // if you never want two different instances
    // It always returns the same object
    
}
// In Tester class

database1 = Database.getDatabase();
database2 = Database.getDatabase();
database3 = Database.getDatabase();

public void addUser() {
    database1.addUser("User 1");
    database2.addUser("User 2");
    database3.addUser("User 3");
    
    assertEquals(3, dataabse1.getNumUsers()); // Passes
}
```

**Observers:**
```java
public interface IDatabase {
    // see above for the rest
    // I want an observer so I can see all the usernames in the databases
    void addUser(IUser username);
    List<IUser> getAllUsers();
    boolean containsUsername(String username);
}

public class Databases implements IDatabase {
    public List<String> getAllUsers() {
        return new ArrayList<String>(this.users); // shallow copy.
    }
    
    public boolean containsUsername(String username) {
        for (IUser user : this.users) {
            if (user.getUsername().equals(username)) {
                return true;
            }
        }
        return false;
    }
}

interface IUser {
    String getUsername();
    void setUsername(String username);
}

public class User implements IUser {
    private String username;
    
    public User(String username) {
        Objects.requireNonNull(username);
        this.username = username;
    }
    
    @Override
    public String getUsername() {
        return this.username;
    }
    
    @Override
    public void setUsername(String username) {
        this.username = username;
    }
}


// Tests
database1.addUser(new User("User1");
database2.addUser(new User("User1");
database3.addUser(new User("User1");

// This is an example of Shallow Copying
List<IUser> users = database1.getAllUsers();
users.clear();
users.get(2).setUsername("User4");

assertEquals(true, database1.containsUsername("User 2"));
```

# Bugs with References

Shallow copying of `ArrayList`:
```java
List<IUser> shallowCopy = new ArrayList<>();
for (IUser user : this.users) {
    shallowCopy.add(user);
}
```

Deep copying of `ArrayList`:
```java
List<IUser> shallowCopy = new ArrayList<>();
for (IUser user : this.users) {
    shallowCopy.add(new User(user.getUsername()));
}
```

```java
private Database(List<IUser> users) {
    this.users = users; // Bad idea -- shallow copy!
    // instead, do the following:
    this.users = new ArrayList<>(users); // only do this if the 
    // User class is immutable 
    // If it is mutable, do this:
    List<IUser> copy = new ArrayList<>();
    for (IUser user : users) {
        copy.add(user.clone());
    }
    this.users = copy;
}
```

For this differentiation, you can have a separate interface:
```java
public interface IMutableUser extends IUser {
    void setUsername(String username);
    // And, of course, remove this method from `IUser`
}
```

You can also create a `clone` method in `User`:
```java
// Also, remember to put this in the interface
public IUser clone() {
    return new User(this.username);
}
// You can also do something like this
public IUser clone(IUser other) {
    User clone = new User(this.username);
    clone.internalData = this.internalData; // Shallow copy
    return clone;
}
```

The C/C++ way would be to create a copy constructor:
```java
public User(User other) {
    this.username = other.username; // you have to copy all of the fields
    // You also have to be careful with this method because how are you
    // going to copy over complex data? Same reference? Or nested clone?
}
```

# Model, View, and Controller

A common OO technique for structuring graphical programs:
* Controller: takes input from the user and decides what to do
* View: knows how to display the interface to the user
* Model: the domain information that the user manipulates
    * Where most of the action is

The MVC system allows for a decoupled application. Every class that you write, should only be in one (either Controller, View, or Model). This means that you can remove the Model(/controller/view) and it shouldn't influence the rest.

## Example Game - Tic-Tac-Toe

Model:
* Play a move as X
* Play a move as O
* Find out whose turn it is
* Find out the contents of the grid
* Find out whether the game is over
* Find out who the winner is (if any)

Controller:
* Must give the model the correct type, but the model handles if it is valid/invalid

More analysis: error conditions:
* Play out of turn
* Play in an occupied cell
* Play after the game has ended

```java
void moveAsX(int column, int row);
void moveAsY(int column, int row);
```
In this implementation, the client needs to keep track of who's turn it is. Always give the user the least amount of privileges possible to get the job done. How can we reduce the freedom?

```java
void move(int column, int row);
```

This way, the user does not need to know who's turn it is.

```java
boolean isXsTurn();
boolean isYsTurn();
```

Can we have one method for this?
* Type `char`, with `X` for X and `O` for O
    * Don't want freedom -- You don't know for sure that there are only `X` and `O`. 
* Class `String`, with `X` for X and `O` for O
    * Even more possibles than `char`.
* Type `boolean`, with `true` for X and `false` for O
    * Isn't clear what is what 
* `int`
    * Too much freedom
* Type `boolean`, with `false` for X and `true` for O
    * Isn't clear what is what -- lose meaning 
* An enumeration defined as `enum Player` `{ X, O }`

We need a type that limits our choices and also has meaning.
We want a class that cannot be modified, has limited choices, and easily differentiable.

### Enumerations

```java
public class PlayerType {
    public final static String X = "X";
    public final static String Y = "Y";
}

// then we can call it with:
PlayerType.X
```

This is a lot better, but it's still a String.

This is what `enum`s do behind the scenes:
```java
final public class PlayerType { // final means that it cannot be extended
    private PlayerType() {};
    // Remember objects are references or address
    public final static PlayerType X = new PlayerType();
    public final static PlayerType Y = new PlayerType();
}
```

Now we can't break with with other Strings. You have limited amount of choices. We also don't have to override `.equals()` because we *want* to compare addresses.

```java
// This is the same thing as above:
public enum PlayerTypeEnum {
    X, Y;
}
```

You can also add things to the `enum`:
```java
public enum PlayerTypeEnum {
    X("X"), Y("Y");
    
    private final String type;
    private PlayerTypeEnum(String type){ 
        this.type = Objects.requireNonNull(type);
    }
    
    @Override
    public String toString() {
        return this.type;
    }
}

```

For homework 2, the implementation would look like:
```java
public enum Suite {
    DIAMOND("♦"), HEART("♥"), SPADE("♠"), CLUB("♣");
    private final String suite;
    Suite(String suite) {
        this.suite = suite;
    }
    
    @Override
    public String toString() {
        return this.suite;
    }
}

public enum Value {
    private final int value;
    
    ACE(1), TWO(2), THREE(3), FOUR(4), FIVE(5), SIX(6) ..., JACK(11), QUEEN(12), KING(13);
    // private final String stringValue;
    // JACK("J"), QUEEN("Q") ... etc
    
    // You can also overload constructors
    Value(String stringValue) {
    // TODO: Finish
    }
    
    Value(int value) {
        if (value < 1 ||  value > 13) {
            throw new IllegalArgumentException("Card values can be between 1- 13");
        }
        
        this.value = value;
    }
    
    int getValue() {
        return this.value;
    }
}

public class Card implemtnts ICard {
    private final Value value;
    private final Suite suite;
    
    public Card(Value value, Suite suite) {
        this.value = Objects.requireNonNull(value);
        this.suite = Objects.requireNonNull(suite);
    }
    
    @Override
    public Suite getSuite() {
        return this.suite; // Can be a shallow copy because they are final
    }
    
    @Override
    public Value getValue() {
        return this.value;
    }
    
    @Override
    public String toString() {
        return super.toString();
    }
}
```

The default for a template object is `Object`. 

For homework 2, `ICard` should be an interface. You should create an interface for most classes that you write.

### Wildcard

By putting a question mark `?`, you don't have to declare the parameter in the class/interface.

We want to do the following. That is, we want to pass in a field without declaring the types.
```java
FreecellView view = new FreecellTextView(model);
```

```java
public class FreecellTextView implements FreecellView  {
// you could also do:
// public class FreecellTextView<ICard> implements FreecellView<ICard> {
    // private final FreecellMode<ICard> model; // Don't do this. This is too tightly coupled
    private final FreecellMode<?> model;
    // You could also do:
    // private final FreecellMode<? extends/implements AnotherObject> model;
    
    public FreecellTextView(FreecellMode<?> model) {
        if (model == null) {
            throw new IllegalArgumentException("Model cannot be null");
        }
        
        this.model = model;
    }
    
    @Override
    public String toString() {
        // We need to use the model observers to generate the 
        // desired output from the homework description
        return "";
    }
}
```

# Builder Pattern

Recall out TicTacToe interface from last lecture:
```java
public interface ITicTacToe {
    PlayerType nextPlaer();
    void move(int x, int y);
    boolean isGameOver();
    PlayerType getWinner();
}
```

There are many different ways to implement the game.

The board:
```java
public class TicTacToeImpl implements ITicTacToe {
    private final PlayerType [][] board;
    // Or you could do something like:
    // private final ArrayList<ArrayList<PlayerType>> listBoard;
    // Because you already know the size, use the Array implementation -- it saves space
    private final PlayerType [] players;
    private final int winGoal;
    public TicTacToeImple() {
        this.board = new PlayerType[3][3];
        this.players = new PlayerType[2];
        this.players[0] = PlayerType.X;
        this.players[1] = PlayerType.Y;
        this.winGoal = 3;
    }
    @Override
    public PlayerType nextPlayer() {
    }
    
    @Override
    public void move(int x, int y) {
    } 
}
```

This relates to Homework 2.

What if we want our constructor to be more customizable?

```java
public interface INConnect {
    void move(int col);
    PlayerType getWinner();
    boolean isGameOver();
}

public class NConnectImpl implements INConnect {

    public NConnectImpl() {
        this.width = 4;
        this.height = 4;
        this.winGoal = 3;
        this.players = PlayerType.values();
        
    }
    
    @Override
    public void move(int col) {
    }
    
    @Override
    public PlayerType getWinner() {
    }
    
    @Override
    public boolean isGameOver() {
        return false;
    }
}
```

We want to keep our fields final, but also we want to have a setter to our user can customize the fields. We also don't want setters because that means that we can modify the game mid-game. Instead, we use a **Builder Pattern**.
* Also, adding a bunch of constructors is not good -- it gets confusing

```java
// Inner class
public class NConnectImpl implements IConnect {
    private NConnectImpl(int width, int height, int winGoal, PlayerType[] players, int depth) {
        // Fill this in
        this.width = width;
        this.height = height;
        this.winGoal = winGoal;
        this.players = players;
        this.depth = depth;
    }
    // Inner class of the NConnectImpl
    public static final class Builder {
        private int width;
        private int height;
        private int winGoal;
        private PlayerType[] players;
        private int depth;
        
        Builder() {
            this.width = 4;
            this.height = 4;
            this.winGoal = 3;
            this.players = PlayerType.values();
            this.depth = 1;
        }
        
        void setWidth(int width) {
            this.width = width;
        }
        
        void setHeight(int height) {
            this.height = height;
        }
        
        void setWinGoal(int winGoal) {
            this.winGoal = winGoal;
        }
        
        void setPlayers(PlayerType[] players) {
            this.players = players;
        }
        
        void setDepth(int dpeth) {
            this.depth = depth;
        }
        
        INconnect build() {
            return new NConnectImpl(this.width, this.height, this.winGoal, this.players, this.dpeth);
        }
    }
}

// When building:
NConnectImpl.Builder builder = NConnectImpl.Builder();
connect = builder.build();
```

You can also have each of the `Builder`'s setters return a `Builder` (`this`). This means that you could chain them:
```java
connect = (new NConnectImpl.Builder()).setHeight(3).setDepth(2).build();
```

You can also have a static method in `NConnectImpl`:
```java
public static Builder getBuilder() {
    return new Builder();
}
```

This means that you can do this:
```java
connect = NConnectImpl.getBuilder().setHeight(3).getDepth(2).build();
```

Because no one is going to be using the real constructor, you can modify it all you want.

We want to catch errors in the constructor and not the builder because the builder could be used by multiple class, each with different constraints

For homework 2:
* Arrays are not optimal

If you have a bunch of chained `if-else` statements, you should use dynamic dispatch.

```java
public class SimpleFreecellModel implements FreecellModel<ICard> {
    private final List<ArrayList<ICard>> cascadePile;    
    
    // constructor
    cascadePile = new ArrayList<ArrayList<ICard>>();
    
    public void startGame(...) {
        cascadePile.add(deck.get(0));
        cascadePile.add(deck.get(6));
    }
    
    public void move(...) {
        // don't put the entire logic in this method
        if (source == PileTyle.CASCADE && destination == PileType.CASCADE) {
            // Use helper methods here!!
        } else if (source == PileType.CASCADE && destination == PileType.FOUNDATION) {
            // Do the move logic here
        }
        // etc
        
        // instead, do:
        // getPile is a helper method
        IPile sourcePile = getPile(source);
        IPile destPile = getPile(destination);
        
        sourcePile.addCard(destPile.getCard(index));
        destPile.removeLastCard();
    }
}

```


```java
public interface IPile<T> {
    void addCard(T card);
    void removeLastCard();
    T getLastCard();
    boolean isFull();
}

public class OpenPile implements IPile<ICard> {
    public void addCard(ICard card) {
        // do the move logic here
    }
    // etc.
}

public class CascadePile implements IPile<ICard> {
    // etc.
}

public class CascadePile implements IPile<ICard> {
    // etc.
}
```

# Controller

We normally drive the interaction of our code using our tests.

What if the users of our code aren't other developers?

```java
public class Main { // This name can be whatever
    // This signature is important, however.
    // The Array of arguments are the command line arguments
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // For the homeworks, we have to make sure that the next is an int
        int num1 = scanner.nextInt();
        int num2 = scanner.nextInt();
        System.out.println(num1 + num2);
        
    }
}
```

How do we test this?
* We need to test the logic
* We need to test the input

```java
public class CalculatorImpl implements ICalulator {
    
    @Override
    public int add(int num1, int num2) {
        return num1 + num2;
    }
}

public interface IController {
    void run(ICalculator calculator);
}

public class ControllerImpl implements IController {
    private final Readable in;
    private final Appendable out;
    
    public ControllerImpl(Readable in, Appendable out) {
        this.in = Objects.requireNonNull(in);
        this.out = Objects.requireNonNull(out);
    }
    
    @Override
    public void run(ICalculator calculator) {
        Scanner scanner = new Scanner(this.in);
        int num1 = scanner.nextInt();
        int num2 = scanner.nextInt();
        String result = Integer.toString(calculator.add(num1, num2));
        
        try { // You MUST handle the exception
            this.out.append(result);
        } catch (IOException e) {
            // TODO: figure out what to do
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Readable readable = new InputStreamReader(System.in);
        Appendable outputStream = new PrintStream(System.out);
        
        ICalculator calculator = new CalculatorImpl();
        IController controller = new ControllerImpl(readable, outputStream); 
        controller.run(calculator);
    }
}
```

In Tester File:
```java
public class CalcImplTest {
    private ICalculator calculator;
    private IController controller;
    
    @Before
    public void setUp() {
        calculator = new CalculatorImpl();
        controller = new ControllerImpl();
    }
    
    @Test
    public void add() {
        assertEquals(7, calculator.add(3, 4));
    }
    
    @Test
    public void testController() {
        Readable stringReader = new StringReader("2 4\n");
        Appendable stringBuilder = new StringBuilder();
        
        ICalculator calculator = new CalculatorImpl();
        
        IController controller = new ControllerImpl(stringReader, outputSteam);
        controller.run(calculator);
        
        assertEquals("7", stringBuilder.toString());
    }
}

```

`Readable` and `Appendable` are higher level than BtyeArrays. We always want to use the highest level possible for out implementation.

## Checked and Unchecked Exceptions

Checked exceptions: forced to catch them
* These happen at runtime

Unchecked exceptions: not forced to catch them
* Happen at compile time

## Mocks

Consider this bug:
```java
int num1 = scanner.nextInt() + 1;
int num2 = scanner.nextInt();
```

How do we know if we are reading the input wrong or if the logic is wrong?

To test this, we need to implement a mock calculator

```java
public class MockCalculator implements ICalculator {
    private final Appendable log;
    
    public MockCalculator(Appendable log) {
        this.log = Objects.requireNonNull(log);
    }
    
    @Override
    public int add(int numm1, int num2) {
        try {
            log.append(num1 + " " + num2);
        } catch (IOException e) {
            // TODO: figure out what to do if this fails
        }
        return 0;
    }
}

// in test class:
@Test
public void testReadingInput() {
    Readable stringReader = new StringReader("3 4\n");
    Appendable mockAppendable = new StringBuilder();
    
    Appendable stringBuilder = new StringReader();
    
    ICalculator mockCalculator = new MockCalculator(mockAppendable);
    
    IController controller = new ControllerImpl(stringReader, stringBuilder);
    controller.run(mockCalculator);
    
    assertEquals("3 4", mockAppendable.toString());
}
```
