---
layout: note
type: note
title: CS2510 Fundamentals of Computer Science 2
date: 2021-01-14
status: In Progress
professor: Leena Razzaq
labels:
  - CS2510
  - Computer Science
---

# The Class

[Class Website](https://course.ccs.neu.edu/cs2510/)

Fundamentals of Computer Science 1: Correct program behavior

Fundamentals of Computer Science 2: Having your code be scalable/maintainable/efficient 

2% late per hour per submission for homework assignments

Read lecture notes before coming to class

Code Review: Taking your code and explain it to somebody else
* Happens towards the end of the semester

# Introduction to Java

Data. We first started with *atomic data*. 

For example:

```scheme
;; a PosReal number representing the price of a coffee
(define coffee-price 3.5)
(define fancy-coffee (+ coffee-price 1.5))
(define extra-fancy-cofee (+ coffee-price "2 dollars")) 
; This won't work. Can't add number to integer.

;; An Auto is a (make-auto Integar Integar String PosReal)
(define-struct auto (x y color speed))
```
DrRacket doesn't know that this is wrong until you run it. `Auto` is an example
of compound data--meaning it holds multiple values.

Java is infix notation.

This code would not have *compiled*.

Java is a **strongly typed language** (data is checked at compile time). And ISL
is **dynamically typed** (data is checked at run time).

## Java Variables
In Java there are two types of numbers: Integers and Doubles. (There are more,
but we only care about these 2 for now.)

Also, you can't have dashes in Java's names--instead use camelCase.
Example in Java:
```java
// Primative Types
int distance = 3;
double coffeePrice = 3.5;
String hi = "hello";
char a = 'a';
boolean isSunny = false;
```

Why is String capitalized? Because it is not a primitive data type. 

## Compound Data in Java
### Example - Auto

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/autodiag.svg'>
</div>

```java
class Auto {
    //int x;
    //int y;
    Location loc;
    String color;
    double speed;
    //Auto(int x, int y, String color, double speed){ // This is a constructor
    Auto(Location loc, String color, double speed){
        //this.x = x; // _this_ means the one in the class
        //this.y = y;
        this.loc = loc;
        this.color = color;
        this.speed = speed;
    }
}
class Location{
    int x;
    int y;
    Location(int x, int y){
        this.x = x;
        this.y = y;
    }
}
class ExamplesAuto{
    Location Loc34 = new Location(3, 4);
    Auto car1 = new Auto(Loc34, "red", 50.0);
    ExamplesAuto(){}
}

```

# Unions

### Example - Spaceships


<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/space-ship-example.png'>
</div>

**Racket**:
```scheme
(define-struct invader (loc color bullets size))
;; An Invader is a (make-invader Posn String PosInt PosInt

(define invader1 (make-invader (make-posn 60 120) "green" 30 3))

#;(define (invader-temp1 inv)
    (posn-temp1 (invader-loc inv))
    (invader-color inv)
    (invader-bullets inv)
    (invader-size inv))

(define-struct ship (loc color speed))
;; A Shapeship is a (make-ship Posn String PosInt)
;; interp.: loc is a position on the Cartesian plane
;; speed is measured in miles/hour
    

;; A GamePiece is one of:
;; - Spaceship
;; - Invader

```

NOTE: The Union data type is only in comments in DrRacket. In Java, however,
this is not in comments.

**Java**
```java
interface IGamePiece {}

// Represents an Invader in the game
class Spaceship implements IGamePiece {
    Location loc
    String color;
    int speed;
    Spaceship(Location loc, String color, int speed){
        this.loc = loc;
        this.color = color;
        this.speed = speed;
    }
}

// Represents an Invader in the game
class Invader implements IGamePiece {
    Location loc
    String color;
    int bullets;
    int size;
    Invader(Location loc, String color, int bullets, int size){
        this.loc = loc;
        this.color = color;
        this.bullets = bullets;
        this.size = size;
    }
}

// A class to represent a location on the Cartesian plane
class Location {
    int x;
    int y;
    Location(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Examples {
    // You cant do the line below because it doesn't know what loc1 is yet
    //Spaceship ship = new Spaceship(this.loc1, "blue", 55);
    
    Location loc1 = new Location(30, 40);
    Location loc2 = new Location(60, 80);
    // Represents two IGamePieces: Spaceships and Invaders
    IGamePiece ship = new Spaceship(this.loc1, "blue", 55);
    IGamePiece invader1 = new Invader(this.loc2, "pink", 30, 3);
    
    // You can still do this, but it's bad practice
    //Spaceship ship = new Spaceship(new Location(30, 40), "blue", 55); 
    
}
    
```

`IGamePiece` is the type at compile time

`Spaceship/Invader` is the type at run-time

Use the `this` keyword anytime you can--it removes ambiguity.

In Java, Unions are **interfaces**. The reason we would want to declare a
variable by it's Union is so it can be that type--which means that we can use
more general operations.

### Example - Ancestor Tree

**Racket**:
```racket
;; A Person is a (make-person String Person Person)
(define-struct person (name mom dad))

(define alice (make-person "Alice" 
                (make-person "Sally"
                    (make-person "Abby"
                        ...
; this issue with this definition is that you cannot stop--you need a base case
; for referential data

;; An AT is one of:
;; - #false
;; - (make-person String AT AT)
```

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/fam-tree-ex-lec-2.png'>
</div>

**Java**:
```java
interface IAT{}

// Class to represent an unknown in an ancestor tree
class Unknown implements IAT {
    Unknown() {}
}

// Class to represent a person in an ancestor tree
class Person implements IAT {
    String name;
    int yob
    IAT mom;
    IAT dad;
    
    Person(String name, int yob, IAT mom, IAT dad) {
    this.name = name;
    this.yob = yob;
    this.mom = mom;
    this.dad = dad;
    }
}
```

# Methods

**Recall the design recipe for functions:**

* Signature
* Purpose Statement
* Examples/Tests
* Code
* Run

Consider the DrRacket code:

```scheme
;; Spaceship Integer -> Integer
;; produces a reduced speed for the given spaceship based on a given percentage
(check-expect (reduced-speed ship1 20) 80) ; ship1 has a speed of 100
(check-expect (reduced-speed ship2 50) 25) ; ship2 has a speed of 25 

(define (reduced-speed ship rate)
    (- (ship-speed ship) (/ (* (ship-speed ship) rate) 100)))
```

## Template
What do I have to work with?

You have to do a template for each class
* If a method takes in a complex data type, you need another template:
```java
/* everything in template above plus
* fields:
* ...
* methods:
* ...
* methods for fields:
* ...
```

In Java, we just list the things:
```java
import tester.*;

interface IGamePiece {
    //moves this IGamePiece by the given x and y
    IGamePiece move(int x, int y); //tells the program that every GamePiece has this method
}

// Represents an Invader in the game
class Invader implements IGamePiece {
    Location loc
    String color;
    int bullets;
    int size;
    
    Invader(Location loc, String color, int bullets, int size){
        this.loc = loc;
        this.color = color;
        this.bullets = bullets;
        this.size = size;
    }
    
    /* TEMPLATE HERE
    *
    */
    
    public IGamePice move(int x, int y){
        return new Invader(this.loc.move(x, y), this.color, this.bullets, this.size);
    }
}

// Represents an Spaceship in the game
class Spaceship implements IGamePiece {
    Location loc;
    String color;
    int speed; //in miles per hour
    
    Spaceship(Location loc, String color, int speed) {
        this.loc = loc;
        this.color = color;
        this.speed = speed;
    }
    
    /* fields:
    *   this.local ... Location
    *   this.color ... String
    *   this.speed ... int
    * methods:
    *   this.reducedSpeed(int) ... int
    *   this.move(int, int) ... Spaceship
    * methods for fields:
    *   this.loc.moveLocation(int, int) ... Location
    */
    
    // produces a reduced speed for this spaceship based on the given percentage
    int reducedSpeed(int rate) {
        return this.speed - ((this.speed * rate) / 100);
    }
    
    // produces a new spaceship that is shifted from this spaceship by the given x and y
    Spaceship move(int x, int y){
        return new Spaceship(this.loc.move(x,y), this.color, this.speed);
    }
}

class Location {
    int x;
    int y;
    Location(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    /* fields
    *   this.x ... int
    *   this.y ... int
    * methods:
    *   this.moveLocation(int, int) ... Location
    */
    
    //Create a new Location that is shifted from this location by a given x and y
    Location move(int x, int y){
        return new Location(this.x + x, this.y + y);
    }
}

class Examples {
    Location loc1 = new Location(30, 40);
    Location loc2 = new Location(60, 80);
    
    Spaceship ship1 = new Spaceship(this.loc1, "blue", 100);
    Spaceship ship1 = new Spaceship(this.loc2, "pink", 30);
    
    //tests for reducing speed
    boolean testReducedSpeed(Tester t) { //these test methods need to start with the word `test`
        return t.checkExpect(this.ship1.reducedSpeed(20), 80) &&
               t.checkExpect(this.ship2.reducedSpeed(50), 15);
    }
    
    //tests for move
    boolean testMove(Tester t){
        return t.checkExpect(this.ship1.move(1, 2), 
               new Spaceship(new Location(31, 42), "blue", "100")) &&
               t.checkExpect(this.loc1.moveLocation(2, 3), new Location(32, 43));
    }
    
    //tests for move
    boolean testMove(Test t){
        return t.checkExpect(this.ship1.move(10, 20),
                            new Spaceship(new Location(40, 60), "blue", 55));
    //notice that we never ask if something is a Spaceship
}
```

## Methods for Unions

We can use the color class by importing the image library.

**Incorrect**:
```java
import java.awt.Color
import javalib.worldimages.*

//...

//In Spaceship class
WorldImage draw() {
    return new CircleImage(50, "solid", this.color)
}

// in Examples class
IGamePiece ship1 = new Spaceship(this.loc1, Color.BLUE, 55);

this.ship.draw() 
// this wouldn't work because draw is in the Spaceship class, NOT IGamePice (which ship1 is)
```

So in this case, you would want to put `draw()` in the interface (not just the `ship` class).

**Correct**:
```java
import java.awt.Color;
import javalib.worldimages.*;

interface IGamePice {
    //...
    WorldImage draw();
}

//...

//in spaceship class
public WorldImage draw() {
    return new EllipseImage(50, 60, "solid", this.color);
}

//In invader class
public WorldImage draw() {
    return new ...
}
```


### Example - Shape

```java
interface IShape {
    double area();
    boolean biggerThan(IShape that);
}

class Circle implements IShape {
    CartPt center;
    int radius; 
    String color;
    
    Circle(CartPt center, int radius, String color){
        this.center = center;
        this.radius = radius;
        this.color = color;
    }
    /*
     // ** TEMPLATE ** 
     public returnType methodName() {
     ... this.center ...              -- CartPt
     ... this.radius ...              -- int
     ... this.color ...               -- String
     
     ... this.area() ...                  -- double 
     ... this.distToOrigin() ...          -- double 
     ... this.grow(int inc) ...           -- IShape
     ... this.biggerThan(IShape that) ... -- boolean
     ... this.contains(CartPt pt) ...     -- boolean
     */
     // See Lecture code for all of these methods
    
    public double area(){
        return Math.PI * Math.pow(this.radius, 2);
    }
    
    public boolean biggerThan(IShape that){
        return this.area() > that.area();
    }
}

class Square implements IShape {
    CartPt nw;
    int size;
    String color;
    
    Square(CartPt nw, int size, String color) {
        this.nw = nw;
        this.size = size;
        this.color = color;
    }
    
        /*
     // ** TEMPLATE ** 
     returnType methodName() {
     ... this.nw ...              -- CartPt
     ... this.size ...            -- int
     ... this.color ...           -- String
     
     ... this.area() ...                  -- double 
     ... this.distToOrigin() ...          -- double 
     ... this.grow(int inc) ...           -- IShape
     }
     */
    
    // to compute the area of this shape
    public double area(){
        return this.size * this.size;
    }
    
    public boolean biggerThan(IShape that){
    /* everything in the Circle template plus:
    * fields of that:
    *
    * methods of that:
    * that.area() ... double
    */
        return this.area() > that.area();
    }
}

class CartPt {
    int x;
    int y;
    
    CartPt(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    // to compute the distance form this point to the origin
    public double distToOrigin(){
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    
    // to compute the distance form this point to the given point
    public double distTo(CartPt pt){
        return Math.sqrt((this.x - pt.x) * (this.x - pt.x) + 
                         (this.y - pt.y) * (this.y - pt.y));
    }
}
```

**You can also nest interfaces**:
<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec4-fig1.svg'>
</div>
```java
class Combo implements IShape {
    IShape top;
    IShape bottom;
    
    Combo(IShape top, Ishape bottom) {
        this.top = top;
        this.bottom = bottom;
    }
    
    /* fields:
    *   this.top ... IShape
    *   this.bottom ... IShape
    * methods:
    *   this.area() ... double
    *   this.biggerThan(IShape) ... boolean
    * methods for fields:
    *   this.top.area() ... double 
    *   this.bottom.area() ... double
    *   this.top.biggerThan(IShape) ... boolean
    *   this.bottom.biggerThan(IShape) ... boolean
    */
    
    public double area() {
        return this.top.area() + this.bottom.area();
    }
    
    public double biggerThan(IShape that){
        return this.area() > that.area();
    }
}

class ExamplesShapes{
    IShape combo1 = new Combo(this.c1, this.s1); //both c1 and s1 are IShapes
    IShape combo2 = new Combo(this.combo1, this.combo1);
}
```

## Methods for Self-referential lists 

Recall list of numbers from Fundies 1:
```scheme
;; A [List-of Number] is one of:
;; - '()
;; - (cons Number [List-of Number])
```
Notice the self-referential nature of this. 

### Example - List of Integers
<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec5-fig1.svg'>
</div>

```java
interface ILoInteger{}

class MtLoInteger implements ILoInteger {} 
// By not having a constructor, it has the 'default' constructor which is nothing

class ConsLoInteger implements ILoInteger {
    int first;
    ILoInteger rest;
    
    ConsLoInteger(int first, ILoInteger rest) {
        this.first = first;
        this.rest = rest;
    }
}
```

Recall the template from Fundies 1:
```scheme
(define (Lon-temp alon)
    (cond [(empty? alon) ... ]
          [(cons? alon) ... (first alon)...
                            (lon-temp (rest alon)) ...]))
```

### Example - Painting

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec5-fig2.svg'>
</div>

```java
interface ILoPainting {
    //count the paintings in this list
    int count();
    //get the paintings in this list that are by the artist with the given name
    ILoPainting getByArtist(String name) {}
}

class MtLoPainting implements ILoPainting {
    /*
    methods:
        
    */
    
    // count the paintings in this MtLoPainting
    public int count(){
        return 0;
    }
    
    ILoPainting getByArtist(String name){
        return this;
    }
}

class ConsLoPainting implements ILoPainting {
    Painting first;
    ILoPainting rest;
    
    ConsLoPainting(Paining first, ILoPainting rest) {
        this.first = first;
        this.rest = rest;
    }
    
    /* fields:
        this.first ... Painting
        this.rest ... ILoPainting
       Methods:
        this.count() ... int
       Methods for fields:
        this.rest.count() ... Int
        this.rest.getByArtist(String) ... ILoPainting
    */
    public int count() {
        return 1 + this.rest.count();
    }
    
    ILoPainting getByArtist(String name) {
        if (this.first.getName(name)){
            return new ConsLoPainting(this.first, this.rest.getByArtist(name));
        } 
        else {
            return this.rest.getByArtist(name);
        }
    }
}

class Painting {
    Artist artist;
    String title;
    double price; // price in millions of dollars
    int year;
    
    Painting(Artist artist, String title, int price, int year) {
        this.artist = artist;
        this.title = title;
        this.price = price;
        this.year = year;
    }
    /* fields:
        this.artist ... Artist
        this.title ... String
        this.price ... Int
        this.year ... Int
       methods:
        this.count() ... int
        this.getByArtist(String) ... ILoPainting
       methods for fieds:
        this.artist.checkArtistName(String) ... boolean
    */
    
    //is the name of the artist of this Painting the same as the given one?
    boolean checkName(String name) {
        return this.artist.checkArtistName(name); 
    }
}

class Artist {
    String name;
    int yob;
    
    Artist(String name, int yob) {
        this.name = name;
        this.yob = yob;
    }
    
    /* fields
        this.name ... String
        this.yob ... int
       methods:
        this.checkArtistName(String) ... boolean
    */
    
    //is this artist's name the same as the given one?
    boolean checkArtistName(String name) {
        return this.name.equals(name);
    }
}

class Examples {
    ...
    ILoPainting mt = new MtLoPainting();
    ILoPainting list1 = new ConsLoPainting(this.mona, this.mt);
    ILoPainting list2 =new ConsLoPainting(this.sunflowers, list1);
}
```

### If Statement
```java
if (true-or-false-question) {
    runs if true
}
//the rest is optional
else {
    runs if false
}
```

### Insertion Sort

```java
//in interface:

    ILoPainting sortByYear();
    //inserts the given painting into this sorted list
    ILoPainting insertByYear(Painting p);

// in empty list
    public ILoPainting sortByYear() {
        return this;
    }

    public ILoPainting insertByYear(Painting p) {
        return new ConsLoPainting(p, this);
    }
// in ConsLoPainting
    public ILoPainting sortByYear() {
        return this.rest.sortByYear().insertByYear(this.first);
    }
    
    //insert the painting into this sorted list,
    //list remains sorted after exiting the method
    public ILoPainting insertByYear(Painting p) {
        if (this.p.paintedBefore(first)) {
            return new ConsLoPainting(p, this);
        }
        else {
            return new ConsLoPainting(this.first, this.rest.insertByYear(p));
        }
    }
// in Painting
    boolean paintedBefore(Painting p) {
        return this.year < p.year;
    }
// in examples
    boolean testSort(Tester t) {
        return t.checkExpect(this.list2.sortByYear(), 
                             new ConsLoPainting(this.mona, 
                             new ConsLoPainting(this.sunflowers, this.mt)));
    }

```

## Accumulator Methods


When to use an accumulator:
1. What information do you need to keep track of? Add a parameter
2. What is the starting information? Remember it
3. How does the function accumulate knowledge? Is it `+`, `cons`, selector?
4. How do you use the accumulator? 
Wrapped in a local -- or helper -- and initialized with starting information

### Example - List of Strings
```java
interface ILoString {
    //concatenate the strings in this list in reverse order
    String reverseConcat();
    //helps to reverse concatenate this list
    //accumulator: reversed concatenated string so far
    String reverseConcatAcc(String acc);
}

class MtLoString implements ILoString {
    //concatenate the strings in this list in reverse order
    String reverseConcat(){
        return "";
    }
    
    //helps to reverse concatenate this list
    //accumulator: reversed concatenated string so far
    String reverseConcatAcc(String acc) {
        return acc;
    }
}

class ConsLoString implements ILoString {
    String first;
    ILoString rest;
    
    ConsLoString(String first, ILoString rest) {
        this.first = first;
        this.rest = rest;
    }
    
    //concatenate the strings in this list in reverse order
    String reverseConcat() {
        return this.reverseConcatAcc("");
    }
    
    //helps to reverse concatenate this list
    //accumulator: reversed concatenated string so far
    String reverseConcatAcc(String acc) {
        return this.rest.reverseConcatAcc(this.first + " " + acc);
    }
}
```

### Example - IAT
```java
interface IAT {
    //list the names in this tree
    ILoString names();
    //helps accumulate the names on the dad's side of the tree
    //accumulator: keeps track of the names on the dad's side
    ILoString namesAcc(ILoString acc);
    
    //is this tree well-formed?
    boolean wellFormed();
    
    //help to check if this tree is well-formed
    //accumulator: keeps track of the child's year of birth
    boolean wellFormedHelp(int childYob);
    
    //produce the IAT that is younger between this IAT and a given one
    IAT youngerIAT(IAT other);
    
    //produce the IAT that is younger between this IAT and a given one
    IAT youngerIATHelp(IAT other, int yob);
}

class Unknown implements IAT {
    Unknown() {}
    
    public ILoString names() {
        return new MtLoString();
    }
    
    public ILoString namesAcc(ILoString acc){
        return acc;
    }
    
    boolean wellFormed() {
        return true;
    }
    
    boolean wellFormedHelp(int childYob) {
        return true;
    }
    
    public youngerIAT(IAT other) {
        return other;
    }
    
    public IAT youngerIATHelp(IAT other, int yob){
        return other;
    }
}

class Person implements IAT {
    String name;
    int yob;
    IAT mom;
    IAT dad;
    
    Person(String name, int yob, IAT mom, IAT dad) {
        this.name = name;
        this.yob = yob;
        this.mom = mom;
        this.dad = dad;
    }
    
    public ILoString names() {
        return this.namesAcc(new MtLoString());
    }
    
    public ILoString namesAcc(ILoString acc){
        return new ConsLoString(this.name, this.mom.names(this.dad.names(acc)));
    }
    
    boolean wellFormed() {
        return this.mom.wellFormedHelp(this.yob) &&
               this.dad.wellFormedHelp(this.yob);
    }
    
    boolean wellFormedHelp(int childYob) {
        return this.yob < childYob &&
               this.mom.wellFormed(this.yob) &&
               this.dad.wellFormed(this.yob);
    }
    
    public youngerIAT(IAT other) {
        return other.youngerIATHelp(this, this.yob); //you don't have to ask what other is
    }
    
    public IAT youngerIATHelp(IAT other, int year){
        if(this.yob > year) {
            return this;
        } else {
            return other;
        }
    }
}
```

Another way to do this problem is to append the father list and the mother list before putting them into the `consLoString`:

```java
public ILoString names2() {
    return new ConsLoString(this.name, this.mom.names2().append(this.dad.names2()));
}
```

# Practice Design

See [Lecture 8](https://course.ccs.neu.edu/cs2510/lecture8.html) for the problems.

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec8-fig1.png'>
</div>

```java

class Author {
  String first;
  String last;
  
  Author(String first, String last) {
    this.first = first;
    this.last = last;
  }
  
  String getBib() {
    return this.last + ", " + this.first + ".";
  }
}

interface IBib {
  ILoString sources();
}

class Book implements IBib {
  Author author;
  String title;
  String publisher;
  ILoBib bibs;
  
  Book(Author author, String title, String publisher, ILoBib bibs) {
    this.author = author;
    this.title = title;
    this.bibs = bibs;
    this.publisher = publisher;
  }

  public ILoString sources() {
    return new ConsLoString(this.author.getBib() + "\"" + this.title + "\"", this.bibs.sourcesFromList());
  }

}

class wikiArticles implements IBib {
  Author author;
  String title;
  String url;
  ILoBib bibs;
  
  wikiArticles(Author author, String title, String url, ILoBib bibs) {
    this.author = author;
    this.title = title;
    this.url = url;
    this.bibs = bibs;
  }

  public ILoString sources() {
    return this.bibs.sourcesFromList();
  }
}

interface ILoString {
  ILoString append(ILoString other);
}


class MtLoString implements ILoString {

  public ILoString append(ILoString other) {
    return other;
  }
  
}

class ConsLoString implements ILoString {
  String first;
  ILoString rest;
  
  ConsLoString(String first, ILoString rest) {
    this.first = first;
    this.rest = rest;
  }

  public ILoString append(ILoString other) {
    return null; // TODO: See previous lectures for append method
  }
}

interface ILoBib {

  ILoString sourcesFromList();}

class MtLoBib implements ILoBib {
  public ILoString sourcesFromList() {
    return new MtLoString();
  }
}

  

class ConsLoBib implements ILoBib{
  IBib first;
  ILoBib rest;
  
  ConsLoBib(IBib first, ILoBib rest){
    this.first = first;
    this.rest = rest;
  }

  public ILoString sourcesFromList() {
    //return new ConsLoString(this.first.sources(), this.rest.sourcesFromList());
    return this.first.sources().append(this.rest.sourcesFromList());
  }
}
```

Problem 2 variant A

See if a given List has all of these requirements:
* A number that is even
* A number that is positive and odd
* A number between 5 and 10, inclusive

```java
interface ILoInt {
    //checks if this list satisfies the three requirements
    boolean satisfies();
    //helps check if the list satisfies the requirements
    // aaccumulators: keeps track of whether each requirement was satisfied
    boolean satisfiesAcc(boolean even, boolean odd, boolean bet5and10);
}

class MtLoInt implements ILoInt {

    public boolean satisfies() {
        return false;
    }
    
    public boolean satisfiesAcc(boolean even, boolean odd, boolean bet5and10) {
        return even && odd && bet5and10;
    }

}

class ConsLoInt implements ILoInt {
    int first;
    ILoInt rest;
    
    ConsLoInt(int first, ILoInt rest) {
        this.first = first;
        this.rest = rest;
    }
    
    public boolean satisfies() {
        return satisfiesAcc(false, false, false);
    }
    
    public boolean satisfiesAcc(boolean even, boolean odd, boolean bet5and10) {
        return (even && odd && bet5and10) ||
               (this.rest.satisfiesAcc(even || this.first % 2 == 0, 
                                      odd || (this.first % 2 == 1 && this.first > 0),
                                      bet5and10 || (this.first >= 5 && this.first <= 10)));
    }
}

class Examples {

}
```

If you are working with booleans, you don't need an `if` statement.

### Working with Images

```java
WorldCanvas c = new WorldCanvas(300, 500);
WorldImage img1 = this.ship2.draw();
WorldImage img2 = new VisiblePinholeImage(img1).movePinholeTo(new Posn(20, 0));
img 2 new OverlayImage(new RectangleImage(30, 30, "solid", color.Black), img2);
WorldScene s = new WorldScene(300, 500), placeImageXY(img3, 150, 150);
```

# Abstract Classes and Inheritance

Consider our `IShape` definition:

Remember that the `Square` and `Circle` classes have similarities.

For example: `CartPt center`, `String color`

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec9-fig1.png'>
</div>

NOTE: There is `IShape` above `AShape`

```java
//underneath IShape
abstract class AShape implements IShape{
    CartPt location;
    String color;
    
    AShape(CartPt location, String color) {
        this.location = location;
        this.color = color;
    }
    
    //compuete the area of this AShape
    public abstract double area();
    
    public double distToOrigin() {
        return this.location.distToOrigin();
    }
    
    public boolean biggerThan(IShape other) {
        return this.area() >= other.area();
    }
}

class Circle extends AShape {
    int radius;
    
    Circle(CartPt center, int radius, String color) {
        super(center, color);
        this.radius = radius;
    }
    
    public double distToOrigin() { //overriding the one in parent class
        return this.location.distToOrigin() - this.radius;
    }
}


class Rect extends AShape {
    int width;
    int height;
    
    Rect(CartPt nw, int width, int height, String color) {
        super(nw, color);
        this.width = width;
        this.height = height;
    }
}

class Square extends Rect {
    Square(CartPt nw, int size, String color) {
        super(nw, size, size, color);
    }
}
```

The extends means that it inherits everything from `AShape`. And because `AShape` implements `IShape`, so does `Circle`, `Square`, and `Recte`.

You cannot make instances of `AShape` (because it is abstract).

You need to say `super(VARS)` to send the parameters to the constructor.

You need templates for abstract classes.

You can extend classes that aren't abstract.

You can override abstract classes
* It runs the most local method

<details>
  <summary>
  Why have an abstract class and an interface?
  </summary>
  
  It's going to make our code more flexible when we want to add more things to our IShapes.  
  
</details>

<details>
  <summary>
  Should a Combo shape be AShape?
  </summary>
  
  No; it doesn't have location or color.
  
</details>

# Customizing Constructors for Correctness and Convenience 

### Overriding
```java

abstract class A {
    int foo() { return 0;}
}

class B extends A {
    public int foo() { return 1;}
}
```

### Overloading

```java
class A {
    String hi() { 
        return "hello";
    }
    String hi(String name) { 
        return "hello, " + name;
}
```


Recall `IGamePiece`.

```java
...
interface IGamePiece {
    //Constant for the starting position
    Location START_LOCATION = new Location(150, 0);
    ...
}

abstract class AGamePiece implements IGamePiece {
    Location loc;
    Color color;
    
    AGamePiece(Location loc, Color color) {
        this.loc = loc;
        this.color = color;
    }
    
    // Overloading
    AGamePiece(Color color) {
        this(START_LOCATION, color);
    }
}
class Invader extends AGamePiece {
   int bullets;
   int size;
   
   Invader(Location loc, Color color, int bullets, int size) {
    super(loc, color);
    this.bullets = bullets;
    this.size = size;
   }
   
   //Overloading
   Invader(Color color, int b, int s) {
    super(color);
    this.bullets = b;
    this.size = s;
   }
   ...
}

class Spaceship extends AGamePiece {
    int speed;
    
    Spaceship(Location loc, Color color, int speed) {
        super(loc, color);
        this.speed = speed;
    }
    
    Spaceship(Color color, int speed) {
        super(color);
        this.speed = speed;
    }
}
...
```

<details markdown="1">
  <summary>
  How do you call one constructor using another?
  </summary>
  
  Use `this`. Ex: `this(c, l)`.
  
</details>

<details markdown="1">
  <summary>
  What is overloading?
  </summary>
  
  Its when you have two methods have the same name but different parameters.
  
</details>

### Rules for Classes
```java
class Date {
    int month;
    int day;
    int year;
    
    //constructor for data integrity
    Date(int m, int d, int y) {
        Utils u = new Utils();
        
        this.month = u.checkRange(m, 1, 12, "Month is invalid");
        this.day = u.checkRange(d, 1, 31, "Day is invalid");
        this.year = u.checkRange(y, 1900, 2050, "Year is invalid");
    }
    
    // constructor for convenience
    Date(int m, int d) {
        this(m, d, 2021);
    }
}

class Utils {
    // Checks that the given int is within some range
    int checkRange(int n, int low, int high, String message) {
        if (n <= high && n >= low) {
            return n;
        } else {
            throw new IllegalArgumentException(message);
        }
}

class ExamplesDates {
    Date today = new Date(2, 10, 2021);
    Date lastChristmas = new Date(12, 25, 2020);
    // This shouldn't be allowed
    // Date badDate = new Date(-12, 120, 2);
    
    boolean testDates(Tester t) {
        return t.checkConstructorExceptions(new IllegalArgumentException("Month is invalid"),
                                            "Date", -3, 120, 5000) &&
               t.checkException(new IllegialArgumentException("nope"),
                                new Utils(), "checkRange", 30, 10, 2, "nope");
    }
}
```

# Defining Sameness for Complex Data

### Properties of Sameness
* Reflexivity - `A` is the same as `A`
* Symmetry - if `A` is the same as `B`, then `B` is the same as `A`.
* Transitivity - if `A` is the same as `B` and `B` is the same as `C`, then `A` is the same as `C`.
* Totality - comparing any two objects of the same type should get the correct answer

**Primitive Data**:

Ints:
```java
int x = 1;
int y = 2;

x == y //False
```

Doubles:
```java
double w = 1.5;
double z = 1.5;

w - z <= 0.0001 // Close enough
```

Booleans:
```java
boolean t = true;
boolean s = false;

t == s
```

Strings (not actually primitive):
```java
String c = "hi";
String d = "hi";

c.equals(d);
```

What about for complex data?

Consider a `Circle` from `IShape`.

```java
// in circle class
boolean sameCircle(Circle that) {
    return this.radius == that.radius &&
        this.color.equals(that.color) &&
        this.location.sameLocation(that.location);
    
}

// in location class
boolean sameLocation(Location that) {
    return this.x == that.x &&
        this.y == that.y;
}

// in examples
return t.checkExpect(this.c1.sameCircle(c2), false); 
// but at compile time, these are both IShape and not circles.
```

We want to be able to compare two `IShape`s.

We need to cast it. And we need type checkers so we don't cast a random thing as a circle.
```java
// in circle
public boolean sameShape(IShape that) {
    if (that instanceof Circle) {
     return this.sameCircle((Circle) that);
    } else {
     return false;
    }
}

// in examples
return t.checkExpect(this.c1.sameShape(c2), false) &&
    t.checkExpect(this.c1.sameShape(c1), true) &&
    t.checkExpect(this.c1.sameShape(r1), false);
```

`instanceof` follows the "is-a" arrows
* c1 instance of Circle -> true
* c1 instance of Rect -> false
* c1 instance of IShape -> true
* c1 instance of AShape -> true

`instanceof` returns true too often
* square instance of rect -> true
* rect instance of square -> false

Violates the law of symmetry

How can we get around this?
* Make our own type checkers

```java
//in abstract class

public boolean isCircle() { return false; }
public boolean isRect() { return false; }
public boolean isSquare() { return false; }

public boolean sameCircle(Circle that) { return false; }
public boolean sameRect(Rect that) { return false; }
public boolean sameSquare(Square that) { return false; }

```

And just override it once in each class.


**Double dynamic dispatch**:
```java
// in circle class
public boolean sameShape(IShape that) {
    return that.sameCircle(this);
}
// in combo class
public booleam sameCombo(Combo that) {
    return this.top.sameShape(that.top) &&
        this.bot.sameShape(that.bot);
}
```
Another example:

```java
//in IFoo
boolean sameFoo(IFoo that)
boolean sameX(X that)
boolean sameY(Y that)
boolean sameZ(Z that)
// in AFoo
boolean sameX(X that) { return false; }
boolean sameY(Y that) { return false; }
boolean sameZ(Z that) { return false; }
// in X:
boolean someFoo(IFoo that) {
    return that.sameX(this);
}

boolean sameX(X that) {
    return ... this.field == that.field ...; //compare all fields
}
// the same for the rest of the classes
```

### Sameness for Lists

```java
interface ILoInt {
    // is this ILoInt the same as the given one?
    boolean sameLoInt(ILoInt that);
    // is this ILoInt the same as the given ConsLoInt?
    boolean sameCons(ConsLoInt that);
    // is this ILoInt the same as the given MtLoInt?
    boolean sameMt(MtLoInt that);
}
class MtLoInt implements ILoInt {
    // is this ILoInt the same as the given one?
    boolean sameLoInt(ILoInt that) {
        return that.sameMt(this);
    }
    
    boolean sameCons(ConsLoInt that) {
        return false;
    }
    
    boolean sameMt(MtLoInt that) {
        return true;
    }
}
class ConsLoInt implemneets ILoInt {
    
    // is this ILoInt the same as the given one?
    boolean sameLoInt(ILoInt that) {
        return that.sameCons(this);
    }
    
    boolean sameCons(ConsLoInt that) {
        return this.first == that.first
            && this.rest.sameLoInt(that.rest);
    }
    
    boolean sameMt(MtLoInt that) {
        return false;
    }
}

```

---
**Exam 1**

Thursday the 25th
* No lecture on the 25th

3 hours long

Will be open on Canvas from 6pm-11:59pm

Cover material from Lecture 1-Lecture 12 inclusive

Sample exam will be on Piazza today

Review is part of lab on Tuesday


---

# Abstracting over Behavior

Recall `getAllDaVinci()` in the paining example.

```java
interface ILoPainting {
    // get all the painting that were painted before 1900
    ILoPainting getAllBefore1900()
}

class MtLoPainting implements ILoPainting {
    ILoPainting getAllBefore1900() {
        return this;
    }
}

class ConsLoPainting implements ILoPainting {

    ILoPainting getAllDaVinci() {
        if (this.first.checkArtist("DaVinci")) {
            return new ConsLoPainting(this.first, this.rest.getAllDaVinci());
        } else {
            return this.rest.getAllDaVinci();
        }
    }
    
    ILoPainting getAllBefore1900() {
        if (this.first.paintedBefore1900()) {
            return new ConsLoPainting(this.first, this.rest.getAllBefore1900());
        } else {
            return this.rest.getAllBefore1900();
        }
    }
}

class Painting {

    Artist artist
    String title
    double value; // in millions of dollars
    int year;
    //...
    
    boolean paintedBefore1900() {
     return this.year < 1900;
    }
    
    boolean checkArtist(String name) {
        return this.artist.checkName(name);
    }
}

class Artist {

    String name;
    int yob;
    //...
    boolean checkName(String name) {
        return this.name.equals(name);
    }
}
```

This looks like **filter**.

Recall from Fundies 1:
```scheme
(filter even? '(1 2 3 4)) ; returns '(2 4)
(filter odd? '(1 2 3 4)) ; returns '(1 3)
```

We can't pass through the functions themselves, but we can pass *objects* which can hold functions:

These are called function objects

```java
interface IPaintingPredicate {
    // ask a question about a given painting
    boolean apply(Painting p);
}

class ByDaVinci implements IPaintingPredicate {
    //is the given Painting by DaVinci?
    public boolean apply(Painting p) {
       return p.artist.checkName("DanVinci");
    }
}

class Before1900 implements IPaintingPredicate {
    //is the given Painting painted before 1900
    public boolean apply(Painting p) {
        return p.year < 1900;
    }
}
//...
interface ILoPainting {
    //...
    //filters this list of painting by the given predicate
    ILoPainting filter(IPaintingPredicate pred);
}

class MtLoPainting implements ILoPainting {
    //...
    ILoPainting filter(IPaintingPredicate pred) {
        return this; 
    }
}
class ConsLoPainting implements ILoPainting {
    //...
    //...
    ILoPainting filter(IPaintingPredicate pred) {
        if(pred.apply(this.first)) {
            return new ConsLoPainting(this.first, this.rest.filter(pred));
        } else {
            return this.rest.filter(pred);
        }
    }
}

class Examples {
    this.mt.filter(new Before1900()) -> this.mt
    this.list2.filter(new ByDaVinci()) -> this.list1
}
```

If you want to add another way to filter something, you'd just need to make a new class in the predicate interface (and create the `apply` method). For example:

```java
class Over50 implements IPaintingPredicate {
    //is the given painting values at more than 50 million dollars?
    public boolean apply(Painting p) {
        return p.value > 50;
    }
}
```

# Abstractions over Multiple Arguments

### Dot Product Example
Dot product problem. For example, (1, 2, 3).dotProduct(5, 6) should return 5+12+0 = 17

Remember, by doing `double dynamic dispatch`, you know whether or not `that` is a `ConsLoInt` or `MtLoList` (because it runs to correct method).

```java
interface ILoInt {
    int dotProduct(ILoInt that);
    //helper for dot product
    int dotProductHelp(int firstOfOriginalList, ILoInt restOfOriginalList); 
}
class ConsLoInt implements ILoInt {
    int first;
    ILoInt rest;
    
    ConsLoInt(int f, ILoInt r) {
        this.first = f;
        this.rest = r;
    }
    
    public int dotProduct(ILoInt that) {
        return that.dotProductHelp(this.first, this.rest);
    }
    
    public int dotProductHelp(int firstOfOriginalList, ILoInt restOfOriginalList) {
        return this.first * firstOfOriginalList + this.rest.dotProduct(restOfOriginalList);
    }
}

class MtLoInt implements ILoInt {
    public int dotProduct(ILoInt that) {
        return 0;
    }
    
    public int dotProductHelp(int firstOfOriginalList, ILoInt restOfOriginalList) {
        return 0;
    }
}

class Examples {
    ILoInt mt = new MtLoInt();
    
    ILoInt list1 = new ConsLoInt(4, new ConsLoInt(5, this.mt));
    ILoInt list2 = new ConsLoInt(1, new ConsLoInt(2, new ConsLoInt(3, this.mt)));
    
    boolean testDot(Tester t) {
      return t.checkExpect(list1.dotProduct(list1), 16+25)
          && t.checkExpect(this.list1.dotProduct(this.list2), 4+10);
    }
}
```

## List Abstractions
Filter: [X -> Boolean] [List-of X] -> [List-of X]

Map: [X -> Y] [List-of X] -> [List-of Y]

Foldr: [X Y -> Y] Y [List-of X] -> Y

Andmap: [X -> Boolean] [List-of X] -> Boolean

Ormap: [X -> Boolean] [List-of X] -> Boolean

We can't make `Foldr` or `Map` yet because of the signature. They both return something with a `Y` which we don't know.

### Filter - Painting Example
Recall `filter` from last lecture. We use function objects to make use of overriding.

```java

// In ConsLoPainting
public ILoPainting filter(IPaintingPredicate pred) {
    if(pred.apply(this)) {
        return new ConsLoPainting(this.first, this.rest.filter(pred));
    } else {
        return this.rest.filter(pred);
    }
}
//In IPaintingPredicate
class BySomeArtist implements IPaintingPredicate {
    String artistName;
    
    BySomeArtist(String artistName) {
        this.artistName = artistName;
    }
    
    // Is the given painting painted by this.artistName?
    public boolean apply(Painting p) {
        return p.checkArtistName(this.artistName);
    }
}

class BeforeSomeYear implements IPaintingPredicate {
    int year;
    
    BeforeSomeYear(int year) {
        this.year = year;
    }
    
    public boolean apply(Painting p) {
        return p.year < this.year;
    }
}


// Example
this.list3.filter(new BySomeArtist("Monet")) //return empty list
```

### Ormap

```java
//in ILoPainting

boolean ormap(IPaintingPredicate pred);

//in mt class

boolean ormap(IPaintingPredicate pred) {
    return false;
}

// in cons class

boolean ormap(IPaintingPredicate pred) {
    return pred.apply(this.first) || this.rest.ormap(pred);
}
```
### Andmap

```java
//in ILoPainting

boolean ormap(IPaintingPredicate pred);

//in mt class

boolean ormap(IPaintingPredicate pred) {
    return true;
}

// in cons class

boolean ormap(IPaintingPredicate pred) {
    return pred.apply(this.first) && this.rest.ormap(pred);
}
```

### Higher Order Predicates

A predicate that takes in another predicate

(Higher order in general--like `foldr`--means takes in another function )

```java
//in predicate
class AndPredicate implements IPaintingPredicate {
    IPaintingPredicate left;
    IPaintingPredicate right;
    
    AndPredicate(IPaintingPredicate left, IPaintingPredicate right) {
        this.left = left;
        this.right = right;
    }
    
    /*
    * FIELDS:
    * this.left ... IPaintingPredicate
    * this.right ... IPaintingPredicate
    * METHODS:
    * this.apply(Painting) ... Boolean
    * METHODS FOR FIELDS: 
    * this.left.apply(Painting) ... Boolean
    * this.right.apply(Painting) ... Boolean
    */
    
    //does the painting pass both predicates?
    public boolean apply(Painting p) {
        return this.left.apply(p) && this.right.apply(p);
    }
}
// in examples:
this.list3.filter(AndPredicate(new BySomeArtist("Monet"), new BeforeSomeYear(1900)));
```

You can nest these as well because it is a `IPaintingPredicate`. You can also do the same thing with `or`. Note, we can use these predicates for sorting as well.

# Abstracting Over More Than One Argument

Example of sorting by year (which looks very similar to sort by title):

```java
// In ILoPainting

// sort this list by year
ILoPainting sortByYear();
//insert the given painting into this sorted list (sorted by year)
ILoPainting insertByYear(Painting p);

// In MtLoPainting

public ILoPainting sortByYear() {
    return this;
}

public ILoPainting insertByYear(Painting p) {
    return new ConsLoPainting(p, this);
}

// In MtLoPainting

public ILoPainting sortByYear() {
    return this.rest.sortByYear().insertByYear(this.year);
}

public ILoPainting insertByYear(Painting p) {
    if (this.first.yearComesBefore(p)) {
        return new ConsLoPainting(this.first, this.rest.insertByYear(p));
    } else {
        return new ConsLoPainting(p, this);
    }
}
```

So we can abstract this using a *comparator* object:

NOTE: This isn't the same as a *predicate* object because they signatures are different. The predicate's signature is Painting -> Boolean and the comparator's signature is Painting Painting -> Boolean (it takes in another Painting). 

You do, however, have to delegate the actual comparison to the painting class

```java
interface IPaintingComparator {
    // does p1 come before p2?
    boolean compare(Painting p1, Painting p2);
}

class CompareByYear implements IPaintingComparator {
    // was p1 painted before p2?
    boolean compare(Painting p1, Painting p2){
        return p1.paintedBefore(p2);
    }
}

class CompareByArtistName implements IPaintingComparator {
    // does p1's artist name come before p2's artist name alphabetically
    boolean compare(Painting p1, Painting p2){
        return p1.nameComesBefore(p2);
    }
}
```

We also create this `compare` method in our Painting class.
```java
// in Painting class
boolean paintedBefore(Painting p) {
    return this.year < p.year;
}
```

And the abstracted `sort` method looks like:

```java
// In ILoPainting
//sort this list of painting by the given comparison operator
ILoPainting sortBy(IPaintingComparator comp);
// inserts into the sorted list
ILoPainting insertBy(IPaintingComparator comp, Painting p);

// In MtLoPainting class
//sort this list of painting by the given comparison operator
ILoPainting sortBy(IPaintingComparator comp) {
    return this;
}

// inserts into the sorted list
ILoPainting insertBy(IPaintingComparator comp, Painting p) {
    return new ConsLoPainting(p, this);
}

// In ConsLoPainting class
//sort this list of painting by the given comparison operator
ILoPainting sortBy(IPaintingComparator comp) {
    return this.rest.sortBy(comp).insertBy(comp, this.first);
}

// inserts into the sorted list
ILoPainting insertBy(IPaintingComparator comp, Painting p) {
    if (comp.compare(this.first, p)) {
        return new ConsLoPainting(this.first, this.rest.insertBy(comp, p));
    } else {
        return new ConsLoPainting(p, this);
    }
}
```

What if we want it to be a three value comparator (is this before that, after that, or the same as that)?
* Returns a negative int if it comes before
* Zero if it's equal
* Positive if it comes after

```java
// in PaintingComparator

// returns a negative int if p1 comes before p2,
// a positive int if p1 comes after p2,
// or zero if p1 is the same as p2
int compare(Painting p1, Painting p2);

// in Painting
int paintedBefore(Painting p) {
    return this.year - p.year;
}

int nameComesBefore(Artist that) {
    return this.name.compareTo(that.name);
}

// in ConsLoPainting
public ILoPainting insertBy(IPaintingComparator comp, Painting p) {
    if (comp.compare(this.first, p) < 0) {
        return new ConsLoPainting(this.first, this.rest.insertBy(comp, p));
    } else {
        return new ConsLoPainting(p, this);
    }
}
```

### Example - Gets the Min Painting in an List
Getting the most expensive/least expensive/earliest painted Painting
```java
// in IPainting 

// Gets the min painting based on the given comparator
Painting findMin(IPaintingComparator comp);

// Gets the min painting
// Accumulator: keeps track of the min painting so far
Painting findMinAcc(IPaintingComparator comp, Painting acc);

// in MtLoPainting

// Gets the min painting based on the given comparator
public Painting findMin(IPaintingComparator comp) {
    throw new RunTimeException("No min painting in empty list");
}

// Gets the min painting
// Accumulator: keeps track of the min painting so far
Painting findMinAcc(IPaintingComparator comp, Painting acc) {
    return acc;
}

// in ConsLoPainting

// Gets the min painting based on the given comparator
public Painting findMin(IPaintingComparator comp) {
    return this.rest.findMinAcc(comp, this.first);
}

// Gets the min painting
// Accumulator: keeps track of the min painting so far
Painting findMinAcc(IPaintingComparator comp, Painting acc) {
    if (comp.compare(this.first, acc) < 0) {
        return this.rest.findMinAcc(comp, this.first);
    } else {
        return this.rest.findMinAcc(comp, acc);
    }
}
```

### Higher Order Comparator

A comparator that takes in another comparator

```java
class ReverseComparator implements IPaintingComparator {
    IPaintingComparator comp;
    
    ReverseComparator(IPaintingComparator comp) {
        this.comp = comp;
    }
    
    // does p2 come before p2 according to the reverse of this.comp?
    public int compare(Painting p1, Painting p2) {
        return this.comp.compare(p1, p2) * -1;
    }
}
```

# Abstracting Over Types

IPaintingPredicate

boolean apply(Painting P)


IBookPredicate

boolean apply(Book P)

These are similar. Can we abstract away these differences (only difference is what they take in)?


We can take in a **generic type**

```java
interface IPred<T> {
    boolean apply(T t);
}
```

**Example:**
```java
class ByArtist implements IPred<Painting> {
    String name;
    
    ByArtist(String name) {
        this.name = name;
    }
    
    // is the given painting painted by this.name?
    boolean apply(Painting p) {
        return this.name.equals(p.name);
    }
}

class ByAuthor implements IPred<Book> {
    String name;
    
    ByAuthor(String name) {
        this.name = name;
    }
    
    // is the given painting painted by this.name?
    boolean apply(Book b) {
        return this.name.equals(b.name);
    }
}
```

### Generic List

We can have one IList interface which can be a list of whatever you want. The downsides to this is that you can't have specific methods (such as `totalSumOfBooks`). Cannot refer to anything specific about `T`. But this is where List Abstractions are helpful.

Filter: [x-> Boolean] [List-of X] -> [List-of X]

Map: [X->Y] [List-of X] -> [List-of Y]

Fold: [X Y -> Y] Y [List-of X] -> Y

NOTE: If we haven't seen a type before, we need to say <X> before the function. See `map`.

```java
interface IList<T> {
    //filters this list by the given predicate
    IList<T> filter(IPred<T> pred);
    
    //map a function onto the members of this list
    <U> IList<U> map(IFunc<T, U> f); 
    
    // combine the items in this list according to the given function
    // foldr
    <U> U fold(IFunc2<T, U, U> f, U base);
}

class MtList<T> implements IList<T> {
    
    //filters this list by the given predicate
    IList<T> filter(IPred<T> pred){
        return this;
    }
    
    //map a function onto the members of this list
    public <U> IList<U> map(IFunc<T, U> f) {
        return new MtList<U>();
    }
    
    // combine the items in this list according to the given function
    public <U> U fold(IFunc2<T, U, U> f, U base) {
        return base;
    }
}

class ConsList<T> implements IList<T> {
    T first;
    IList<T> rest;
    
    ConsList(T first, IList<T> rest) {
        this.first = first;
        this.rest = rest;
    }
    
    //filters this list by the given predicate
    IList<T> filter(IPred<T> pred){
        if (pred.apply(this.first)) {
            return new ConsList<T>(this.first, this.rest.filter(pred));
        } else {
            return this.rest.filter(pred);
        }
    }
    
    //map a function onto the members of this list
    public <U> IList<U> map(IFunc<T, U> f) {
        return new ConsList<U>(f.apply(this.first), this.rest.map(f));
    }
    
    // combine the items in this list according to the given function
    public <U> U fold(IFunc2<T, U, U> f, U base) {
        return f.apply(this.first, this.rest.fold(f, base));
    }
}

interface IPred<X> {
    //asks a question about the given x
    boolean apply(X x);
}

class ByAuthor implements IPred<Painting> {
    String name;
    
    ByAuthor(String name) {
        this.name = name;
    }
    
    public boolean apply(Painting x) {
        return x.checkArtistName(this.name); 
    }
}

interface IFunc<X, Y> {
    //apply an operation to x and produce a y
    Y apply(X x);
}

interface IFunc2<X, Y, Z> {
    //apply some operation to x and y to produce a Z
    Z apply(X x, Y y);
}

class SumValues implements IFunc2<Painting, Double, Double> {
    
    public Double apply(Painting x, Integer y) {
        return p.value + y;
    }
}

class PaintingToArtist implements IFunc<Painting, Artist> {
    
    // gets the artist of a given painting
    public Artist apply(Painting x) {
        return x.artist;
    }
}


class Examples {
    ...
    Painting waterlilies = new Painting(this.monet, "Water Lilies", 20, 1915);
    
    IList<Painting> paintings  = new ConsList<Painting>(this.waterlilies, new MtList<Painting>);
    
    boolean testFilter(Tester t) {
        return t.checkExpect(this.paintings.filter(new ByAuthor("Monet")), this.paintings);
    }
    
    boolean testMap(Tester t) {
        return t.checkExpect(this.paintings.map(new PaintingToArtist()),
                            new ConsList<Artist>(this.monet, new MtList<Artist>))
                    && t.checkExpect(new MtList<Painting>().map(new PaintingToArtist()),
                            new MtList<Artist>());
    }
}
```

### Java's Own Implementation 

Import utils for Java

**java.util.function**
Predicate
* Instead of `apply`, it has the method `test`

Function
* `apply` method

BiFunction
* The same as `Func2`
* `apply` method

**java.util.**

Comparator
* `compare` method


See official Java documentation for more information.


# Visitors

Recall *Generic Lists* from last lecture

NOTE: You can implement multiple interfaces in a single class

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec16-fig1.png'>
</div>


```java
...

interface IShape {
    
    // produces a Double when this IShape is apply to by the given function
    <R> R accept(IShapeVisitor<R> f);
}

class Circle implements IShape {
    int x, y, radius;
    String color;
    
    Circle(int x, int y, int radius, String color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
    }
    
    // produces a Double when this Circle is apply to by the given function
    public <R> R accept(IShapeVisitor<R> f){
        return f.applyToCircle(this);
    }
}

class Rect implements IShape {
    int x, y, w, h;
    String color;
    
    Rect(int x, int y, int w, int h, String c) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = c;
    }
    
    // produces a Double when this Rect is apply to by the given function
    public <R> R accept(IShapeVisitor<R> f){
        return f.applyToRect(this);
    }
}

// We can say this `extends IFunc<IShape, R>` if we want every
// IShapeVisitor to be an IFunc
interface IShapeVisitor<R> {
    R visitCircle(Circle c);
    R visitRect(Rect r);
}
// a function to compute the area of an IShape
class ShapeArea implements IShapeVisitor<Double>{
    
    // compute the area of a Circle
    public Double visitCircle(Circle c) {
        return Math.PI * c.radius * c.radius;
    }
    
    // compute the area of a Rect 
    public Double visitRect(Rect c) {
        return r.h * r.w * 1.0;
    }
    
    // apply a function to the given shape
    public Double apply(IShape x) {
        return x.accept(this);
    }
}

// NOTE: We could also just have every IShapeVisitor is an IFunc
class ShapeGrow implements IShapeVisitor<Shape>, IFunc<IShape, Double> {
    int increment;
    
    ShapeGrow(int i) {
        this.increment = i;
    }
    
    public IShape visitCircle(Circle c) {
        return new Circle(c.x, c.y, c.radius + this.increment, c.color);
    }
    
    public IShape visitRect(Rect r) {
        return new Rect(r.x, r.y, r.w, r.h, r.color);
    }
    
    // apply a function to the given shape
    public Double apply(IShape x) {
        return x.accept(this);
    }
}


class Examples {
    IShape c1 = new Circle(3, 4, 10, "red");
    IShape r1 = new Rectangle(6, 8, 3, 2, "blue");
    
    IList<IShape> shapes = new ConsList<IShape>(this.c1, new ConsList<IShape>(this.r1, new MtList<IShape>()));
    
    boolean testShapeAreas(Tester t){
        return t.checkExpect(this.shapes.map(new shapeArea()), 
            new ConsList<Double>(Math.PI * 100, new ConsList<Double>(6.0, new MtList<Double>())));
    }
}
```

What about the visitors for `IList`s?

```java
import java.util.Function;

interface IList<T> {
  <R> R accept(IListVisitor<T, R> ilv);
}

class MtList<T> implements IList<T> {

  public <R> R accept(IListVisitor<T, R> ilv) {
    return ilv.visitMt(this);
  }

}

class ConsList<T> implements IList<T> {
  T first;
  IList<T> rest;
  
  ConsList(T first, IList<T> rest) {
    this.first = first;
    this.rest = rest;
  }

  public <R> R accept(IListVisitor<T, R> ilv) {
    return ilv.visitCons(this);
  }

  
}

interface IListVisitor<T, R> {
  R visitMt(MtList<T> mt);
  R visitCons(ConsList<T> cons);
}

class FilterVisitor<T> implements IListVisitor<T, IList<T>> {
    Predicate<T> pred;
    
    FilterVisitor(Predicate<T> pred) {
        this.pred = pred;
    }
    
    public IList<T> visitMt(MtList<T> mt) {
        return mt;
    }
    
    // asks a question about the first item in the cons, recurs on the rest
    public IList<T> visitCons(ConsList<T> cons) {
        if (this.pred.test(cons.first)) {
            return new ConsList<T>(cons.first, cons.rest.accept(this));
        } else {
            return this.rest.accept(this);
        }
    }
}

class ContainsA implements Predicate<String> {
    
    // does the string contain the letter a?
    public boolean test(String x) {
        return x.contains("a") || x.contains("A");
    }
    
}

class Examples {
    // Strings2 = ["dog", "cat"]
    // Strings1 = ["cat"]

    boolean testFilter(Tester t) {
        return t.checkExpect(this.strings2.accept(new FilterVisitor<String>(new ContainsA())), this.strings1);
    }
}
```

# Mutation

Consider:

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec17-fig1.png'>
</div>

This doesn't work because this is *circular data*. How can we make an example of this?

What we want is:
```java
t.checkExpect(this.monet.painting.artist, this.monet);
```

```java
class Artist {
    String name;
    int yob;
    Painting painting;
    
    Artist(String n, int yob, Painting p) {
        this.name = n;
        this.yob = yob;
        this.painting = p;
    }
}

class Painting {
    String title;
    Artist artist;
    int year;
    int value;
    
    Painting(String t, Artist a, int y, int v) {
        this.title = t;
        this.artist = a;
        this.year = y;
        this.value = v;
    }
}
```

In order to do this, we need to start with incomplete objects:

```java
this.monet = new Artist("Claude Monet", 1840, null);
this.waterlilies = new Painting(this.monet, "Waterlilies", 30, 1915);

// Assignment statement
this.monet.painting = this.waterlilies;
```
This represents:

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec17-fig2.png'>
</div>

The side effect is that The `Artist`s `painting` value is changed from `null` to `waterlilies`.

Now what about checking for sameness? Because we introduced *circularity* in our data, we have to make sure that our methods terminate.
```java

// In Painting class

boolean samePainting(Painting p) {
    return this.artist.sameArtist(p.artist) 
        && this.title.equals(p.title)
        && this.value == p.value
        && this.year == p.year;
}

// In Artist class

boolean sameArtist(Artist other) {
    return this.name.equals(other.name) 
        && this.yob == other.yob; 
        // We don't include the next line because it introduces circularity
        //&& this.painting.samePainting(other.painting);
}
```

Another example (to show how complicated this can get):
```java
class Counter {
  int val;
  Counter() {
    this(0);
  }
  Counter(int initialVal) {
    this.val = initialVal;
  }
  int get() {
    int ans = this.val;
    this.val = this.val + 1;
    return ans;
  }
}
class ExamplesCounter {
  boolean testCounter(Tester t) {
    Counter c1 = new Counter();
    Counter c2 = new Counter(2);
    // What should these tests be?
    return t.checkExpect(c1.get(), 0)// Test 1
        && t.checkExpect(c2.get(), 2)// Test 2
        && t.checkExpect(c1.get() == c1.get(), false)// Test 3
        && t.checkExpect(c2.get() == c1.get(), true)// Test 4
        && t.checkExpect(c2.get() == c1.get(), true)  // Test 5
        && t.checkExpect(c1.get() == c1.get(), false)  // Test 6
        && t.checkExpect(c2.get() == c1.get(), false)// Test 7
  }
}
```

NOTE: If we pass through primitive types, it makes a copy of the value whereas if we pass in objects, it copies the reference (we will go over this in future lectures).

Another example for Painting.
```java
Painting poppies = new Painting(this.monet, "Poppies", 20, 1873);

boolean testPainting(Tester t) {
    this.monet.painting = this.poppies;
    
    return  t.checkExpect(monet.painting.artist, this.monet);
}
```

We want to make this more clear:

NOTE: A void method does not return anything. If a method has a side effect to running it, you have to declare an *effect statement*. If it also returns something, you add a purpose statement.

```java
// In Artist class

// EFFECT: Update this Artist's painting with the given painting
void updatePainting(Painting p) {
    if (this.painting != null) {
        throw new RuntimeException("Artist cannot have a second painting");
    } else if (!p.artist.sameArtist(this)) {
        throw new RuntimeException("not the right painting for this artist");
    }
    } else {
        this.painting = p;
    }
}

// In Examples class

this.monet.updatePainting(this.waterlilies);
this.monet.updatePainting(this.poppies);
```

# Mutation Inside Structures
## Test Fixture

**How to test updatePainting**:
1. Ensure the state of our initial conditions
2. Modify the state by running the code
3. Test that the changes occurred 

Example:
```java
// In Examples class
Artist monet;
Painting waterlilies;
Painting poppies;

//initialize the data to its initial conditions
void initData() {
    this.monet = new Artist("Claude Monet", 1840, null);
    this.waterlilies = new Painting(this.monet, "Waterlilies", 30, 1915);
    this.poppies = new Painting(this.monet, "Poppies", 20, 1873);
}

boolean testPainting1(Tester t) {
    //1. Ensure our initial conditions
    this.initData(); 
    
    //2. Run the code
    this.monet.updatePainting(this.waterlilies);
    
    //3. Test that the changes occurred
    return t.checkExpect(this.monet.painting.artist, monet);
}
```

NOTE: Test methods are run in a random order each time.

We do not require testing `initData`.

NOTE: We don't have to have our test methods return a boolean, they can return a void.

```java
void testPainting(Tester t) {
    //1. Ensure our initial conditions
    this.initData()
    
    // Check
    t.checkExpect(this.monet.painitng, null);
    
    //2. Run the code
    this.monet.updatePainting(this.waterlilies);
    
    //3. Test that the changes occurred
    t.checkExpect(this.monet.painting, this.waterlilies);
}

void testPaintingsArtists(Tester t) {
    this.initData();
    
    Artist daVinci = new Artist("Leonardo da Vinci", 1452, null);
    Painting mona = new Painting(this.daVinci, "Mona Lisa", 100, 1500);
    
    t.checkExpect(this.monet.painting, null);
    t.checkExpect(this.daVinci.painting, null);
    
    t.checkException(new RuntimeException("not the right painting for this artist"),
            daVinci, "updatePainting", waterlilies);
}
```

This linking should happen automatically:

```java
// in Painting class
Painting(Artist artist, String title, double value, int year) {
    this.artist = artist;
    this.title = title;
    this.value = value;
    this.year = year;
    this.artist.updatePainting(this);
}

// in Artist class
Artist(String name, int yob) {
    this.name = name;
    this.yob = yob;
}

// in Examples
Artist monet = new Artist("Monet", 1850); // Don't need to initialize the painting here
```

Lets make an Artist have multiple paintings.

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec18-fig1.png'>
</div>

This is still circular.

```java
// in Artist class
IList<Painting> paintings;

void updatePaintings(Painting p) {
    if (!p.artist.sameArtist(this)) {
        throw new RuntimeException("Artist cannot have a second painting");
    } else {
        this.paintings = new ConsList<Painting>(p, this.paintings);
    }
}
```
### Lambdas

You need an interface with only one method. (The input for `map` is that interface.)

Example:
```java
this.strings2.map(x -> x.length());
```

Map takes in an `IFunc` and `IFunc` only has one method (`apply`).

You can also have multiple inputs:
```java
this.strings2.map((x, y) -> x.length());
```

(This won't work with our current implementation of `IFunc2`, but it would work if it was implemented correctly.)

# Mutation, Aliasing, and Testing

When changing a person, we want to change the person object instead of creating a new object with the changed value in a list. That way, when we refer to the person in another list (or just directly), we will see the changed values.

```java
class Person {
  String name;
  int phone;
  Person(String name, int phone) {
    this.name = name;
    this.phone = phone;
  }
  // Returns true when the given person has the same name and phone number as this person
  boolean samePerson(Person that) {
    return this.name.equals(that.name) && this.phone == that.phone;
  }
  // Returns true when this person has the same name as a given String
  boolean sameName(String name) {
    return this.name.equals(name);
  }
  // Returns the number of this person when they have the same name as a given String
  int phoneOf(String name) {
    if (this.name.equals(name)) {
      return this.phone;
    }
    else {
      throw new RuntimeException("The given name does not match this person's name");
    }
  }
  
  //EFFECT: changes this persons phone number to the given one
  void changePhone(int newNum) {
    this.phone = newNum;
  }
}

interface ILoPerson {
  // Returns true if this list contains a person with the given name
  boolean contains(String name);
  
  // gets the number of the person with the given name
  int findPhoneNum(String name);
  
  //EFFECT: change the number of the person with the given name
  void changeNum(String name, int newNum);
  
}

class MtLoPerson implements ILoPerson {
    public boolean contains(String name) {
        return false;
    }
    
    public int findPhoneNum(String name) { return -1; }
    
    public void changeNum(String name, int newNum) {}
}

class ConsLoPerson implements ILoPerson {
    // Returns true if this non-empty list contains a person with the given name
    public boolean contains(String name) {
        return this.first.sameName(name) || this.rest.contains(name);
    }
    
    public int findPhoneNum(String name) {
        if (this.first.sameName(name)) {
            return this.first.phoneOf(name);
        }
        else {
            return this.rest.findPhoneNum(name);
        }
    }
    
    public void changeNum(String name, int newNum) {
        if (this.first.sameName(name)) {
            this.first.changePhone(newNum);
        } else {
            this.rest.changeNum(name, newNum);
        }
    }
}

class Examples {
    ...
    void testChangePhoneNum(Tester t) {
        this.initData()
        
        t.checkExpect(this.friends.findPhoneNum("Frank"), 7294);
        t.checkExpect(this.family.findPhoneNum("Frank"), 7294);
        t.checkExpect(this.frank.phone, 7294);
        
        this.friends.changeNum("Frank", 4927);
        
        t.checkExpect(this.friends.findPhoneNum("Frank"), 4927);
        t.checkExpect(this.family.findPhoneNum("Frank"), 4927);
        t.checkExpect(this.frank.phone, 4927);
    }
}
```

```java
Person alice1 = new Person("Alice", 67890);
Person alice2 = new Person("Alice", 67890);
Person alice3 = this.alice1; //Alias for alice1
```

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec19-fig1.png'>
</div>

```java
alice1.samePerson(alice2) - > true

alice1.samePerson(alice3) -> true

alice1.phone = 09676

alice1.samePerson(alice2) -> false

alice1.samePerson(alice3) -> true
```

**Extensional Equality**:

Compare objects field-by-field seeing if all the values are equivalent.

**Intensional Equality**:

Checks if two objects are the exact same object.


```java
alice1.equals(alice2) -> false // Intensional equality
alice1.equals(alice3) -> true
```



```java
class Counter {
  int val;
  Counter() {
    this(0);
  }
  Counter(int initialVal) {
    this.val = initialVal;
  }
  int get() {
    int ans = this.val;
    this.val = this.val + 1;
    return ans;
  }
}
class ExamplesCounter {
  boolean testCounter(Tester t) {
    Counter c1 = new Counter();
    Counter c2 = new Counter(5);
    Counter c3 = c1;
    // What should these tests be?
    return t.checkExpect(c1.get(), 0)// Test 1
        && t.checkExpect(c2.get(), 5)// Test 2
        && t.checkExpect(c3.get(), 1)// Test 2
        
        && t.checkExpect(c1.get() == c1.get(), false)// Test 3
        && t.checkExpect(c2.get() == c1.get(), true)// Test 4
        && t.checkExpect(c2.get() == c1.get(), true)  // Test 5
        && t.checkExpect(c1.get() == c1.get(), false)  // Test 6
        && t.checkExpect(c2.get() == c1.get(), false)// Test 7
  }
}

```

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec19-fig2.png'>
</div>


Relating to the persons example, what if we use `IList<T>`

NOTE: When abstracting over types, if you want to not return anything, you use `Void` and in the method, you return `null`. (It's an object type and not the same as `void`.) 

```java
interface IList<T> {
    // EFFECT: modifies the first object in this list that passes the predicate
    void modify(IPred<T> whichOne, IFunc<T, Void> whatToDo);
}

class MtList<T> implements IList<T> {
    public T find(IPred<T> whichOne) {return null; }
    // EFFECT: modifies the first object in this list that passes the predicate
    void modify(IPred<T> whichOne, IFunc<T, Void> whatToDo) {}
}

class ConsList<T> implements IList<T> {
    T first;
    IList<T> rest;
    
    ConsList(T first, IList<T> rest) {
        this.first = first;
        this.rest = rest;
    }
    
    public T find(IPred<T> whichOne) {
        if (whichOne.apply(this.first)) {
            return this.first;
        } else {
            return this.rest.find(whichOne);
        }
    }
    
    // EFFECT: modifies the first object in this list that passes the predicate
    void modify(IPred<T> whichOne, IFunc<T, Void> whatToDo) {
        if (whichOne.apply(this.first)) {
            whatToDo.apply(this.first);
        } else {
            this.rest.modify(whichOne, whatToDo);
        }
    }
}

// In the Java library, you can just use Consumer
class ChangePhone implements IFunc<Person, Void> {
    int num;
    
    ChangePhone(int num) {
        this.num = num;
    }
    
    public Void apply(Person x) {
        x.phone = this.num;
        return null;
    }
}

```

# Mutable Data Structures

Recall the friends list from last lecture
```java
// In ILoPerson
// EFFECT: Removes the person with the given name from this list
void removePerson(String name);
// EFFECT: Helps to remove the person with the given name
// ACCUMULATOR: Keeps track of the previous node
void removePersonHelp(String name, ConsLoPerson prev);

// In MtLoPerson
// EFFECT: Removes the person with the given name from this list
void removePerson(String name) {}
// EFFECT: Helps to remove the person with the given name
// ACCUMULATOR: Keeps track of the previous node
void removePersonHelp(String name, ConsLoPerson prev) {}

// In ConsLoPerson
// EFFECT: Removes the person with the given name from this list
void removePerson(String name) {
    this.rest.removePersonHelp(name, this);
}

// EFFECT: Helps to remove the person with the given name
// ACCUMULATOR: Keeps track of the previous node
void removePersonHelp(String name, ConsLoPerson prev) {
    if(this.first.sameName(name)) {
        prev.rest = this.rest;
    } else {
       this.rest.removePersonHelp(name, this); 
    }
}

//in Examples
void testRemove(Tester t) {
    this.initData();
    t.checkExpect(this.friends.contains("Frank"), true);
    t.checkExpect(this.family.contains("Frank"), true);
    this.friends.removePerson("Frank");
    t.checkExpect(this.friends.contains("Frank"), false);
    t.checkExpect(this.family.contains("Frank"), true);
}

void testRemoveFirst(Tester t) {
    this.initData();
    t.checkExpect(this.friends.contains("Anne"), true);
    t.checkExpect(this.family.contains("Anne"), true);
    this.friends.removePerson("Anne");
    t.checkExpect(this.friends.contains("Anne"), false);
    t.checkExpect(this.family.contains("Anne"), true);
}
```

This won't work because it can't change the first (there is nothing before it). We need to add a *sentinel* which stands in front of a list and only has a `rest`.

Adding a layer of indirection
<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec20-fig1.png'>
</div>

NOTE: Doing it this way would mean that we would always need a sentinel in front. 

To make this easier, we need a wrapper:

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec20-fig2.png'>
</div>

```java
abstract class APersonList {
    abstract void removePersonHelp(String name, ANode prev);
}

class MtLoPerson extends APersonList {
    void removePersonHelp(String name, ANode prev) {}
}

abstract class ANode extends APersonList {
    APersonList rest;
    
    ANode(APersonList rest) {
        this.rest = rest;
    }
}

class ConsLoPerson extends ANode {
    Person first;
    ConsLoPerson(Person first, APersonList rest) {
        super(rest);
        this.first = first;
    }
    
    void removePersonHelp(String name, ANode prev) {
        if(this.first.sameName(name)) {
            prev.rest = this.rest;
        } else {
            this.rest.removePersonHelp(name, this);
        }
    }
}

class Sentinel extends ANode {
    Sentinel(APerson rest) {
        super(rest);
    }
    
    void removePersonHelp(String name, ANode prev) {
        throw new RuntimeException("Cannot remove the sentinel");
    }
}

class MutablePersonList {
    Sentinel sentinel;
    MutablePersonList() {
        this.sentinel = new Sentinel(new MtLoPerson());
    }
    
    void removePerson(String name) {
        this.sentinel.rest.removePersonHelp(name, this.sentinel);
    }
}
```

This adds two layers of indirection.

How can we make this generic? (We will see Java's implementation of this later)
```java
interface IMutableList<T> {
    void remove(T t); // Uses intentional equality (== or .equals)
    T remove(Predicate<T> pred); // Uses extensional equality. Returns what we remove. 
    void addToFront(T t);
    void addToEnd(T t);
    void insert(T t, int n); // Adds at some index
    void set(int index, T t); // Sets the element at _index_ to _t_
    int size();
}
```
# ArrayLists

Recall `IMutableList` from last lecture. We aren't going to be using our own implementation, rather we are going to be using `ArrayList` in Java's implementation.

[ArrayList Documentation](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html)

## ArrayLists and For Each Loops

### For Each Loops

```java

... setup ...
for (T item : list) {
    ... body ...
}
... use the results ...

```


```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.function.Function;
import java.util.function.BiFunction;

class ArrayUtils {
    // EFFECT: Swaps the items in the given list at the two given indices 
    <T> void swap(ArrayList<T> alist, int index1, int index2) {
        // ArrayList.set returns the previous element
        alist.set(index2, alist.set(index1, alist.get(index2)));
    }
   
    
    // map a function onto every member of the given list
    <T, U> ArrayList<U> map(ArrayList<T> alist, Function<T, U> f) {
        return this.mapHelp(alist, f, 0, new ArrayList<U>());
    }
   
    // map a function onto every member of the given list
    <T, U> ArrayList<U> mapHelp(ArrayList<T> alist, Function<T, U> f, int current, ArrayList<U> result) {
        if (alist.size() == current) {
            return result;
        } else {
            return this.mapHelp(alist, f, current + 1, result.add(f.apply(alist.get(current)))); 
        }
    }
    
    // map a function onto every member of the given list
    <T, U> ArrayList<U> map2(ArrayList<T> alist, Function<T, U> f) {
        ArrayList<U> result = new ArrayList<U>();
        
        for (T t : alist) {
            result.add(f.apply(t));
        }
        
        return result;
    }
    
    // combines the items in the given list using the given BiFunction
    <T, U> U fold(ArrayList<T> alist, BiFunction<T, U, U> f, U base) {
        /*
        For `foldr`
        ArrayList<T> reverse = new ArrayList<T>();
        
        for (T item : alist) {
            reverse.add(0, item);
        }
        */
        
        // Foldl:
        U result = base;
        
        for (T t : alist) {
            result = f.apply(item, result);
        }
        
        return result;
    }
    
    // find the index of the first item that passes the given predicate
    // returns -1 if the item is not found
    <T> int find(ArrayList<T> alist, Predicate<T> pred) {
       return this.findHelp(alist, pred, 0);
    }
    
    // find the index of the first item that passes the given predicate
    // returns -1 if the item is not found
    <T> int findHelp(ArrayList<T> alist, Predicate<T> pred, int current) {
        if (current >= alist.size()) {
            return -1;
        } else if (pred.test(alist.get(current))) {
            return current;
        } else {
            return this.findHelp(alist, pred, current+1);
        }
    }
    
    
    
}

class Examples {
    ArrayList<Integer> ints;
    ArrayList<String> strings;
    
    void initData() {
        this.ints = new ArrayList<Integer>();
        
        this.ints.add(1);
        this.ints.add(2);
        this.ints.add(3);
        
        this.strings = new ArrayList<String>(Arrays.asList("a", "b", "c"));
    }
    
    void testArrayLists(Tester t) {
        this.initData();
        t.checkExpect(this.ints.get(0), 1);
        t.checkExpect(this.strings.get(2), "c");
        
        // Will throw a IndexOutOfBounds exception
        //t.checkExpect(this.strings.get(3), "c"); 
        
        this.strings.add(2, "d");
        t.checkExpect(this.strings.get(3), "c"); 
        
        new ArrayUtils().swap(this.strings, 2, 3)
        
        t.checkExpect(this.strings.get(3), "d");
    }
    
    void testMap(Tester t) {
        this.initData();
        t.checkExpect(new ArrayUtils().map(this.ints, n -> n+1),
                      new ArrayList<Integer>(Arrays.asList(2, 3, 4)));
    }
    
}
```

### Finding Something in a Sorted List

We don't have to use `find` for a sorted list because that would be inefficient. Instead, we can treat it like a binary search tree. So to do that, we go to the middle and go from there.

```java
// In ArrayListUtils

// find the index of the first String that matches target in given sorted list
// returns -1 if the item is not found
<T> int binarySearch(ArrayList<String> alist, String target) {
    return this.binarySearchHelp(alist, target, 0, alist.size() -1);
}

// find the index of the first String that matches target in given sorted list
// returns -1 if the item is not found
<T> int binarySearchHelp(ArrayList<String> alist, String target, int low, int high) {
    int mid = (low+high) / 2
    
    if (low > high) {
        return -1;
    }
    else if (target.compareTo(alist.get(mid)) == 0) {
        return mid;
    }
    else if(target.compareTo(alist.get(mid)) > 0) {
        return this.binarySearchHelp(alist, target, mid + 1, high);
    }
    
    else if(target.compareTo(alist.get(mid)) < 0) {
        return this.binarySearchHelp(alist, target, low, mid - 1);
    }
}

// in Examples class

ArrayList<String> strings2 = new ArrayList<String>(Arrays.asList("a", "b", "c", "d", "e", "f"));

void testFind(Tester t) {
    t.checkExpect(new ArrayUtils().binarySearch(this.strings2, "b"), 1);
    t.checkExpect(new ArrayUtils().binarySearch(this.strings2, "bb"), -1);
}

```

### Sorting (Selection Sort)

Selection sort
1. Find the index of the min item
2. Swap with that item and the item at the front of the unsorted part

### Counted For Loop

```java
for (initialization; termination condition; update statement) {
... body ...
}
```

1. Initialization statement: declares a loop variable, initialize to starting value, runs once
2. Termination condition: checked before every iteration, if it returns false, loop terminates when this evaluates to false
3. Loop body Execute at every iteration of the loop
4. Update statement: executed after the loop body, used to advance the loop variable to its next value

Example:
```java
for (int i = 0; i<10; i=i+1) {
    ...
}
```

```java
// In ArrayListUtils
//find the index of the String that comes first alphabetically in the list
int findIndexOfMinItem(ArrayList<String> strings) {
    if (strings.size() == 0) {
        throw new RuntimeException("No min of an empty list");
    }
    int currentMin = 0;
    
    for (int i=0; i < strings.size(); i += 1) {
        if (strings.get(current).compareTo(strings.get(i)) > 0) {
            currentMin = i;
        }
    }
    
    return currentMin;
}
```


### Nested For Loops
We get every combination of `suits` and `values`.
```java
// In ArrayListUtils class
ArrayList<Card> makeDeck() {
    ArrayList<Card> cards = new ArrayList<Card>();
    ArrayList<String> suits = new ArrayList<String>(Arrays.asList("hearts", "diamonds", "spades", "clubs"));
    ArrayList<String> values = new ArrayList<String>(Arrays.asList("ace", "two", "three", "four"));
    
    for (int i = 0; i < values.size(); i += 1) {
        for (int j = 0; j < suits.size(); j += 1) {
            cards.add(new Card(values.get(i), suits.get(j)));
        }
    }
    
    return cards;
}



// Outside of ArraylistUtils class
class Card {
    String value;
    String suit;
    
    Card(String value, String suit) {
        this.value = value;
        this.suit = suit;
    }
}
```


# For-each and Counted-for Loops

### Example - Build list
```java
// In ArrayListUtil

// Build a list by applying the given function to natural numbers starting
// from 0 to n-1
<U> ArrayList<U> buildList(int num, Function<Integer, U> func) {
    ArrayList<U> result = new ArrayList<U>();
    for (int i = 0; i < num; i += 1) {
        result.add(func.apply(i));
    }
    return result;
}
```

Consider the Cartesian points. 

```java
class CartPt {
    int x;
    int y;
    
    CartPt(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    // EFFECT: Shifts this CartPt by a given dx and dy
    void shift(int dx, int dy) {
        this.x = this.x + dx;
        this.y = this.y + dy;
    }
    
    // Prints this object
    // Overrides the default toString which is OBJECTCLASS@numsandletters
    // Works with System.out.println
    public String toString() {
        return "[" + this.x + ", " + this.y + "]";
    }
}
```

### Example - shiftPoints
How can we shift all of the points in a given ArrayList by a given dx, dy?

3 choices for `shiftPoints`:
1. Try to remove the current point and then add a new shifted point
    * Problematic because we are adding/removing an element while we are trying to iterating over the list
    * You can get a `ConcurrentModificationException`
2. Change the point to be a new Cartesian point that is shifted.
    * See below on why this won't work
3. Modify the current point
    * This works

```java
// In ArrayListUtils

// EFFECT: shifts all of the points in the given list by the given increments
void shiftPoints(ArrayList<CartPt> points, int x, int y) {
   /*
   // Option 2:
   for (CartPt pt : points) {
    pt = new CartPt(pt.x + x, pt.y + y);
   }
   */
   
   // Option 3:
   for (CartPt pt: points) {
    pt.shift(x, y);
   }
}

// In Examples
ArrayList<CartPt> pointsList = new ArrayList<CartPt>(Arrays.asList(new CartPt(3, 4), new CartPt(6, 8)));
```

Why option 2 doesn't work:

When we change `pt`, we don't actually change anything in the list because we are only changing what `pt` points to.

<div style='width: 100%' class='ui rounded images'>
<img class='ui image' src='/notes/cs2510/lec23-fig1.png'>
</div>

How can we shift every `CartPt` in a 2 dimensional array?
```java
// in Examples
void test2dArray(Tester t) {
    ArrayList<ArrayList<CartPt>> twoDArray = new ArrayList<ArrayList<CartPt>>();
    ArrayList<CartPt> temp;
    
    for (int i = 0; i < 3; i += 1) {
        temp = new ArrayList<CartPt>();
        for (int j = 0; j < 3; j += 1) {
            temp.add(new CartPt(i, j));
        }
        twoDArray.add(temp);
    }
    
    // Don't test like this, but this shows a good representation
    for (int i = 0; i < twoDArray.size(); i += 1) {
        System.out.println(twoDArray.get(i));
    }
    
    // Shifting every CartPt in a 2D array
    for (int i = 0; i < twoDArray.size(); i += 1) {
        for (int j = 0; j < twoDArray.size(); i += 1) {
            twoDArray.get(i).get(j).shift(0, 1); 
        }
    }
    
    for (int i = 0; i < twoDArray.size(); i += 1) {
        System.out.println(twoDArray.get(i));
    }
}
```

### Differences in Incrementation

`++i` : Pre increment
* Increments `i`, then assigns

`i++` : Post increment
* Assigns, then increments `i`

`++i`: (the "more correct" option)
* `i = i + 1`
* `return i`

`i++`:
* `int j = i` Cached value of `i`
* `i = i + 1`
* `return j`

**Examples**:

`int i = 0`

`int x = i++` (x=0, i=1)

`int y = ++i` (y=2, i=2)

### Example Problem with Aliases

**Example**:
```java
class Weather {
    String description;
    
    Weather(String description) {
        this.description = description;
    }
}

class Examples {
    void F2(Weather s1) {
        Weather s2 = s1;
        s2.weather = "rain";
    }
    
    String question2() {
        Weather sunny = new Weather("sun");
        F2(sunny);
        return sunny.description;
    }
    
    void testWeather(Tester t) {
        // What will this return?
        t.checkExpect(this.question2(), "rain");
    }
}
```

**Example 2**:
```java
class Weather {
    String description;
    
    Weather(String description) {
        this.description = description;
    }
}

class Hurricane {
    String name;
    int severity;
    Weather weather;
    
    Hurricane(String name, int severity, Weather weather) {
        this.name = name;
        this.severity = severity;
        this.weather = weather;
    }
}

class Examples {
    void F3(Weather w1) {
        Hurricane jane = new Hurricane("Jane", 5, w1);
        jane.weather.description = "thunder";
    }
    
    String question3() {
        Weather hail = Weather("hail");
        Hurricane sally = new Hurricane("sally", 3, hail);
        F3(hail);
        return hai.description;
    }
    
    void testWeather(Tester t) {
        // What will this return?
        t.checkExpect(this.question3(), "thunder");
    }
}
```
